{
  "hash": "132497725f60c487be3b17883d67726d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Modelling the impact of fire on the Southern Greater Glider\"\ndescription: |\n  Major fire events impact flora and fauna, particularly in areas where fire can dramatically reshape the livable habitat area. Here we investigate how greater gliders, a tree-dwelling marsupial species, were impacted by the 2019-2020 bushfires using {tidymodels} and {tidysdm}.\nauthor:\n  - name: \"Jarod Wright\"\n  - name: \"Dax Kellie\"\ndate: \"2025-04-02\"\ntitle-block-banner: \"#B8573E\"\ntoc: true\ntoc-location: left\ntoc-depth: 2\ncategories:\n  - Eukaryota\n  - Animalia\n  - Marsupialia\n  - Maps\n  - R\n  - Intern-post\n  - Species distribution modelling\nimage: gliders-map.png\nfreeze: true\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n<!-- remove metadata section -->\n\n```{=html}\n<style>\n  #title-block-header.quarto-title-block.default .quarto-title-meta {\n      display: none;\n  }\n</style>\n```\n\n<!-- Author card -->\n\n::::::: author-card\n::: author-card-text\n#### Author\n\nJarod Wright\\\n[Dax Kellie](https://labs.ala.org.au/about/Kellie_Dax/index.html)\n\n#### Date\n\n2 April 2025\n:::\n\n::::: {.row-b layout-ncol=\"3\" style=\"margin-left: auto; margin-right: auto; margin-top: auto; margin-bottom: auto;\"}\n::: {.author-card-image style=\"width: auto; height: 120px; margin-right: auto !important;\"}\n<img src=\"https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/jarod.png\" style=\"object-fit: cover; border-radius: 50% !important; width: 140px;\"/></img>\n:::\n\n::: {.author-card-image style=\"width: auto; height: 120px; margin-right: auto;\"}\n<img src=\"https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/dax.jpg\" style=\"object-fit: cover; border-radius: 50% !important; width: 140px;\"/></img>\n:::\n:::::\n:::::::\n\n<!------------------------ Post starts here ------------------------>\n\n:::{.callout-tip}\n\n## Intern Post\n\n:::\n\nBush fires are a frequent and natural part of Australia’s ecosystems. Australia's flora and fauna have adapted alongside fire, with some plants [needing fire to germinate and regenerate](https://www.dbca.wa.gov.au/wildlife-and-ecosystems/fire-and-environment/fire-plants-and-vegetation).\n\nAboriginal and Torres Strait Islander people have also expertly [used fire for tens of thousands of years](https://www.sciencedirect.com/science/article/pii/S0016718521000233) to [care for Country](https://www.bushheritage.org.au/what-we-do/our-challenge/fire-management), managing vegetation, reducing wildfire risk, and fostering biodiversity. Since European colonisation, however, the disruption of these practices has created a [build-up of fuel loads](https://wwf.org.au/blogs/new-study-confirms-indigenous-fire-management-equals-success/) and introduced invasive plant species, increasing Australia's risk of larger, uncontrollable fires as temperatures rise.\n\nIn 2019-2020, Australia experienced one of the most catastrophic bushfire seasons on record. Fires burnt approximately [19 million hectares](https://wwf.org.au/what-we-do/australian-bushfires/), of which 12.6 million were primarily forest and bushland. An estimated [900 species](https://www.nature.com/articles/s41586-024-08174-6) of plants and animals were severely impacted, and [3 billion animals were killed or displaced](https://wwf.org.au/what-we-do/australian-bushfires/).\n\nIn this post we will explore the impact of the 2019-2020 bushfires on a population of greater gliders (*Petauroides volans*), a forest-dwelling marsupial species found along the east coast of Australia. We'll determine greater gliders' overall habitat range using [tidymodels](https://www.tidymodels.org/) and [tidysdm](https://evolecolgroup.github.io/tidysdm/), then use the output of our model to explore whether the impact of fire on greater glider observations since 2019-2020.\n\nTo begin, we can load the following packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(galah)\nlibrary(tidyverse)\nlibrary(tidymodels) \nlibrary(tidysdm) # devtools::install_github(\"EvolEcolGroup/tidysdm\")\nlibrary(ranger)\nlibrary(terra)\nlibrary(tidyterra)\nlibrary(here)\nlibrary(sf)\nlibrary(ozmaps)\nlibrary(elevatr)\nlibrary(geodata)\nlibrary(stacks)\n```\n:::\n\n\nWe are interested in testing whether observations of gliders changed in areas burnt by the 2019/2020 Black Summer bushfires compared to those that remained unburnt.\n\nThat means we'll need a few components for our investigation:\n\n-   Data of greater glider observations made before and after the fires\n-   Environmental variables that determine greater gliders' likely habitat range\n-   The extent of area burnt by the 2019-2020 bushfires\n\nOur hypothesised effect is that there are *fewer* occurrences of greater gliders after the fire, and a driver of this effect is that *an area was previously burnt* during the 2019/2020 bushfires.\n\nFirst, let's establish our study area and download records of our species of interest.\n\n# Download data\n\n## Observational data\n\nThe Southern Greater Glider (*Petauroides volans*) is Australia’s largest gliding marsupial, found in tall eucalypt forests along the east coast, from Queensland to Victoria. They are an endagered nocturnal, tree-dwelling herbivore that primarily feed on eucalyptus leaves and den in hollow bear trees[^1].\n\n[^1]: Southern greater gliders grow up to 1m long from head to tail and can glide up to 100 metres through the canopy!\n\n::: {layout-ncol=\"2\" style=\"margin-left: auto; margin-right: auto;\"}\n<img src=\"https://ala-images.s3.ap-southeast-2.amazonaws.com/store/2/1/0/8/e0bec186-b95a-4a50-8ce3-824143268012/original\" class=\"rounded\"/></img>\n\n<img src=\"https://ala-images.s3.ap-southeast-2.amazonaws.com/store/c/4/c/e/a0428bcf-f667-4f43-80b5-5ba1dc40ec4c/original\" class=\"rounded\"/></img>\n:::\n\n::: figure-caption\nLeft: [*Petauroides volans* (Josh Bowell \\| CC-BY-NC 3.0 (Au))](https://biocache.ala.org.au/occurrences/fde509c4-f493-46fc-9ae5-bab9fe2fc621), Right: [*Petauroides volans* (David Sinnott \\| CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/65b74308-6e20-40f1-ac34-0b8f65a468bd)\n:::\n\nWe're going to focus on a region of South-East New South Wales and the Australian Captial Territory for our investigation. To start, let's establish a bounding box around our area in a few different formats (`tibble`, `SpatExtent` and `sf`). We'll also pull in a map of Australia for later rendering and working with our rasters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# define geographic region of bounding box\n# tibble format is handy for plotting\nse_nsw_bbox <- tibble(\n  ymin = -37.5,\n  ymax = -35,\n  xmin = 148.5,\n  xmax = 151\n)\n# Create a terra extent \n# SpatExtent objects are used for modifying raster layers later on\nbbox_ext <- terra::ext(\n  c(se_nsw_bbox[[\"xmin\"]], \n    se_nsw_bbox[[\"xmax\"]], \n    se_nsw_bbox[[\"ymin\"]], \n    se_nsw_bbox[[\"ymax\"]]\n  ))\n\n# Create an sf object of our bounding box\n# sf object will help specify elevation data later on\nbbox_sf <- st_as_sf(as.polygons(bbox_ext, crs = \"EPSG:4326\"))\n\n# Get outline of Australia\naus <- ozmaps::ozmap_country |>\n  st_transform(crs = \"EPSG:4326\")\n```\n:::\n\n\n::: aside\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n:::\n\nNow let's use the [galah package](https://galah.ala.org.au/) to download greater glider records from the [Atlas of Living Australia](https://www.ala.org.au/) over a 10-year time period from 2014 to 2024, which captures observations of greater gliders before and after the 2019-2020 bushfires. Passing our `se_nsw_bbox` to `galah_geolocate()` will return only the records in our bounding box. You'll need to [register your email address with the ALA](https://auth.ala.org.au/userdetails/registration/createAccount), then pass it to galah using `galah_config()`.\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngalah_config(email = \"your-email-here\") # Registered ALA email\n\n# Collect all greater glider records between 2014 and 2024 for the region we defined\ngliders <- galah_call() |>\n  identify(\"Petauroides volans\") |>\n  filter(year >= 2014 & year <= 2024) |>\n  galah_apply_profile(ALA) |>\n  galah_geolocate(se_nsw_bbox, type = \"bbox\") |>\n  atlas_occurrences()\n\n# Create an sf object for spatial analysis & mapping\ngliders_sf <- gliders |>\n  st_as_sf(coords = c(\"decimalLongitude\", \"decimalLatitude\")) |>\n  st_set_crs(4326)\n```\n:::\n\n\n::: aside\n\n::: {.cell}\n::: {.cell-output-display}\n![Greater Glider Observations (2014-2024)](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n:::\n\n### Before or after fire {#before-or-after-fire}\n\nLet's add a new column `fire_period` to categorise whether an observation was recorded before or after the fires. Fires lasted over several months so it's difficult to pinpoint an *exact* cut-off date. Let's choose the 1st of December 2019 as a cut-off between `pre_fire` and `post_fire`, which marks the beginning of peak bush fire season. Many of the largest bush fires had moved into our study area by this point in time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Classify each glider record as pre or post fire\ngliders_sf <- gliders_sf |>\n  mutate(\n    fire_period = if_else(eventDate < as.Date(\"2019-12-01\"), \"pre_fire\", \"post_fire\"),\n    .before = eventDate # position the column so we can see it\n    )\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot() +\n  geom_sf(data = aus, fill = \"grey97\", color = \"grey40\") +\n  geom_rect(data = se_nsw_bbox,\n            mapping = aes(xmin = xmin, \n                          ymin = ymin, \n                          xmax = xmax, \n                          ymax = ymax),\n            colour = \"grey50\",\n            fill = NA) + \n  geom_sf(data = gliders_sf, \n          aes(color = fire_period), \n          size = 2, \n          alpha = 0.7) +\n  scale_colour_manual(values = c(\"#0F3F5C\", \"#CF5F37\")) +\n  labs(color = \"Fire Period\") +\n  coord_sf(xlim = c(se_nsw_bbox$xmin, se_nsw_bbox$xmax), \n           ylim = c(se_nsw_bbox$ymin, se_nsw_bbox$ymax)) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![Greater glider observations before and after the 2019-2020 bushfires](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nNow that we have greater glider observations, we can start pulling in our raster data for our model.\n\n## Spatial data\n\nThere are a few environmental factors that are useful for determining the suitable habitat area for greater gliders. With the help of previous studies on gliders[^2], we've chosen to download the following four raster layers[^3] to use as environmental predictors in our species distribution model:\n\n[^2]: e.g. [Smith et al. 2007](https://www.publish.csiro.au/WR/WR06063); [Ridley et al. 2024](https://onlinelibrary.wiley.com/doi/full/10.1111/aec.13582)\n\n[^3]: For more info about what rasters are, see the [\"What's a raster\" section from this ALA Labs article](https://labs.ala.org.au/posts/2024-04-30_sdm-tidymodels/#download-environmental-data).\n\n1.  Elevation (from the [elevatr package](https://github.com/USEPA/elevatr))\n2.  Tree cover (from [Global Land Analysis & Discovery](https://glad.umd.edu/dataset/global-2010-tree-cover-30-m))\n3.  Mean annual temperature (BIO1) (from [CHELSA](https://chelsa-climate.org/))\n4.  Annual precipitation (BIO12) (from [CHELSA](https://chelsa-climate.org/))\n\nTo assess bush fire impact, we will also need to download a fifth raster layer that maps the area burnt over the 2019-2020 bushfires:\n\n5.  Fire extent and severity mapping (2019-2020) (from the [NSW government](https://datasets.seed.nsw.gov.au/dataset/fire-extent-and-severity-mapping-fesm-2019-20))\n\nEach raster layer will need to be wrangled so that they fit neatly together (same area, same projection, same resolution). We will perform a common series of modifications to each layer that generally fall into the following steps:\n\n-   **Crop** the layer to our study area\n-   **Mask** (or remove) the ocean from our layer so that it does not skew our model\n-   **Rename** the layer to something sensible\n-   **Resample** each layer to the same resolution (so that every layer's grid aligns correctly)\n\nThese steps might not always be in the same order, but you will recognise them as we go through the next few sections to download our spatial data.\n\n#### Elevation\n\nFirst we'll download elevation data for our defined region using the `{elevatr}` package's handy `get_elev_raster()` function. By passing our bounding box `bbox_sf` to the `locations` argument we can return elevation data (in metres) for our specified area!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Download elevation raster\nelevation_data <- get_elev_raster(locations = bbox_sf, \n                                  z = 9, \n                                  prj = \"EPSG:4326\")\n\n# Remove raster information outside of the aus land boundary\nelevation_aligned <- elevation_data |>\n  terra::rast() |>      # convert to SpatRaster class\n  terra::mask(aus) |>   # remove information outside of aus boundary\n  terra::crop(bbox_ext) # crop layer to bbox\n\n# Rename layer for simplicity\nnames(elevation_aligned) <- \"elevation\"\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot() +\n  geom_spatraster(data = elevation_aligned, aes(fill = elevation)) +\n  scale_fill_terrain_c(na.value = NA) +\n  guides(fill = guide_colorbar(title = \"Elevation (m)\")) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![Elevation in metres](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n#### Tree cover\n\nNext we'll download tree cover data. This tree cover raster layer contains satellite data from [Hansen et al (2010)](https://glad.umd.edu/dataset/global-2010-tree-cover-30-m) where tree cover is recorded as a percentage (`0` = no cover and `100` = complete tree cover).\n\nSpatial data are held on the [Global Land Analysis and Discovery website](https://glad.umd.edu/). Tree cover data files are divided in tiles of 10 x 10 latitude/longitude. Because our study area crosses over two tiles (`30S_150` and `30S_140`), we will need to download and stitch together two rasters. We can then crop them down to our specified area.\n\n**2026 UPDATE: See the box below** ~~To download the files, go to the [global 2010 treecover dataset](https://glad.umd.edu/dataset/global-2010-tree-cover-30-m) --\\> click on the url link under the **Data Links** subheading near the bottom of the page --\\> click on the relevant data links to download. The two file names we are interested in are: `treecover2010_30S_140E.tif` and `treecover2010_30S_150E.tif`. Save these files in your local working directory.~~\n\n:::{.callout-warning}\n\n##### Treecover dataset webpage \"Forbidden\"\n\nNavigating to the link above to download data returns a \"Forbidden\" page as of 12 Jan, 2026. I have contacted GLAD to ask if they might amend access to this page. In the meantime, for the sake of reproducibility, I have made my local version of these two layers available for download.\n\n{{< downloadthis ../data/tree-cover/treecover2010_30S_150E.tif label=\"Download tree_cover_150\" icon=database-fill-down type=info class=data-button >}}\n\n{{< downloadthis ../data/tree-cover/treecover2010_30S_140E.tif label=\"Download tree_cover_140\" icon=database-fill-down type=info class=data-button >}}\n\n[Data citation: Hansen, M.C., Potapov, P.V., Moore, R., Hancher, M., Turubanova, S.A., Tyukavina, A., Thau, D., Stehman, S.V., Goetz, S.J., Loveland, T.R., Kommareddy, A., Egorov, A., Chini, L., Justice, C.O., and Townshend, J.R.G., 2013, High-Resolution Global Maps of 21st-Century Forest Cover Change: Science, v. 342, no. 6160, p. 850-853, at\nhttp://www.sciencemag.org/content/342/6160/850.abstract.]{style=\"font-size:.7rem;\"}\n\n:::\n\nLet's load our files into R as rasters.\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the raster\ntree_cover_150 <- terra::rast(here(\"treecover2010_30S_150E.tif\"))\ntree_cover_140 <- terra::rast(here(\"treecover2010_30S_140E.tif\"))\n```\n:::\n\n\nNow we can crop them to our study area and merge them together.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Crop to bbox\ntree_cover_150_cropped <- tree_cover_150 |> terra::crop(bbox_ext)\ntree_cover_140_cropped <- tree_cover_140 |> terra::crop(bbox_ext)\n\n# Merge\ntree_cover <- merge(tree_cover_150_cropped, tree_cover_140_cropped)\n\n# Rename for simplicity\nnames(tree_cover) <- \"treecover\"\n```\n:::\n\n\n::: {.callout-note collape=\"true\"}\n##### Best practice\n\nWhen working with spatial data we tend to use up a lot of memory! That's a big reason why we are performing these cropping steps---so that we can use up the least amount of memory necessary to get our model to function. Because of this, after we have stitched our two rasters together, we should safely delete the other two as we will no longer require them to clear space.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# We can now safely delete the first two raster files to save memory\nrm(tree_cover_140); rm(tree_cover_150)\n```\n:::\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot() +\n  geom_spatraster(data = tree_cover, aes(fill = treecover)) +\n  scale_fill_viridis_c(direction = -1, begin = 0.8, end = 0.1) +\n  guides(fill = guide_colorbar(title = \"Tree Cover (%)\")) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![Tree cover (%)](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n#### Temperature & precipitation\n\nNext we’ll download two bioclimatic raster layers from [CHELSA](https://chelsa-climate.org/). CHELSA hosts climate projections at high resolutions intended for ecological use ([here's the paper about it](https://doi.org/10.1038/sdata.2017.122)). Climate projections extend from 1981 to 2100. Vegetation that greater gliders inhabit is sensitive to temperature and precipitation changes, so we decided to use climate projections for 2011-2040 for the following two climate variables:\n\n-   BIO1: Mean Annual Temperature\n-   BIO12: Annual Precipitation\n\nTo download these layers on the [CHELSA website](https://chelsa-climate.org/), click on 'Downloads' in the top bar, under version 2.1 click the 'Download' button, then navigate to `GLOBAL/*` --\\> `climatologies/` --\\> `UKESM1-0-LL` --\\> `ssp370/` --\\> `bio/`. Then select the files with names beginning with `CHELSA_bio1_2011-2040` and `CHELSA_bio12_2011-2040`. Save these files in your local directory.\n\n<details>\n\n<summary>Use code to download</summary>\n\nAlternatively, we can use the following code chunk to download files:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Download our two raster files\ndownload.file(\"https://os.zhdk.cloud.switch.ch/chelsav2/GLOBAL/climatologies/2011-2040/UKESM1-0-LL/ssp370/bio/CHELSA_bio1_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif\",\n              destfile=\"CHELSA_bio1_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif\", mode=\"wb\")  \n\ndownload.file(\"https://os.zhdk.cloud.switch.ch/chelsav2/GLOBAL/climatologies/2011-2040/UKESM1-0-LL/ssp370/bio/CHELSA_bio12_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif\",\n              destfile=\"CHELSA_bio12_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif\", mode=\"wb\") \n```\n:::\n\n\n</details>\n\n\n::: {.cell}\n\n:::\n\n\nLet's load our files into R as rasters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp <- rast(\"CHELSA_bio1_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif\")\nprecip <- rast(\"CHELSA_bio12_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif\")\n```\n:::\n\n\nNow we'll mask and crop each layer, then rename them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# mask and crop to study area\ntemp <- temp |>\n  terra::mask(aus) |>   # remove oceans\n  terra::crop(bbox_ext) # crop to bbox\n\nprecip <- precip |>\n  terra::mask(aus) |>   # remove oceans\n  terra::crop(bbox_ext) # crop to bbox\n\n# Rename for simplicity\nnames(temp) <- \"temp_bio1\"\nnames(precip) <- \"precip_bio12\"\n```\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell .fig-column-body-outset layout-nrow=\"1\" layout-ncol=\"2\" layout-align=\"center\"}\n::: {.cell-output-display}\n![Mean Annual Temperature (BIO1)](index_files/figure-html/unnamed-chunk-22-1.png){fig-align='center' width=672}\n:::\n\n::: {.cell-output-display}\n![Annual Precipitation (BIO12)](index_files/figure-html/unnamed-chunk-22-2.png){fig-align='center' width=672}\n:::\n:::\n\n\n#### Burnt area\n\n<!-- \nNote to authors: \n\nThe data in this section is too large to save on the normal Teams directory. The cropped raster is saved in /data/fire_extent/cvmsre_NSW_20192020_ag1l0.tif to enable this Labs Post to render. However, to test the method used to crop the larger file will require you to download the entire raster to your local computer (following the intstructions written in the Post below).\n\n\nThe process to crop the larger file was failing but now it works. Keep an eye on it. To allow people to see the outputs but avoid having to run this process when rendering, I've manually pasted the output in a few sections. This *might* need updating in the future. The point was to allow users to see what the output even looks like if it runs correctly.\n-->\n\nFinally, we will download a fire extent raster layer, documenting the area burnt by the 2019-2020 bushfires in New South Wales. The NSW Government’s [Fire Extent and Severity Mapping (FESM) 2019/20 dataset](https://datasets.seed.nsw.gov.au/dataset/fire-extent-and-severity-mapping-fesm-2019-20) contains information on the extent and severity of burnt areas across the state.\n\nTo download, navigate to the [NSW Government website](https://datasets.seed.nsw.gov.au/dataset/fire-extent-and-severity-mapping-fesm-2019-20), click on 'Dataset Packages', then select the download icon next to 'FESM v3-data in IMG and TIFF format'. Save this zip folder in your working directory and uncompress the folder.\n\n::: {.callout-warning collapse=\"true\"}\n##### Warning: Big zip folder\n\nWhile the download itself is only several hundred megabytes, when uncompressed the .tif file is *very* large (10.3 GB). Please keep this in mind when choosing a place to store the folder!\n:::\n\nLet's load the fire extent layer into R as a raster.\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load raster\nfire_extent <- rast(\"cvmsre_NSW_20192020_ag1l0.tif\")\n```\n:::\n\n\nThis file is pretty huge *and* it's in the wrong projection, which we can see under `coord. ref` when we view the object. Our desired CRS is `WGS84`/`EPSG:4326` but this raster is projected using CRS `GDA_94_Lambert`, which affects the extent and coordinates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfire_extent\n```\n:::\n\n\n```\nclass       : SpatRaster \ndimensions  : 103386, 107910, 1  (nrow, ncol, nlyr)\nresolution  : 9.993738, 9.993738  (x, y)\nextent      : 8857447, 9935872, 4022290, 5055502  (xmin, xmax, ymin, ymax)\ncoord. ref. : GDA94_NSW_Lambert \nsource      : cvmsre_NSW_20192020_ag1l0.tif \ncolor table : 1 \nname        : Layer_1 \n```\n\nThis poses an issue for us. Reprojecting the entire file to `WGS84` (like we have for other rasters) will take up a lot of processing time and memory if we do this reprojection as a first step.\n\nTo save time and memory, let's use an alternative method of cropping first and reprojecting second. We'll first crop `fire_extent` to our desired study area by taking our original `bbox_ext` object and matching its projection to the CRS of `fire_extent`. We'll use `bbox_ext_gda94` to crop `fire_extent` to a much smaller area. Then, second, we can reproject our `fire_extent_cropped` object to the correct projection (and crop again to be certain our layer matches with other layers).\n\nFirst let's convert our bounding box `bbox_ext`, convert it to a polygon and reproject that polygon to use the CRS of `fire_extent`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert bbox to polygon with new projection that matches fire_extent\nbbox_ext_gda94 <- bbox_ext |> \n  terra::as.polygons(\n    crs = gliders_sf           # set crs to match glider data\n    ) |>\n  terra::project(fire_extent)  # reproject crs to match fire_extent\n\nbbox_ext_gda94\n```\n:::\n\n\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 1, 0  (geometries, attributes)\n extent      : 9432876, 9664886, 4021704, 4305054  (xmin, xmax, ymin, ymax)\n coord. ref. : GDA94_NSW_Lambert \n```\n\nNow we can use our new bounding box `bbox_ext_gda94` to crop `fire_extent` to our study area, then reproject it to our desired CRS `WGS84`. When complete, you'll notice the `extent` and `coord. ref.` or `fire_extent_cropped` have changed to match our expected bounding box and CRS.\n\n::: callout-warning\n##### This process takes a while to run\n\nThe next few steps to crop and reproject `fire_extent` takes \\~5 minutes to run.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Crop fire_extent using the reprojected bbox, then reproject to WGS84\nfire_extent_cropped <- fire_extent |>\n  terra::crop(bbox_ext_gda94) |>\n  terra::project(crs(gliders_sf))   # reproject to match glider data\n\nfire_extent_cropped\n```\n:::\n\n\n```\nclass       : SpatRaster \ndimensions  : 26110, 26732, 1  (nrow, ncol, nlyr)\nresolution  : 9.962733e-05, 9.962733e-05  (x, y)\nextent      : 148.4563, 151.1196, -37.54717, -34.9459  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : spat_38b02a6426e6_14512_80Q6udnsxVen2Mq.tif \nname        : Layer_1 \nmin value   :       0 \nmax value   :       5 \n```\n\nIf there are a few tailing decimal places that appeared while converting the `extent` of `fire_extent_cropped`, we can crop it again using `bbox_ext` to make sure it matches other rasters (the `extent` will slightly but noticeably change).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfire_extent_cropped <- fire_extent_cropped |>\n  terra::crop(bbox_ext)\n```\n:::\n\n\nWe'll now mask out the ocean and rename the layer like we did for other layers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remove ocean\nfire_extent_cropped <- fire_extent_cropped |>\n    terra::mask(aus)\n\n# Rename for simplicity\nnames(fire_extent_cropped) <- \"fire_extent\"\n\nfire_extent_cropped\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 2053, 2054, 1  (nrow, ncol, nlyr)\nresolution  : 0.001217593, 0.001217593  (x, y)\nextent      : 148.4994, 151.0003, -37.5001, -35.00038  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource(s)   : memory\nvarname     : cvmsre_NSW_20192020_ag1l0 \nname        : fire_extent \nmin value   :           0 \nmax value   :           5 \n```\n\n\n:::\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n##### Save your cropped layer\n\nNow would be a good time to save your new cropped raster layer locally. This cropped raster layer is *much* smaller than our original layer, and it will be easier (and faster) to use this smaller layer in a workflow. Just be sure to document where you downloaded the larger file and the process you used to crop it!\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot() +\n  geom_spatraster(data = fire_extent_cropped, aes(fill = fire_extent)) +\n  scale_fill_princess_c(palette = \"america\")  +\n  guides(fill = guide_colorbar(title = \"Fire Severity\")) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![Fire Severity](index_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\nThe `fire_extent` layer contains information of the fire's severity on a scale from 0 (unburnt) to 5 (extreme). For our purposes, we are mainly interested in whether the area was affected by fire or not, rather than its severity.\n\n::: {.callout-note collapse=\"true\"}\n##### Fire severity values\n\nIf you are interested, the `fire_extent` dataset categorises fire severity using the following values:\n\n-   0 - Unburnt (0% canopy and understory burnt)\n-   1 - Reserved (Experimental category, is not used in raster right now)\n-   2 - Low (\\> 10% burnt upderstory, \\>90% green canopy)\n-   3 - Moderate (20-90% canopy scorch)\n-   4 - High (\\> 90% canopy scorched, \\<50% canopy consumed)\n-   5 - Extreme (\\>50% canopy biomass consumed)\n:::\n\nFor simplicity, let's recode `fire_extent` to whether an area is burnt or unburnt and save this info in a new column `burnt`. We'll use a dummy variable to make our results easier to interpret where burnt is `1` and unburnt is `-1`. Then we'll rename the layer.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nburnt_cropped <- fire_extent_cropped |>\n  mutate(\n    # make `burnt` column\n    burnt = case_when(\n      fire_extent >= 1 ~ 1, # burnt\n      fire_extent == 0 ~ -1, # unburnt\n      .default = NA_integer_\n    )\n  ) |>\n  select(-fire_extent) # remove fire_extent column\n\n# Rename for simplicity\nnames(burnt_cropped) <- \"burnt\"\n\nburnt_cropped\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 2053, 2054, 1  (nrow, ncol, nlyr)\nresolution  : 0.001217593, 0.001217593  (x, y)\nextent      : 148.4994, 151.0003, -37.5001, -35.00038  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource(s)   : memory\nname        : burnt \nmin value   :    -1 \nmax value   :     1 \n```\n\n\n:::\n:::\n\n\n### Match resolution\n\nA final important step is to make sure our layers are projected at the same resolution. Aligning rasters allows for more accurate and reliable results because grid cells won't overlap in unexpected ways (which would affect our model). Typically, the resolution should match the layer with the lowest resolution. In our case, this is `elevation_aligned` layer, which you can see if you print the object to the console and compare with other layers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelevation_aligned\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 2053, 2054, 1  (nrow, ncol, nlyr)\nresolution  : 0.001217593, 0.001217593  (x, y)\nextent      : 148.4994, 151.0003, -37.5001, -35.00038  (xmin, xmax, ymin, ymax)\ncoord. ref. : +proj=longlat +datum=WGS84 +no_defs \nsource(s)   : memory\nvarname     : file7ed462946383 \nname        : elevation \nmin value   :      -728 \nmax value   :      1901 \n```\n\n\n:::\n:::\n\n\nLet's resample each layer to match the resolution of `elevation_aligned` using `terra::resample()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Resample our tree cover to the resolution of the elevation data\ntree_cover <- terra::resample(tree_cover, elevation_aligned)\ntemp <- terra::resample(temp, elevation_aligned)\nprecip <- terra::resample(precip, elevation_aligned)\nburnt <- terra::resample(burnt_cropped, elevation_aligned)\n```\n:::\n\n\n### Combine spatial layers\n\nWe can now combine all of our raster layers into one object containing:\n\n-   Elevation\n-   Tree cover\n-   Mean annual temperature (BIO1)\n-   Annual precipitation (BIO12)\n-   Burnt area from the 2019-2020 bushfires\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombined_rasters <- c(elevation_aligned, tree_cover, temp, precip, burnt)\n\ncombined_rasters\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 2053, 2054, 5  (nrow, ncol, nlyr)\nresolution  : 0.001217593, 0.001217593  (x, y)\nextent      : 148.4994, 151.0003, -37.5001, -35.00038  (xmin, xmax, ymin, ymax)\ncoord. ref. : +proj=longlat +datum=WGS84 +no_defs \nsource(s)   : memory\nvarnames    : file7ed462946383 \n              file7ed462946383 \n              file7ed462946383 \n              ...\nnames       : elevation, treecover, temp_bio1, precip_bio12, burnt \nmin values  :      -728,   0.00000,  6.293441,     468.7325,    -1 \nmax values  :      1901,  94.93295, 18.281870,    1358.0767,     1 \n```\n\n\n:::\n:::\n\n\nPhew! That was a lot of data preparation. But with our spatial data sorted, we are now ready to begin preparing our model!\n\n# Build our model\n\nIf you're new to species distribution modeling (SDM) or want a deeper dive into the details of species distribution modelling using tidymodels, check out [this ALA Labs post](https://labs.ala.org.au/posts/2024-04-30_sdm-tidymodels/). We'll use a similar workflow but will spend less time explaining the ins-and-outs of how species distribution modelling works.\n\n### Prepare data\n\nFirst, we will **thin** our data so that there is only one glider observation in any individual grid cell, so that each grid cell contains a \"presence\" or \"absence\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngliders_thin <- tidysdm::thin_by_cell(gliders_sf, \n                                      raster = combined_rasters)\n```\n:::\n\n\n::: aside\n\n::: {.cell}\n::: {.cell-output-display}\n![Thinned observations](index_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n:::\n\n:::\n\nNext, we will add *pseudo-absences*[^4] to our data because our glider observations from the ALA are presence-only[^5].\n\n[^4]: Pseudo-absences, also called background points, are points that represent true absences in our data for modelling. They are there to help our model make predictions about what variables more strongly predict a presence vs an absence. Because we don't have true presence data, this is one way to provide a model this information, though it is less informative for our interpretation.\n\n[^5]: They only provide information about the conditions of when a glider was observed but no information about when gliders *aren't* observed\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate pseudo-absences\ngliders_pseudoabs <- tidysdm::sample_pseudoabs(\n  gliders_thin,\n  n = 3 * nrow(combined_rasters), \n  raster = combined_rasters,\n  method = c(\"dist_min\", tidysdm::km2m(5))\n  )\n\n# Extract environmental data for each pseudo-absence\ngliders_pseudoabs <- gliders_pseudoabs |>\n  # Extract tree cover, elevation and climate values for pseudoabs points\n  bind_cols(\n  terra::extract(combined_rasters,\n                 gliders_pseudoabs,\n                 ID = FALSE)\n  )\n\ngliders_pseudoabs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 7861 features and 6 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 148.5 ymin: -37.49949 xmax: 150.8049 ymax: -35.00099\nGeodetic CRS:  GEOGCRS[\"unknown\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ID[\"EPSG\",6326]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433],\n        ID[\"EPSG\",8901]],\n    CS[ellipsoidal,2],\n        AXIS[\"longitude\",east,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]],\n        AXIS[\"latitude\",north,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]]]\n# A tibble: 7,861 × 7\n   class                geometry elevation treecover temp_bio1 precip_bio12\n * <fct>             <POINT [°]>     <dbl>     <dbl>     <dbl>        <dbl>\n 1 presence (150.2831 -35.39945)       132      87.6     16.9          965.\n 2 presence  (149.4786 -36.0617)      1238      74.9     10.2          843.\n 3 presence (149.5959 -36.83313)       516      84.3     13.3          922.\n 4 presence (148.8219 -37.14629)      1065      89.7     10.2          933.\n 5 presence (149.5117 -36.16433)      1015      87.9     11.2          885.\n 6 presence   (149.5155 -35.597)      1045      87.9     11.3          773.\n 7 presence  (149.523 -36.22319)       874      76.6     12.0          847.\n 8 presence  (149.507 -35.80711)      1303      78.7      9.99         856.\n 9 presence (150.2892 -35.65361)        38      84.8     17.5         1048.\n10 presence (148.8348 -37.13295)       935      87.6     10.8          915.\n# ℹ 7,851 more rows\n# ℹ 1 more variable: burnt <dbl>\n```\n\n\n:::\n:::\n\n\nAnd we'll join our pseudo-absences to our thinned presence data `gliders_thin` to attach any missing columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngliders_joined <- gliders_pseudoabs |>\n    st_join(\n    gliders_thin, \n    left = TRUE\n    )\n\ngliders_joined\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 7861 features and 13 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 148.5 ymin: -37.49949 xmax: 150.8049 ymax: -35.00099\nGeodetic CRS:  GEOGCRS[\"unknown\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ID[\"EPSG\",6326]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433],\n        ID[\"EPSG\",8901]],\n    CS[ellipsoidal,2],\n        AXIS[\"longitude\",east,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]],\n        AXIS[\"latitude\",north,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]]]\n# A tibble: 7,861 × 14\n   class                geometry elevation treecover temp_bio1 precip_bio12\n * <fct>             <POINT [°]>     <dbl>     <dbl>     <dbl>        <dbl>\n 1 presence (150.2831 -35.39945)       132      87.6     16.9          965.\n 2 presence  (149.4786 -36.0617)      1238      74.9     10.2          843.\n 3 presence (149.5959 -36.83313)       516      84.3     13.3          922.\n 4 presence (148.8219 -37.14629)      1065      89.7     10.2          933.\n 5 presence (149.5117 -36.16433)      1015      87.9     11.2          885.\n 6 presence   (149.5155 -35.597)      1045      87.9     11.3          773.\n 7 presence  (149.523 -36.22319)       874      76.6     12.0          847.\n 8 presence  (149.507 -35.80711)      1303      78.7      9.99         856.\n 9 presence (150.2892 -35.65361)        38      84.8     17.5         1048.\n10 presence (148.8348 -37.13295)       935      87.6     10.8          915.\n# ℹ 7,851 more rows\n# ℹ 8 more variables: burnt <dbl>, recordID <chr>, scientificName <chr>,\n#   taxonConceptID <chr>, fire_period <chr>, eventDate <dttm>,\n#   occurrenceStatus <chr>, dataResourceName <chr>\n```\n\n\n:::\n:::\n\n\n::: aside\n\n::: {.cell}\n::: {.cell-output-display}\n![Presence and pseudo-absence points](index_files/figure-html/unnamed-chunk-39-1.png){width=672}\n:::\n:::\n\n:::\n\n[Earlier](#before-or-after-fire), we categorised our greater glider observations as `pre_fire` or `post_fire`. We will need to categorise our pseudo-absences into the same categories. Doing so allows our model to generate a *probability* of presence in both conditions.\n\nAs a simple way to categorise our pseudo-absence points, we'll use `sample()` to randomly assign them to `pre_fire` or `post-fire` which will assign a more-or-less equal number of randomly selected pseudo-absence points for both timeframes[^6]. Doing this with `case_when()` allows us to conditionally assign a new category only when there isn't one already (i.e. only for pseudo-absence points).\n\n[^6]: For this analysis, it doesn't really matter whether we have a *perfect* split.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assign `pre_fire` and `post_fire` categories to pseudoabsences\ngliders_categorised <- gliders_joined |>\n  mutate(\n    fire_period = case_when(\n      # If there is no category already, sample one\n      is.na(fire_period) ~ sample(c(\"pre_fire\", \"post_fire\"),\n                                  size = nrow(gliders_joined),\n                                  replace = TRUE),\n      .default = fire_period\n    )\n  ) |>\n  select(1:2, fire_period, everything()) # reorder\n\ngliders_categorised\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 7861 features and 13 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 148.5 ymin: -37.49949 xmax: 150.8049 ymax: -35.00099\nGeodetic CRS:  GEOGCRS[\"unknown\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ID[\"EPSG\",6326]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433],\n        ID[\"EPSG\",8901]],\n    CS[ellipsoidal,2],\n        AXIS[\"longitude\",east,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]],\n        AXIS[\"latitude\",north,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]]]\n# A tibble: 7,861 × 14\n   class                geometry fire_period elevation treecover temp_bio1\n   <fct>             <POINT [°]> <chr>           <dbl>     <dbl>     <dbl>\n 1 presence (150.2831 -35.39945) post_fire         132      87.6     16.9 \n 2 presence  (149.4786 -36.0617) post_fire        1238      74.9     10.2 \n 3 presence (149.5959 -36.83313) pre_fire          516      84.3     13.3 \n 4 presence (148.8219 -37.14629) pre_fire         1065      89.7     10.2 \n 5 presence (149.5117 -36.16433) post_fire        1015      87.9     11.2 \n 6 presence   (149.5155 -35.597) post_fire        1045      87.9     11.3 \n 7 presence  (149.523 -36.22319) post_fire         874      76.6     12.0 \n 8 presence  (149.507 -35.80711) post_fire        1303      78.7      9.99\n 9 presence (150.2892 -35.65361) post_fire          38      84.8     17.5 \n10 presence (148.8348 -37.13295) pre_fire          935      87.6     10.8 \n# ℹ 7,851 more rows\n# ℹ 8 more variables: precip_bio12 <dbl>, burnt <dbl>, recordID <chr>,\n#   scientificName <chr>, taxonConceptID <chr>, eventDate <dttm>,\n#   occurrenceStatus <chr>, dataResourceName <chr>\n```\n\n\n:::\n:::\n\n\n::: aside\n\n::: {.cell}\n::: {.cell-output-display}\n![Pseudo-absences, assigned to `pre-fire` or `post-fire`](index_files/figure-html/unnamed-chunk-41-1.png){width=672}\n:::\n:::\n\n:::\n\nTo make the modelled results of our `fire_period` column easier to interpret, let's reformat our categories to a dummy variable format, where `pre_fire` is `-1` and `post_fire` is `1`. Whichever number our coefficient is closer to will tell us which period had more greater glider observations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Change fire period to a dummy variable \ngliders_filtered <- gliders_categorised |>\n  mutate(\n    fire_period = as.numeric(\n      if_else(fire_period == \"post_fire\", 1, -1) # post_fire = 1\n      )\n    )\n\ngliders_filtered |> head(5L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 5 features and 13 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 148.8219 ymin: -37.14629 xmax: 150.2831 ymax: -35.39945\nGeodetic CRS:  GEOGCRS[\"unknown\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ID[\"EPSG\",6326]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433],\n        ID[\"EPSG\",8901]],\n    CS[ellipsoidal,2],\n        AXIS[\"longitude\",east,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]],\n        AXIS[\"latitude\",north,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]]]\n# A tibble: 5 × 14\n  class                geometry fire_period elevation treecover temp_bio1\n  <fct>             <POINT [°]>       <dbl>     <dbl>     <dbl>     <dbl>\n1 presence (150.2831 -35.39945)           1       132      87.6      16.9\n2 presence  (149.4786 -36.0617)           1      1238      74.9      10.2\n3 presence (149.5959 -36.83313)          -1       516      84.3      13.3\n4 presence (148.8219 -37.14629)          -1      1065      89.7      10.2\n5 presence (149.5117 -36.16433)           1      1015      87.9      11.2\n# ℹ 8 more variables: precip_bio12 <dbl>, burnt <dbl>, recordID <chr>,\n#   scientificName <chr>, taxonConceptID <chr>, eventDate <dttm>,\n#   occurrenceStatus <chr>, dataResourceName <chr>\n```\n\n\n:::\n:::\n\n\n### Train our model\n\nOur data is ready to be used for model training and testing. Let's **split** our data into training and testing datasets, allocating \\~75% of points to training and \\~25% to testing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(100)\n\n# Allocate data into training or testing datasets\ngliders_split <- \n  gliders_filtered |>\n  initial_split()\ngliders_split\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<Training/Testing/Total>\n<5895/1966/7861>\n```\n\n\n:::\n\n```{.r .cell-code}\n# Create datasets\ngliders_train <- training(gliders_split)\ngliders_test <- testing(gliders_split)\n```\n:::\n\n\n::: {.panel-tabset .nav-pills}\n##### Train\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngliders_train |> head(5L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 5 features and 13 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 148.6997 ymin: -36.58508 xmax: 149.8954 ymax: -35.03022\nGeodetic CRS:  GEOGCRS[\"unknown\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ID[\"EPSG\",6326]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433],\n        ID[\"EPSG\",8901]],\n    CS[ellipsoidal,2],\n        AXIS[\"longitude\",east,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]],\n        AXIS[\"latitude\",north,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]]]\n# A tibble: 5 × 14\n  class                 geometry fire_period elevation treecover temp_bio1\n  <fct>              <POINT [°]>       <dbl>     <dbl>     <dbl>     <dbl>\n1 pseudoabs (149.5691 -35.03022)           1       957     66.7       12.3\n2 presence   (149.552 -35.87507)           1       979     76.6       11.7\n3 pseudoabs (149.3353 -35.89714)          -1      1128     71.6       10.8\n4 pseudoabs (148.6997 -36.58508)           1       921      7.72      11.8\n5 pseudoabs (149.8954 -36.22467)           1       234     75.7       15.5\n# ℹ 8 more variables: precip_bio12 <dbl>, burnt <dbl>, recordID <chr>,\n#   scientificName <chr>, taxonConceptID <chr>, eventDate <dttm>,\n#   occurrenceStatus <chr>, dataResourceName <chr>\n```\n\n\n:::\n:::\n\n\n##### Test\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngliders_test |> head(5L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 5 features and 13 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 149.055 ymin: -37.25944 xmax: 149.5959 ymax: -35.60257\nGeodetic CRS:  GEOGCRS[\"unknown\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ID[\"EPSG\",6326]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433],\n        ID[\"EPSG\",8901]],\n    CS[ellipsoidal,2],\n        AXIS[\"longitude\",east,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]],\n        AXIS[\"latitude\",north,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]]]\n# A tibble: 5 × 14\n  class                geometry fire_period elevation treecover temp_bio1\n  <fct>             <POINT [°]>       <dbl>     <dbl>     <dbl>     <dbl>\n1 presence (149.5959 -36.83313)          -1       516      84.3     13.3 \n2 presence  (149.507 -35.80711)           1      1303      78.7      9.99\n3 presence  (149.517 -35.60257)          -1      1018      88.6     11.5 \n4 presence (149.5295 -36.16274)          -1       917      88.0     11.8 \n5 presence  (149.055 -37.25944)          -1       711      87.9     12.0 \n# ℹ 8 more variables: precip_bio12 <dbl>, burnt <dbl>, recordID <chr>,\n#   scientificName <chr>, taxonConceptID <chr>, eventDate <dttm>,\n#   occurrenceStatus <chr>, dataResourceName <chr>\n```\n\n\n:::\n:::\n\n:::\n\nNow we'll **resample** our data into *folds* (i.e. smaller resampled datasets) using *block cross-validation*, a type of resampling better-suited to spatial data[^crossval]. We will use these folds to train and tune our model.\n\n[^crossval]: For more info on what this means, see [this section from another ALA Labs article](https://labs.ala.org.au/posts/2024-04-30_sdm-tidymodels/#resampling)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform Cross validation\ngliders_cv <- spatial_block_cv(gliders_train, v = 5)\n\ngliders_cv\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#  5-fold spatial block cross-validation \n# A tibble: 5 × 2\n  splits              id   \n  <list>              <chr>\n1 <split [4784/1111]> Fold1\n2 <split [4641/1254]> Fold2\n3 <split [4864/1031]> Fold3\n4 <split [4349/1546]> Fold4\n5 <split [4942/953]>  Fold5\n```\n\n\n:::\n:::\n\n\nNext, we'll define our model's \"recipe\". We wish to test how our response variable `class` (presence or absence) is affected by each predictor variable (`burnt`, `fire_period`, `elevation`, `temp_bio1`, `temp_bio12`, and `treecover`). We'll also add an interaction between `burnt` and `fire_period` because we expect greater glider occurrences to be more strongly affected in burnt areas *and* after the fires.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngliders_recipe <- recipe(\n  gliders_train, \n  formula = class ~ burnt + fire_period + elevation + temp_bio1 + precip_bio12 + treecover\n  ) |>\n  step_interact(terms = ~burnt:fire_period)\n\ngliders_recipe\n```\n:::\n\n\nNow we can set our workflow, which uses our `gliders_recipe` and training data to train several types of models (see [tidysdm](https://evolecolgroup.github.io/tidysdm/articles/a0_tidysdm_overview.html#fit-the-model-by-cross-validation) for more information on these model specifications).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngliders_models <-\n  workflow_set(\n    preproc = list(default = gliders_recipe), # Use the same recipe for all\n    models = list(\n      glm = sdm_spec_glm(),        # Generalised Linear Model\n      rf = sdm_spec_rf(),          # Random Forest\n      gbm = sdm_spec_boost_tree(), # Gradient Boosting Machine\n      maxent = sdm_spec_maxent()   # Maximum Entropy\n    ),\n    cross = TRUE \n  ) |>\n  option_add(control = control_ensemble_grid())\n\ngliders_models\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A workflow set/tibble: 4 × 4\n  wflow_id       info             option    result    \n  <chr>          <list>           <list>    <list>    \n1 default_glm    <tibble [1 × 4]> <opts[1]> <list [0]>\n2 default_rf     <tibble [1 × 4]> <opts[1]> <list [0]>\n3 default_gbm    <tibble [1 × 4]> <opts[1]> <list [0]>\n4 default_maxent <tibble [1 × 4]> <opts[1]> <list [0]>\n```\n\n\n:::\n:::\n\n\nWe're ready to **tune** and optimise our models using our workflow above and the cross validation blocks we generated earlier. This step helps us find which model parameters and hyperparameters make reasonable predictions.\n\nUsing `autoplot()`, we can quickly see which models performed best using three performance metrics for evaluating species distribution models (`boyce_cont`, `roc_auc` and `tss_max`). In general, results are pretty varied depending on the metric, though Maxent models performed best according to the [Boyce Continuous Index](https://evolecolgroup.github.io/tidysdm/reference/boyce_cont.html).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(9999)\n\n# Tune the model using cross validation\ngliders_models_tune <-\n  gliders_models |>\n  workflow_map(\"tune_grid\",\n               resamples = gliders_cv,     # Use our cross-validation blocks for tuning\n               grid = 6,                   # number of tuning iterations\n               metrics = sdm_metric_set(), # Evaluate model performance\n               verbose = TRUE,\n               control = stacks::control_stack_grid()\n  )\n\ngliders_models_tune\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A workflow set/tibble: 4 × 4\n  wflow_id       info             option    result   \n  <chr>          <list>           <list>    <list>   \n1 default_glm    <tibble [1 × 4]> <opts[4]> <rsmp[+]>\n2 default_rf     <tibble [1 × 4]> <opts[4]> <tune[+]>\n3 default_gbm    <tibble [1 × 4]> <opts[4]> <tune[+]>\n4 default_maxent <tibble [1 × 4]> <opts[4]> <tune[+]>\n```\n\n\n:::\n:::\n\n\n::: aside\n\n::: {.cell}\n\n```{.r .cell-code}\nautoplot(gliders_models_tune)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-49-1.png){width=672}\n:::\n:::\n\n:::\n\nTo help improve accuracy and generalisation of our model predictions, let's \"stack\" our models into an [ensemble model to blend predictions](https://stacks.tidymodels.org/articles/workflowsets.html). Again using `autoplot()`, we can see the relative weighting each model adds to our final prediction.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(98765)\n\ngliders_stacked <- \n  stacks() |>                                # Initialize the stack\n  add_candidates(gliders_models_tune) |>     # Add models\n  blend_predictions() |>                     # Blend their predictions\n  fit_members()                              # Fit the final model\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: The inputted `candidates` argument `default_gbm` generated notes during\ntuning/resampling. Model stacking may fail due to these issues; see\n`collect_notes()` (`?tune::collect_notes()`) if so.\n```\n\n\n:::\n:::\n\n\n::: aside\n\n::: {.cell}\n\n```{.r .cell-code}\n# See model contribution\nautoplot(gliders_stacked, \n         type = \"weights\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-51-1.png){width=672}\n:::\n:::\n\n:::\n\nNow that we have our stacked ensemble model, it’s time to test how well it performs on new data. We do this by making predictions about the points in `gliders_test` and comparing them to the \"true\" results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Predict probability of presence \ngliders_test_predictions <-\n  gliders_test %>%\n  bind_cols(predict(gliders_stacked, ., \n                    type = \"prob\", \n                    save_pred = TRUE)) \n\ngliders_test_predictions |>\n  select(class, .pred_pseudoabs, .pred_presence, everything()) # reorder cols\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 1966 features and 15 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 148.5 ymin: -37.49949 xmax: 150.8037 ymax: -35.00099\nGeodetic CRS:  GEOGCRS[\"unknown\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ID[\"EPSG\",6326]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433],\n        ID[\"EPSG\",8901]],\n    CS[ellipsoidal,2],\n        AXIS[\"longitude\",east,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]],\n        AXIS[\"latitude\",north,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]]]\n# A tibble: 1,966 × 16\n   class    .pred_pseudoabs .pred_presence             geometry fire_period\n   <fct>              <dbl>          <dbl>          <POINT [°]>       <dbl>\n 1 presence           0.855          0.145 (149.5959 -36.83313)          -1\n 2 presence           0.525          0.475  (149.507 -35.80711)           1\n 3 presence           0.371          0.629  (149.517 -35.60257)          -1\n 4 presence           0.479          0.521 (149.5295 -36.16274)          -1\n 5 presence           0.715          0.285  (149.055 -37.25944)          -1\n 6 presence           0.315          0.685 (148.9613 -37.19281)          -1\n 7 presence           0.317          0.683 (148.8443 -37.17765)          -1\n 8 presence           0.375          0.625  (149.0659 -37.1989)          -1\n 9 presence           0.306          0.694 (149.4122 -36.63081)          -1\n10 presence           0.356          0.644 (149.5112 -35.60364)           1\n# ℹ 1,956 more rows\n# ℹ 11 more variables: elevation <dbl>, treecover <dbl>, temp_bio1 <dbl>,\n#   precip_bio12 <dbl>, burnt <dbl>, recordID <chr>, scientificName <chr>,\n#   taxonConceptID <chr>, eventDate <dttm>, occurrenceStatus <chr>,\n#   dataResourceName <chr>\n```\n\n\n:::\n:::\n\n\nUsing `tidysdm::sdm_metric_set()`, we can print several helpful metrics about our model's performance. Overall, our model seems to have performed very well[^7].\n\n[^7]: So well, in fact, that it's plausible it might be [*overfitting*](https://www.tmwr.org/tuning#overfitting-bad), making our model poor for prediction outside of our small spatial bounding box in New South Wales. For our intended analysis, this doesn't matter, but for a model intended for use to make broad future predictions this could pose a problem.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Evaluate performance\ngliders_test_predictions |> \n  sdm_metric_set()(truth = class, .pred_presence)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  .metric    .estimator .estimate\n  <chr>      <chr>          <dbl>\n1 boyce_cont binary         0.990\n2 roc_auc    binary         0.965\n3 tss_max    binary         0.817\n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n##### Specifics about estimates\n\n-   `boyce_cont`: The Boyce Continuous Index is from -1 to 1, where values closer to 1 indicate the model's predictions are consistent with the actual value.\n\n-   `roc_auc`: The Relative Operating Characteristics Area Under the Curve (ROC AUC) is from 0.5 to 1, where a value of 0.5 indicates that the model's predictions are no better than random chance, whereas a value of 1 indicates perfect prediction.\n\n-   `tss_max`: The True Skill Statistic is from -1 to 1, where values closer to 1 indicate better model performance.\n:::\n\n# Greater glider distribution\n\nWe are nearly ready to map our predicted distribution. There's just one final step before predicting a distribution surface.\n\nOur model includes the variable `fire_period`, a categorical variable without an associated spatial layer. However, in order for our model to predict a spatial surface with `fire_period` included (and it must be included because our model uses it), we have to create a raster based on the point locations and values of `fire_period`. We'll follow the same general steps that we did earlier, building a raster, cropping and matching the resolution of the other layers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add fire_period as a spatial layer\nfire_period_rast <- gliders_filtered |>\n  select(fire_period) |>\n  terra::vect() |>                   # convert to vector\n  terra::rast() |>                   # rasterise\n  terra::crop(bbox_ext) |>           # crop to bounding box\n  terra::resample(elevation_aligned) # match resolution\n\n# add fire_period data to raster\nterra::values(fire_period_rast) <- gliders_filtered$fire_period\nnames(fire_period_rast) <- \"fire_period\" # Rename for simplicity\n\nfire_period_rast\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 2053, 2054, 1  (nrow, ncol, nlyr)\nresolution  : 0.001217593, 0.001217593  (x, y)\nextent      : 148.4994, 151.0003, -37.5001, -35.00038  (xmin, xmax, ymin, ymax)\ncoord. ref. : +proj=longlat +datum=WGS84 +no_defs \nsource(s)   : memory\nvarname     : file7ed462946383 \nname        : fire_period \nmin value   :          -1 \nmax value   :           1 \n```\n\n\n:::\n:::\n\n\nNow we can join `fire_period_rast` with the other raster layers\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombined_rasters_complete <- c(combined_rasters, fire_period_rast)\ncombined_rasters_complete\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \nsize        : 2053, 2054, 6  (nrow, ncol, nlyr)\nresolution  : 0.001217593, 0.001217593  (x, y)\nextent      : 148.4994, 151.0003, -37.5001, -35.00038  (xmin, xmax, ymin, ymax)\ncoord. ref. : +proj=longlat +datum=WGS84 +no_defs \nsource(s)   : memory\nvarnames    : file7ed462946383 \n              file7ed462946383 \n              file7ed462946383 \n              ...\nnames       : elevation, treecover, temp_bio1, precip_bio12, burnt, fire_period \nmin values  :      -728,   0.00000,  6.293441,     468.7325,    -1,          -1 \nmax values  :      1901,  94.93295, 18.281870,    1358.0767,     1,           1 \n```\n\n\n:::\n:::\n\n\nOk! We're finally ready to make our final prediction of greater gliders' distribution. We'll use `tidysdm::predict_raster()`, a very helpful function for spatial predictions, and maps our results!\n\n\n::: {.cell .fig-column-page layout-align=\"center\" lightbox='{\"group\":\"final-plot\",\"description\":\"Predicted distribution of greater gliders\"}'}\n\n```{.r .cell-code}\n# Predict\nprediction_present <- predict_raster(gliders_stacked, \n                                     combined_rasters_complete, \n                                     type = \"prob\",\n                                     wopt = list(steps=32))\n\n# Map\nggplot() +\n  geom_spatraster(data = prediction_present, \n                  aes(fill = .pred_presence)) +\n  scale_fill_viridis_c(option = \"E\", na.value = NA) +\n  guides(fill = guide_colorbar(\n    title = \"Relative\\nHabitat\\nSuitability\")\n    ) +\n  labs(title = \"Predicted distribution of greater gliders\",\n       subtitle = \"Southeast New South Wales\") +\n  pilot::theme_pilot(grid=\"hv\") +\n  theme(\n    legend.text = element_text(hjust = 0.5)\n    )\n```\n\n::: {.cell-output-display}\n![Predicted distribution of greater gliders](index_files/figure-html/unnamed-chunk-56-1.png){fig-align='center' width=864 style=margin-left:auto;margin-right:auto;}\n:::\n:::\n\n\nAs we used pseudo-absences rather than true absences, it's best to interpret the map as showing us the relative habitat suitability for greater gliders across the area (as opposed to a true distribution of where greater gliders occur). The highest habitat suitability for greater gliders appears to be along the middle forest area where most of our greater glider observations were located (which makes sense), along with a few larger areas in the upper and lower west, and near the upper coastline.\n\n# Impact of fire\n\nAs the second part of our investigation, we wanted to know whether the 2019/2020 bushfires had an impact on greater gliders. Our hypothesis was that there are *fewer* greater glider occurrences after the fire, and a driver of this effect is that *an area was burnt* during the 2019/2020 bushfires.\n\nTo see the more traditional statistical test results (e.g., estimates, test statistics, p-values), we *could* extract them from our Generalised Linear Model (GLM) which we ran over our tuning process. These types of summary statistics are easier to interpret, but they might not be the best option for us to use. \n\n:::{.callout-note collapse=\"true\"}\n##### Why can't we use GLM results?\nGeneralised Linear Models fit a straight line of best-fit to the data. As a result, it's possible to return a coefficient that estimates the slope of the line and some test statistics about each variable's importance in the model.\n\nOther models we've run like Maxent and Random Forest models are a little different, though. They use weights to \"penalize\" a model to get a better fitted line; one that isn't just straight, but shaped and curved to better fit the data. This shaped, squiggly line can be represented by a unique equation, not just a coefficient of slope. When asked to return results for models like these, tidymodels returns penalty values (*lambda*) used by the model, not a summary of statistics and *p* values. \n\nWe have to use other packages (like {vip} and {DALEX}) to assess more complex types of models like our complete `gliders_stacked` model.\n:::\n\nTo see what we mean, let's have a look at our GLM results. Before we see them, let's remind ourselves what we are expecting to see given our hypothesis:\n\n-   Fewer occurrences after the fire. This should appear as a significant, positive `fire_period` coefficient.\n-   Fewer occurrences in burnt areas. This should appear as a significant, positive `burnt` coefficient.\n-   An interaction between fire period and burnt area, because burnt areas after fire will have very few records[^multiply].\n\n[^multiply]: To the extent that the combination of an area being `burnt` and `post_fire` might multiply the effect when together.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# See the models that performed best\n# gliders_models_tune |>\n#   rank_results(\n#     rank_metric = \"boyce_cont\",\n#     select_best = TRUE\n#   )\n\n# extract best glm model\nbest_model <- gliders_models_tune |> \n  extract_workflow(id = \"default_glm\")\n\n# use best glm to fit complete `gliders_filtered` data\nfitted <- \n  best_model |> \n  fit(data = gliders_filtered)\n\n# see results\nfitted |>\n  broom::tidy()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 5\n  term                 estimate std.error statistic   p.value\n  <chr>                   <dbl>     <dbl>     <dbl>     <dbl>\n1 (Intercept)         20.5       1.35        15.1   8.97e- 52\n2 burnt                0.288     0.0403       7.15  8.83e- 13\n3 fire_period         -0.211     0.0359      -5.87  4.36e-  9\n4 elevation           -0.00576   0.000416   -13.9   1.15e- 43\n5 temp_bio1           -0.742     0.0725     -10.2   1.39e- 24\n6 precip_bio12         0.000201  0.000311     0.645 5.19e-  1\n7 treecover           -0.0825    0.00290    -28.5   3.32e-178\n8 burnt_x_fire_period -0.153     0.0356      -4.31  1.64e-  5\n```\n\n\n:::\n:::\n\n\n\nWhen running a model on this many data points, it's generally expected that most variables will be significant. It's easier to look at the size of the effect (i.e. `statistic`) and the estimate & standard error to figure out the direction and certainty of that estimate. The estimates are a little confusing here due to the model using `presence` as the reference level---higher numbers are a stronger prediction of *absence*.\n\nA quick first impression tells us that `fire_period` and `burnt` variables are significant but relatively weak predictors. You might also notice that some variables like `elevation` are very significant in the model but have tiny estimate coefficients. Let's use DALEX to help us understand how this is possible.\n\n### Use DALEX\n\nIf we want to understand more about our more complex stacked model, we can use the [DALEXtra package](https://modeloriented.github.io/DALEX/). DALEX[^8] is a model-agnostic tool for assessing complex models.\n\n[^8]: DALEX stands for mo**D**el **A**gnostic **L**anguage for **E**xploration and e**X**planation. It may be one of the strangest acronyms of all time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DALEXtra)\n```\n:::\n\n\nDALEX assumes the opposite reference level to tidymodels for our outcome variable `class`. So to make the results of DALEX make sense, we'll need to recode the predicted values of our model to flip the 1's and 0's. We can do this by returning the results of our best model (according to the metric `boyce_cont`), then we can use `extract_mold()` to see the components of the model, extract the outcome values, and recode the 1's and 0's.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get the results of the best fit model\nbest_fit <- fit_best(gliders_models_tune, metric = \"boyce_cont\")\n\n# flip `class` variable coding\nclass_revised <- best_fit |>\n  workflowsets::extract_mold() |> # components of fitted model results\n  purrr::pluck(\"outcomes\") |>     # pluck predicted 'class' from list\n  dplyr::pull() |>                # pull values from tibble\n  case_match(\"pseudoabs\" ~ 1, \"presence\" ~ 0) # recode\n\nclass_revised |> head(30L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1 0 1 1 1 1 1 1 1 0 1 0 0 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 1\n```\n\n\n:::\n:::\n\n\nThe rest is very straightforward (thank goodness). We can feed our stacked model, data and revised `class` variable into `explain_tidymodels()` to do exactly that!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest <- explain_tidymodels(gliders_stacked,\n                           data = gliders_train,\n                           y = class_revised)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nPreparation of a new explainer is initiated\n  -> model label       :  list  (  default  )\n  -> data              :  5895  rows  14  cols \n  -> data              :  tibble converted into a data.frame \n  -> target variable   :  5895  values \n  -> predict function  :  yhat.model_stack  will be used (  default  )\n  -> predicted values  :  No value for predict function target column. (  default  )\n  -> model_info        :  package stacks , ver. 1.1.1 , task classification (  default  ) \n  -> predicted values  :  numerical, min =  0.2558928 , mean =  0.7773144 , max =  0.9251635  \n  -> residual function :  difference between y and yhat (  default  )\n  -> residuals         :  numerical, min =  -0.9234804 , mean =  0.004873901 , max =  0.7261293  \n  A new explainer has been created!  \n```\n\n\n:::\n:::\n\n\nLet's see which parts of our model had the greatest importance for predicting the outcome. You'll notice these results look similar to the results of our GLM.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest |>\n  model_parts() |> \n  plot(show_boxplots = FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-61-1.png){width=672}\n:::\n:::\n\n\nWe can also see the partial effects of our model, which show how the model is fitting each individual variable effect. Here we can appreciate the model's complexity, as each variable has its own non-linear fitted line! DALEX can return many other helpful summaries to check model performance and results. [See more here](https://bookdown.org/gaetan_lovey/data_analytics/dalex.html).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_profile(test, \n              type = \"partial\", \n              variables = c(\"burnt\", \"fire_period\", \"treecover\", \"temp_bio1\", \"precip_bio12\", \"elevation\")\n              ) |>\n  plot()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-62-1.png){width=672}\n:::\n:::\n\n\n\nOverall, our results seem to show that fire does have an effect, but it's a relatively small effect on greater glider occurrences.\n\nWe can also more clearly see a few additional things:\n\n-   Tree cover and elevation are excellent predictors of greater gliders, which makes sense given they live in trees in alpine regions.\n-   The negative estimate of `fire_period` suggests that there are more records of greater gliders after the fires than before[^afterfires]. This is probably due to the growing number of records each year in the ALA (though the effect is relatively small).\n-   The slight positive estimate of `burnt` suggests fewer records in burnt areas[^burntareas]. However, the effect is pretty small.\n\n[^afterfires]: Based on how our variable is coded, a negative coefficient means that *before* fires, there is a higher likelihood of *absence*.\n\n[^burntareas]: Based on how our variable is coded, a positive coefficient means that in *burnt areas*, there is a higher likelihood of *absence*.\n\n\n# Final thoughts\n\nThe 2019-2020 bushfires had a huge impact on the Australian environment. However, it wasn't all negative; across taxonomic groups there was a wide range of [negative *and* positive effects](https://www.nature.com/articles/s41586-024-08174-6) from the fire. It might not all be \"doom-and-gloom\" after all, thanks to the resilience of many Australian species to fires.\n\nOur investigation finds that despite the [general negative impact of severe fire on forests](https://www.nature.com/articles/s41586-024-08174-6), greater gliders may have been less immediately affected in the aftermath of the 2019-2020 fires than other mammals and marsupials. In the short-term, [glider distributions after megafires seem generally stable](https://onlinelibrary.wiley.com/doi/full/10.1111/aec.13582). However, other areas in NSW were more [negatively impacted](https://www.publish.csiro.au/wr/WR23129), and they may deteriorate over longer periods. Ultimately, factors like the [density of hollowed den trees](https://www.publish.csiro.au/WR/WR06063) may determine how well greater gliders survive after fire, not only the burnt forest area.\n\nTo learn more on ALA Labs, check out these posts on [using tidymodels and tidysdm](https://labs.ala.org.au/posts/2024-04-30_sdm-tidymodels/) and [mapping multiple overlapping species distributions](https://labs.ala.org.au/posts/2024-01-25_hex_point_maps/).\n\n<details>\n\n<summary style=\"color: #E06E53;\">\n\nExpand for session info\n\n</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in system2(\"quarto\", \"-V\", stdout = TRUE, env = paste0(\"TMPDIR=\", :\nrunning command '\"quarto\"\nTMPDIR=C:/Users/KEL329/AppData/Local/Temp/RtmpiqjFgF/file7ed434e39f6 -V' had\nstatus 1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.5.2 (2025-10-31 ucrt)\n os       Windows 11 x64 (build 26100)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Australia.utf8\n ctype    English_Australia.utf8\n tz       Australia/Sydney\n date     2026-01-19\n pandoc   3.6.3 @ c:\\\\Users\\\\KEL329\\\\AppData\\\\Local\\\\Programs\\\\Positron\\\\resources\\\\app\\\\quarto\\\\bin\\\\tools/ (via rmarkdown)\n quarto   NA @ C:\\\\Users\\\\KEL329\\\\AppData\\\\Local\\\\Programs\\\\Quarto\\\\bin\\\\quarto.exe\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package       * version date (UTC) lib source\n broom         * 1.0.10  2025-09-13 [1] CRAN (R 4.5.2)\n DALEX         * 2.5.3   2025-10-16 [1] CRAN (R 4.5.2)\n DALEXtra      * 2.3.0   2023-05-26 [1] CRAN (R 4.5.2)\n dials         * 1.4.2   2025-09-04 [1] CRAN (R 4.5.2)\n dplyr         * 1.1.4   2023-11-17 [1] CRAN (R 4.5.2)\n elevatr       * 0.99.1  2025-09-10 [1] CRAN (R 4.5.2)\n forcats       * 1.0.1   2025-09-25 [1] CRAN (R 4.5.2)\n future        * 1.68.0  2025-11-17 [1] CRAN (R 4.5.2)\n galah         * 2.1.2   2025-06-12 [1] CRAN (R 4.5.2)\n geodata       * 0.6-6   2025-09-30 [1] CRAN (R 4.5.2)\n ggplot2       * 4.0.1   2025-11-14 [1] CRAN (R 4.5.2)\n here          * 1.0.2   2025-09-15 [1] CRAN (R 4.5.2)\n infer         * 1.1.0   2025-12-18 [1] CRAN (R 4.5.2)\n lubridate     * 1.9.4   2024-12-08 [1] CRAN (R 4.5.2)\n modeldata     * 1.5.1   2025-08-22 [1] CRAN (R 4.5.2)\n ozmaps        * 0.4.5   2021-08-03 [1] CRAN (R 4.5.2)\n parsnip       * 1.4.1   2026-01-11 [1] CRAN (R 4.5.2)\n purrr         * 1.2.0   2025-11-04 [1] CRAN (R 4.5.2)\n ranger        * 0.17.0  2024-11-08 [1] CRAN (R 4.5.2)\n readr         * 2.1.6   2025-11-14 [1] CRAN (R 4.5.2)\n recipes       * 1.3.1   2025-05-21 [1] CRAN (R 4.5.2)\n rsample       * 1.3.1   2025-07-29 [1] CRAN (R 4.5.2)\n scales        * 1.4.0   2025-04-24 [1] CRAN (R 4.5.2)\n sessioninfo   * 1.2.3   2025-02-05 [1] CRAN (R 4.5.2)\n sf            * 1.0-23  2025-11-28 [1] CRAN (R 4.5.2)\n spatialsample * 0.6.1   2025-12-02 [1] CRAN (R 4.5.2)\n stacks        * 1.1.1   2025-05-27 [1] CRAN (R 4.5.2)\n stringr       * 1.6.0   2025-11-04 [1] CRAN (R 4.5.2)\n tailor        * 0.1.0   2025-08-25 [1] CRAN (R 4.5.2)\n terra         * 1.8-86  2025-11-28 [1] CRAN (R 4.5.2)\n tibble        * 3.3.0   2025-06-08 [1] CRAN (R 4.5.2)\n tidymodels    * 1.4.1   2025-09-08 [1] CRAN (R 4.5.2)\n tidyr         * 1.3.1   2024-01-24 [1] CRAN (R 4.5.2)\n tidysdm       * 1.0.4   2025-12-13 [1] CRAN (R 4.5.2)\n tidyterra     * 0.7.2   2025-04-14 [1] CRAN (R 4.5.2)\n tidyverse     * 2.0.0   2023-02-22 [1] CRAN (R 4.5.2)\n tune          * 2.0.1   2025-10-17 [1] CRAN (R 4.5.2)\n workflows     * 1.3.0   2025-08-27 [1] CRAN (R 4.5.2)\n workflowsets  * 1.1.1   2025-05-27 [1] CRAN (R 4.5.2)\n yardstick     * 1.3.2   2025-01-22 [1] CRAN (R 4.5.2)\n\n [1] C:/Users/KEL329/AppData/Local/Programs/R/R-4.5.2/library\n * ── Packages attached to the search path.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}