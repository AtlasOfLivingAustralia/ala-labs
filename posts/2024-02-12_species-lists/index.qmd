---
title: "Download a species list and cross-reference with conservation status lists in Python"
description: |
  Knowing what species have been observed in a local area is a regular task for ecosystem management. Here we show how to make a species list with {galah-python} and how to cross-reference this list with threatened and sensitive species lists. We then show how to visualise this information as a waffle chart using {pywaffle} & {matplotlib}.
author:
  - name: "Dax Kellie"
  - name: "Amanda Buyan"
date: "2024-02-12"
date-modified: "2026-02-26"
title-block-banner: "#B8573E"
toc: true
toc-location: left
toc-depth: 2
filters:
   - lightbox
lightbox: auto
categories:
  - Eukaryota
  - Animalia
  - Plantae
  - Summaries
  - Python
image: barplot_threatened.png
freeze: true
draft: true
editor_options: 
  chunk_output_type: console
---

```{r}
#| include: false
library(htmltools)
```

<!-- remove metadata section -->

```{=html}
<style>
  #title-block-header.quarto-title-block.default .quarto-title-meta {
      display: none;
  }
</style>
```

<!-- Author card -->

:::::: author-card
::: author-card-text
#### Author

[Dax Kellie](https://labs.ala.org.au/about/Kellie_Dax/)\
[Amanda Buyan](https://labs.ala.org.au/about/Buyan_Amanda/)

#### Date

20 July 2025
:::

::: author-card-image
```{r, out.width='120px', out.extra='style="clip-path: circle();"', echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/dax.jpg")
```
:::

::: author-card-image
```{r, out.width='120px', out.extra='style="clip-path: circle();"', echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/amanda.jpg")
```
:::
::::::

<!------------------------ Post starts here ------------------------>

Knowing what species inhabit an area is important for conservation and ecosystem management. In particular, it can help us find how many known species are in a given area, and whether any species are vulnerable or endangered.

In this post, we will present two options, one using the [galah-python](https://galah.ala.org.au/Python/) package, the other using an external shapefile and list. Using either workflow, we will show you how to download a list of species within a Local Government Area (Shoalhaven, NSW), cross-reference this list with a state conservation status list, and visualise the number of threatened species in the region with [pywaffle](https://pywaffle.readthedocs.io/en/latest/) and [plotnine](https://plotnine.org/).

```{r}
#| include: false
# If you are not using positron, this chunk needs to be `eval: true`
library(reticulate)
py_require(c("pandas"))
py_require(c("geopandas"))
py_require(c("galah-python"))
py_require(c("numpy"))
py_require(c("natsort"))
py_require(c("shapely"))
py_require(c("pywaffle"))
py_require(c("pyjanitor"))
py_require(c("plotnine"))
py_require(c("session_info"))
py_require(c("openpyxl"))
py_require(c("itables"))
py_require(c("ipython"))
```

::: aside
For those unfamiliar with Australian geography, Shoalhaven is located here:

```{python}
#| echo: false
#| warning: false
#| message: false
import pandas as pd
import geopandas as gpd
from plotnine import *
import shapely

# set pandas options here
pd.set_option('display.max_columns', None)
pd.set_option('expand_frame_repr', False)

# read in shapefile
lgas = gpd.read_file('../data/LGA_2023/LGA_2023_AUST_GDA2020.zip')

# change CRS to WGS84
lgas_wgs84 = lgas.to_crs(4326)

# remove empty shapes and areas outside contiguous Australia
lgas_wgs84 = lgas_wgs84.dropna(subset=['geometry'])
uninc_nsw = lgas_wgs84[lgas_wgs84['LGA_NAME23'] == 'Unincorporated NSW']
exclude_box = shapely.box(110,-45,155,0)
lgas_wgs84[lgas_wgs84['LGA_NAME23'] == 'Unincorporated NSW'] = uninc_nsw.clip(exclude_box)
lgas_wgs84 = lgas_wgs84[lgas_wgs84['geometry'].within(exclude_box)]

# get shoalhaven
shoalhaven = lgas_wgs84[lgas_wgs84['LGA_NAME23'] == 'Shoalhaven']

# create plot object
p = (
    ggplot()
    + geom_map(mapping = lgas_wgs84, fill = 'white', colour = '#A6A6A6')
    + geom_map(mapping = shoalhaven, fill = '#E06E53', colour = '#E06E53')
    + annotate(
        "segment",
        x=154,
        y=-40,
        xend=151.,
        yend=-35.2,
        color="black",
        arrow=arrow(angle=30,length=0.1,ends='last',type="closed"),
    )
    + annotate(
        "text",
        x=150, # 153
        y=-41,
        label="Shoalhaven",
        size=20 # 10
    )
    + theme_void()
)

# show plot
p.show()
```
:::

Let's first load our packages. To download species lists, you will also need to enter a registered email with the ALA using `galah_config()`.

```{python}
#| eval: false
import galah

galah.galah_config(email = "your-email-here") # ALA-registered email
```

```{python}
#| echo: false
#| warning: false
#| message: false
#| eval: true
import galah

galah.galah_config(email = "amanda.buyan@csiro.au")
```

# Download threatened species in an area

Choose which method you would like to view:

-   `{galah-python}` (using `fields` downloaded from the Atlas of Living Australia)
-   Downloaded shapefile + species list

The method you choose depends on whether the region or list you wish to return species for is already in `{galah-python}`, or whether you wish to filter for a more specific area defined by a separate shapefile or list. Keep in mind that using an external list may require additional work matching taxonomic names.

::::: {.panel-tabset .nav-pills}
# galah-python

### Search for fields

To find what exists in galah to help us narrow our query, we can use `search_all()` to search for available fields. A **field** in `{galah-python}` refers to a column or layer stored in a living atlas. Let's do a text search to find what fields contain information on "Local Government Areas".

```{python}
galah.search_all(fields = "Local Government Areas")
```

The field `cl11170`[^1] contains the most recent available data (from 2023). We can preview what values are *within* field `cl11170` using `show_values()`.

```{python}
galah.show_values(field = 'cl11170')
```

There are lots of Local Government Areas! To check whether Shoalhaven is included, we can do a text search for values that match `'shoalhaven'`.

```{python}
galah.search_values(field = 'cl11170', value = 'shoalhaven')
```

### Download data

Using the `field` and `value` returned above, we can now build our query. We begin our query with `galah_call()` and filter to only Shoalhaven in the year 2024. Ending our query with `atlas_species()` will return a list of species. 

```{python}
species_shoal = galah.atlas_species(filters = ['cl11170=Shoalhaven','year=2024'])

species_shoal
```

`atlas_species()` returns taxonomic information at the species level (for more info, see the tab below). To make sure we return taxonomic information at the lowest level each occurrence was identified, we'll `group_by(taxonConceptID)`, which is a unique ID attached to each occurrence record's taxonomic identification (read the box below for more on what this means).

:::{.callout-important collapse="true"}
##### atlas_species() returns species-level information

By default `atlas_species()` only returns taxonomic information at the species level. This means that if some species are identified to subspecies on a specific list like the NSW Conservation Status list, `atlas_species()` will return the species-level match, rather than the subspecies-level match. For example, the name `"Potorous tridactylus"` is returned instead of `"Potorous tridactylus tridactylus"`.

Grouping by `taxonConceptID` like we do below specifies that we wish to match to the identified taxon, rather than only to the species level.

:::

```{python}
species_shoal = galah.atlas_species(filters = ['cl11170=Shoalhaven','year=2024'], group_by = 'taxonConceptID')

species_shoal
```

:::{.callout-tip collapse="true"}
##### Download record counts

It's also possible to return number of observations by ending our query with `atlas_counts()`. In this case, we can group by `scientificName` (the name of the lowest level the observation was identified).

```{python}
galah.atlas_counts(filters = ['cl11170=Shoalhaven','year=2024'],group_by = 'scientificName')
```

:::

### Cross-reference with threatened species lists

Next we'll compare our Shoalhaven species list `species_shoal` with a state-wide conservation status list. We can use `{galah-python}` to access lists that are available on the Atlas of Living Australia. Shoalhaven is within the state of New South Wales, so let's search for "New South Wales" to see what state-specific lists are available.

```{python}
galah.search_all(lists = 'New South Wales')
```

Two lists are returned, and both appear relevant. With the help of some additional columns returned by `search_all()`—`listType`, `isAuthoritative` and `isThreatened`—we can learn more about which list suits our needs best. Although both lists are authoritative, only one list (`dr650`) contains threatened species whereas the other (`dr487`) contains sensitive species.

```{python}
galah.search_all(lists = 'New South Wales')[['species_list_uid', 'listType', 'isAuthoritative', 'isThreatened']]
```

By specifying the ID `dr650` and using `show_values()`, we can view the complete New South Wales threatened species list.

```{python}
galah.show_values(field = 'dr650',lists = True)
```

As of {galah version} 0.12.2, we can also use `show_values()` to add conservation status columns to our species list. By adding the argument `all_fields = True`, we can add any columns stored in the ALA from the original list. For conservation lists, this includes columns like `status`, `sourceStatus` and `IUCN_Status`.

```{python}
#| message: false
#| warning: false
# get values
nsw_threatened = galah.show_values(field = 'dr650', lists = True, all_fields = True)

# rearrange columns so statuses are in front
nsw_threatened = nsw_threatened[['status','sourceStatus','IUCN_equivalent_status'] + [col for col in nsw_threatened.columns if col not in ['status','sourceStatus', 'IUCN_equivalent_status']]]
```

Adding status info can be handy if we want to join this with other information like record counts.

```{python}
# get record counts for each species on the NSW Conservation Status list
threatened_counts = galah.atlas_counts(
                      filters = ['species_list_uid=dr650','cl11170=Shoalhaven','year=2024'], 
                      group_by = 'scientificName'
                    )

threatened_counts
```
```{python}
# join counts to status information
threatened_counts_joined = pd.merge(threatened_counts,nsw_threatened,on='scientificName')
threatened_counts_joined = threatened_counts_joined[['scientificName', 'count', 'status', 'commonName'] + [col for col in threatened_counts_joined.columns if col not in ['scientificName', 'count', 'status', 'commonName']]]

threatened_counts_joined
```


To return which species on the New South Wales Conservation Status List (`dr650`) were recorded in Shoalhaven in 2024, we can add `species_list_uid == dr650` as a filter to a query ending with `atlas_species()`. To make sure we return taxonomic information at the lowest level each occurrence was identified, we'll `group_by(taxonConceptID)`.

```{python}
threatened = galah.atlas_species(
                filters = ['cl11170=Shoalhaven','year=2024','species_list_uid=dr650'], 
                group_by = 'taxonConceptID'
              )

threatened
```



Note that status information is not included in the query above, but can be joined in the same way we added this status information to `threatened_counts`[^right-join].

[^right-join]: We used `right_join()` this time because we wanted to first select columns from `nsw_threatened`, then join so that we keep all 90+ rows in `threatened` (using `left_join()` would keep all 1,000+ rows in `nsw_threatened` instead).

```{python}
# select status columns, join status information
threatened = threatened.rename(columns={'Species Name': 'scientificName'})
threatened_status = pd.merge(nsw_threatened,threatened,on='scientificName')
threatened_status = threatened_status[['scientificName', 'status', 'sourceStatus'] + [col for col in threatened_status.columns if col not in ['scientificName', 'status', 'sourceStatus']]]

threatened_status
```



# Shapefile + list

### Download shapefile

To retrieve the spatial outline of Shoalhaven, let's download the latest Local Government Areas data from the [Australian Bureau of Statistics Digital Boundary files page](https://www.abs.gov.au/statistics/standards/australian-statistical-geography-standard-asgs-edition-3/jul2021-jun2026/access-and-downloads/digital-boundary-files). Find "Local Government Areas - 2025 - Shapefile" and click "Download ZIP". Save the zip folder in your current directory and unzip it.

Let's read the file into Python. 

```{python}
#| eval: false
lgas = gpd.read_file('LGA_2025_AUST_GDA2020.zip')
lgas
```

```{python}
#| warning: false
#| message: false
#| echo: false
#| class-output: hscroll
lgas = gpd.read_file('../data/LGA_2023/LGA_2023_AUST_GDA2020.zip')

lgas
```

Now let's transform our shapefile to use the Coordinate Reference System (CRS) [EPSG](https://en.wikipedia.org/wiki/EPSG_Geodetic_Parameter_Dataset):4326 (the standard used in cartography and GPS, also known as [WGS84](https://en.wikipedia.org/wiki/World_Geodetic_System)) so that it matches the projection of our data from the ALA [^3].

```{python}
lgas_wgs84 = lgas.to_crs(4326)
```

Next we'll filter our shapefile to Shoalhaven. The column `LGA_NAME23` contains area names, and we can filter our data frame to only rows where `LGA_NAME25` is equal to `Shoalhaven`. We are left with a single polygon shape of Shoalhaven.

We will also simplify the shapefile[^2] using `shapely.simplify()` from the [shapely package](https://shapely.readthedocs.io/en/2.0.6/index.html) because complex shapefiles can sometimes cause problems with sending queries to the ALA.

```{python}
shoalhaven = lgas_wgs84[lgas_wgs84['LGA_NAME23'] == 'Shoalhaven']
shoalhaven_simplify = shapely.simplify(shoalhaven['geometry'][shoalhaven.index[0]],tolerance=4)
```

### Download data

Now that `shoalhaven` contains our LGA shape, we can build our query. Once again, we'll begin with `galah_call()` and filter to only records from 2024. We can specify that we want records within `shoalhaven` using `geolocate()`. To make sure we return taxonomic information at the level occurrences were identified to, we'll `group_by(taxonConceptID)`, which is a unique ID attached to each occurrence record's taxonomic identification (read the box below for more on what this means). Finally, we can return a species list by ending our query with `atlas_species()`. 

:::{.callout-important collapse="true"}
##### atlas_species() returns species-level information

By default `atlas_species()` only returns taxonomic information at the species level. This means that if some species are identified to subspecies on a specific list like the NSW Conservation Status list, `atlas_species()` will return the species-level match, rather than the subspecies-level match. For example, the name `"Potorous tridactylus"` is returned instead of `"Potorous tridactylus tridactylus"`.

Grouping by `taxonConceptID` like we do below specifies that we wish to match to the identified taxon, rather than only to the species level.

:::

```{python}
# shoalhaven index
species_shoal = galah.atlas_species(
                  filters = ['year=2024'], 
                  polygon = shoalhaven_simplify,
                  group_by = 'taxonConceptID'
                )

species_shoal
```

:::{.callout-tip collapse="true"}

##### Download record counts
It's also possible to return the observations counts by ending our query with `atlas_counts()`. In this case, we can group by `scientificName` (the name of the lowest level the observation was identified).

```{python}
galah.atlas_counts(
  filters = ['year=2024'], 
  polygon = shoalhaven_simplify,
  group_by = 'scientificName'
)
```

:::

### Use external list

We can use our own conservation status lists from an external source to compare to our Shoalhaven species list. As an example, we are using the the New South Wales Conservation Status List downloaded from the [NSW Bionet Atlas website](https://atlas.bionet.nsw.gov.au/UI_Modules/ATLAS_/AtlasSearch.aspx)[^4].

::: {.callout-note collapse="true"}
##### What options did we choose to download our list?

We downloaded this list on 2025/07/08. To download a complete NSW threatened species list, we selected the following options:

-   Which species or group? *All entities*
-   Legal status? *Select records that fall under one or more categories* ➝ *Threatened NSW*
-   What area? *Entire area*
-   Period of records? *All records*
-   Status? *Valid records only*
:::

{{< downloadthis ../data/nsw_threatened.xlsx label="Download Conservation Status List" icon=database-fill-down type=info class=data-button >}}

Save the downloaded `.xls` file in your working directory. We'll read in our `.xls` file, which we have renamed to `nsw_threatened.xls`.

```{python}
#| eval: false
nsw_threatened_list = pd.read_excel('path/to/nsw_threatened.xlsx', skiprows = 3) # skip first 3 rows
```

```{python}
#| echo: false
#| warning: false
#| message: false
nsw_threatened_list = pd.read_excel('../data/nsw_threatened.xlsx', skiprows = 3) # skip first 3 rows
```

::: {.callout-warning collapse="true"}
##### libxls error

It's possible you might receive the following error.

```         
Error:
  filepath: [path-to-file]
  libxls error: Unable to open file
```

This relates to a formatting issue preventing `read_excel()` from reading the file correctly, which seems related to the way BioNet saves its files. To fix this issue, open the list file on your computer, then re-save the file as a `.xlsx` document (File ➝ Save As ➝ select file format`.xlsx` ➝ Save). Then you can use `read_excel()` to read the new file in.

```{python}
#| eval: false
nsw_threatened_list = pd.read_excel('path/to/nsw_threatened.xlsx', skiprows = 3) # skip first three rows
```
:::

### Cross-reference with threatened species lists

First we'll clean the column names to make them easier to use in Python using the amazing function `clean_names()` in the `janitor` package. We also need to remove the `^` that precedes some names on the list.

```{python}
from janitor import clean_names

nsw_threatened_list = clean_names(nsw_threatened_list)

nsw_threatened_list
```


Now we can filter our Shoalhaven list to only those that match names in `nsw_threatened_list`.

```{python}
species_shoal = clean_names(species_shoal)
threatened_filter = species_shoal[species_shoal['species_name'].isin(nsw_threatened_list['scientific_name'].unique())].reset_index(drop=True)

threatened_filter
```

To preserve status information, instead we can join `species_shoal` and `nsw_threatened_list` dataframes, which will retain columns while still filtering results.

```{python}
threatened_joined = pd.merge(species_shoal, nsw_threatened_list,
                             left_on = 'species_name', right_on = 'scientific_name'
                             ).dropna(subset = ['nsw_status'])

threatened_joined
```

::: {.callout-tip collapse="true"}

##### Species with more than one status

Species lists from BioNet Atlas can sometimes return both species and specific populations of the same species with their own conservation status, respectively. When matching species names, this means there can be multiple matches for the same species. For example, there are seperate conservation statuses assigned to the Yellow bellied glider and a Yellow bellied glider population in the Bago Plateau. 

```{python}
#| code-fold: true
threatened_joined[
  threatened_joined['species_name'] == 'Petaurus australis'
][['species_name', 'common_name', 'nsw_status']]
```

These multiple statuses explain why there are several more rows when we join dataframes (`threatened_joined`) compared to when we filter by species names (`threatened_filter`).

:::

::: {.callout-warning collapse="true"}
##### Names matching 

You might notice that fewer species are returned when using an externally downloaded list than using galah. This discrepancy is due to differences in scientific names between those on the BioNet Atlas and those on the ALA. Names mismatches are a risk when using external species lists. Additional work is usually needed to avoid unexpected mismatches. The _Cleaning Biodiversity Data in R_ book details [some methods for finding name synonyms](https://cleaning-data-r.ala.org.au/3_ecological-cleaning/taxonomic-validation.html#checking-for-synonyms), but amending taxonomic names can be difficult. 

When ALA ingests data, it matches those data to the ALA's taxonomic backbone, with the goal of minimising name mismatches. We recommend using galah because it makes names matching easier. However, not all lists exist on the ALA, so some tasks inevitably require matching to externally downloaded lists.

:::

To use this list for summarising or plotting, it might be useful to add to `threatened_joined` status information for each species as vulnerable, endangered, critically endangered or extinct. To add this info, we'll extract the first value of `nsw_status` by removing everything after the first comma and save that value in `nsw_status_extracted`. Then we'll recode these values[^statuscode] and save them in `nsw_status_simple`. 

[^statuscode]: We can double check status information by viewing the species list in Excel and clicking on links in the `info` column. This is handy for double checking species status codes or learning more about each species and status.

```{python}
# clean statuses
statuses = {'V': 'Vulnerable', 'E1': 'Endangered','E2': 'Endangered',
            'E3': 'Endangered','E4A': 'Critically Endangered',
            'E4': 'Extinct'}
threatened_clean = threatened_joined.copy()
threatened_clean['nsw_status_extracted'] = threatened_clean['nsw_status'].copy().replace({',P': ''},regex=True)
threatened_clean['nsw_status_simple'] = threatened_clean['nsw_status_extracted'].copy().replace(statuses)

# reposition columns
threatened_clean = threatened_clean[['nsw_status', 'nsw_status_extracted', 'nsw_status_simple', 'species_name'] + [col for col in threatened_clean.columns if col not in ['nsw_status', 'nsw_status_extracted', 'nsw_status_simple', 'species_name']]]

threatened_clean
```


:::::

[^1]: Each spatial layer has a two letter code, along with a number to identify it. The abbreviations are as follows:\
  \* `cl` = contextual layer (i.e. boundaries of LGAs, Indigenous Protected Areas, States/Territories etc.)\
  \* `11170` = number associated with the spatial layer in the atlas

[^2]: Simplifying a shapefile removes the number of total points that draw the shape outline.

[^3]: Check out [this post](https://labs.ala.org.au/posts/2023-12-18_beginners-guide-make-a-map/#make-a-map-1) for a better explanation of what CRS is and how it affects maps.

[^4]: On a related note, it's possible to download a list specifically for Shoalhaven on the BioNet Atlas website. However, results from BioNet will be matched BioNet records only. As a result, fewer species will be identifed compared to the ALA, which matches NSW BioNet data *as well as* data from other sources.

Whichever method you've followed, you will end up with very similar datasets containing threatened species and their statuses, though the number of matched species might differ[^different].

[^different]: This is due to differences in taxonomic names in the externally downloaded list and in ALA data. More info can be found under the "Names Matching" tab in the **Shapefile + list** section.

::::: {.panel-tabset .nav-pills}

##### galah

```{python}
import itables
from IPython.display import HTML, display
html = itables.to_html_datatable(threatened_status)
HTML(html)
```

##### Shapefile + list

```{python}
import itables
from IPython.display import HTML, display
html = itables.to_html_datatable(threatened_clean)
HTML(html)
```

:::::

To finish, we can save our dataframe as a csv file.

```{python}
#| eval: false
# save
pd.to_csv(threatened_status,
          'path/to/file-name.csv')
```


# Visualise species conservation status

Along with a species list, we can also summarise `threatened_status` visually. Few options are as simple and easy-to-understand than a bar plot. Here we've made a simple bar plot displaying the number of species by conservation status, and styled it with a custom font and some nicer colours.

For nicer formatting, we can use the [Roboto](https://fonts.google.com/specimen/Roboto) font from Google Fonts by downloading the font from Google Fonts, saving the folder in your current directory, unzipping the folder, and loading it with the matplotlib library.

```{python}
#| warning: false
#| message: false
#| code-fold: true
#| column: page
#| fig-align: center
#| fig-height: 5
#| fig-width: 6.5
#| out-extra: "style=margin-left:auto;margin-right:auto;"
# import packages for font management
import matplotlib.font_manager as fm
import os

# add Roboto custom font
project_dir = os.getcwd()
font_path = os.path.join(project_dir, "Roboto-VariableFont_wdth,wght.ttf")
prop = fm.FontProperties(fname=font_path)

# bar plot
bar_status = (
  ggplot(threatened_status) # 
  + geom_bar(aes(x='status',fill='status')) # added colour
  + labs(title = "Threatened species status in Shoalhaven, NSW (2024)",
         x = "Conservation status",
         y = "Number of species") 
  + scale_fill_manual(values = ['#ab423f', '#cd826d', '#ebc09e'],
                      labels = ["Vulnerable", "Endangered", "Critically Endangered"]) 
  + theme(
        plot_title = element_text(fontproperties=prop, size = 140),
        axis_title_x = element_text(fontproperties=prop, size = 10, vjust = -0.1),
        axis_title_y = element_text(angle = 90, fontproperties=prop, size = 10, hjust = -.1),
        axis_text_x = element_text(fontproperties=prop, size = 8, vjust = -.1),
        axis_text_y = element_text(fontproperties=prop, size = 8),
  )
)

bar_status.show()
```


A useful but more exciting way to see a taxonomic breakdown of species is using a waffle chart. Waffle charts are great because they display number and proportion all at once. For more advanced Python users, waffle charts can be a useful summary tool.  Unfortunately, waffle charts aren't available yet in `{plotnine}`, so we will be using `{matplotlib}`.

```{python}
#| code-fold: true
#| warning: false
#| message: false
#| column: page
#| fig-align: center
#| fig-width: 10
#| out-extra: "style=margin-left:auto;margin-right:auto;"
import matplotlib.pyplot as plt
from pywaffle import Waffle 
import matplotlib as mpl
from matplotlib import font_manager
from matplotlib import rcParams

# condense all taxa in one column 
threatened_status['taxa_for_waffle'] = threatened_status.apply(
              lambda row: 
                row['Kingdom'] if (row['Kingdom'] == 'Plantae') 
                               else (row['Class'] if row['Class'] in ['Aves','Reptilia','Mammalia'] else 'Other'),
              axis=1
    ).replace({'Aves': 'Birds', 'Reptilia': 'Reptiles', 'Mammalia': 'Mammals','Plantae': 'Plants'})

# import Roboto font into matplotlib
font_files = font_manager.findSystemFonts(fontpaths="Roboto/")
for ff in font_files:
  font_manager.fontManager.addfont(ff)
rcParams['font.family'] = 'Roboto'

# set up the plot
fig,ax = plt.subplots(figsize=(10,6))
status_counts = list(threatened_status['taxa_for_waffle'].value_counts())

# make waffle chart
Waffle.make_waffle(
    ax=ax,
    rows=8,
    values=status_counts, 
    colors = ['#567c7c', '#687354', '#C3CB80', '#c4ac79', '#38493a'],
    interval_ratio_x = 0.1,
    interval_ratio_y = 0.1,
    legend={
        'labels': ['Birds', 'Mammals', 'Plants', 'Reptiles', 'Other'],
        'loc': 'lower center',
        'bbox_to_anchor': (0.5,-.1),
        'ncol': 5,
        'framealpha': 0,
        'fontsize': 14
    }
)

# make plot prettier
plt.suptitle('Taxonomic breakdown of threatened species in Shoalhaven, NSW (2024)',fontsize=20,font='Roboto')
fig.text(0.75,0.02,"*1 square = 1 species",fontsize=16)

plt.show()
```


# Final thoughts

We hope this post has helped you understand how to download a species list for a specific area and compare it to conservation lists. It's also possible to compare species with other information like lists of migratory species or seasonal species.

For other posts, check out [our beginner's guide to map species observations](https://labs.ala.org.au/posts/2023-12-18_beginners-guide-make-a-map/) or see [an investigation of dingo observations in the ALA](https://labs.ala.org.au/posts/2023-05-16_dingoes/).

<details>

<summary style="color: #E06E53;">

Expand for session info

</summary>

```{python}
#| echo: false
import math
import natsort
import pandas
import session_info

session_info.show()
```

</details>