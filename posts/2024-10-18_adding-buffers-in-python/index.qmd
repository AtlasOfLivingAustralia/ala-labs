---
title: "Add buffers to a shapefile"
description: |
  Knowing what species have been observed in a local area is a regular task for ecosystem management. Here we show how to add a buffer to a shapefile using {shapely} and {geopandas}. Then we use {galah-python} and {matplotlib} to demonstrate how data points that have been obfustcated (obscured by reducing their precision) may affect the size of a buffer in order to representatively capture species in the area.
  - name: "Amanda Buyan"
  - name: "Dax Kellie"
date: "2025-05-30"
title-block-banner: "#B8573E"
toc: true
toc-location: left
toc-depth: 2
categories:
  - Eukaryota
  - Animalia
  - Amphibia
  - Summaries
  - Python
# image: waffle-chart.png
freeze: true
engine: knitr
jupyter: python3
draft: true
editor_options: 
  chunk_output_type: console
---

```{r}
#| include: false
library(htmltools)
```

<!-- remove metadata section -->
<style>
  #title-block-header.quarto-title-block.default .quarto-title-meta {
      display: none;
  }
</style>



<!-- Author card -->

:::{.author-card}
:::{.author-card-text}

#### Author
[Amanda Buyan](https://labs.ala.org.au/people/Buyan_Amanda/index.html)  
[Dax Kellie](https://labs.ala.org.au/people/Kellie_Dax/index.html)  

#### Date
12 February 2024

:::

:::{.author-card-image}
```{r, out.width='120px', out.extra='style="clip-path: circle();"', echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/amanda.jpg")
```
:::

:::{.author-card-image}
```{r, out.width='120px', out.extra='style="clip-path: circle();"', echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/dax.jpg")
```
:::

:::

<!------------------------ Post starts here ------------------------>

<!-- 
General comment: Sorry to say it, but please switch to the Australian spelling of 'metres' throughout haha
-->

Ecological data is often used to understand what species are found in a given location. This information is a frequent requirement for conservation monitoring, and for environmental impact assessment prior to land development. A common method for this task is to use a **buffer**, an outward boundary around a given area location. Adding a buffer helps to capture all the species in an area, including those that have been observed just outside the area but might live in, or be affected by that area.

Choosing a buffer size, however, can be tougher than it seems. Individual organisms move, either over the course of a day or an entire season (e.g., migration, perennial growth), so species' lifecycles and behaviours may determine the size of our final buffer. A more difficult challenge occurs when species are considered sensitive or endangered. These species' exact point locations are often obfuscated (aka their location is made less precise) to keep these species safe. This added inprecision will again affect our final decision on buffer size.

In this post, we'll show how to add a buffer around a shapefile with [{geopandas}](https://geopandas.org/en/stable/), [{shapely}](https://shapely.readthedocs.io/en/stable/) and [{matplotlib}](https://matplotlib.org/). Then we will use [{galah-python}](galah.ala.org.au/Python) to download data of Stuttering frogs (*Mixophyes balbus*) to demonstrate how the size of a buffer can affect the detection of sensitive species in an area.

# Draw a buffer

For our example, our area of interest is Mid-Western, a Local Government Area (LGA) in New South Wales. We'll first need to get a shapefile of our area, which we can get by downloading a [shapefile of all LGAs from the Australian Bureau of Statistics](https://www.abs.gov.au/statistics/standards/australian-statistical-geography-standard-asgs-edition-3/jul2021-jun2026/access-and-downloads/digital-boundary-files). Download the zip file of "Local Government Areas - 2024", then place the zip file in your local directory. We can then read in the shapefile and show what it looks like using {geopandas}.

::: aside

For those unfamiliar with Australian geography, the ACT is located here:

```{python}
#| echo: false
#| eval: true
import geopandas as gpd
import matplotlib
import matplotlib.pyplot as plt
lgas = gpd.read_file("../data/LGA_2024_AUST_GDA2020.zip")
ax = lgas[lgas['STE_NAME21'] == 'New South Wales'].plot(edgecolor = "#5A5A5A", linewidth = 0.5, facecolor = "white")
a = lgas[lgas['LGA_NAME24'] == 'Mid-Western'].plot(ax=ax,facecolor='#00008b')
a = ax.axis('off')
plt.show()
```

:::


```{python}
#| echo: true
#| eval: false
import geopandas as gpd
lgas = gpd.read_file("LGA_2024_AUST_GDA2020.zip")
lgas.head()
```

```{python}
#| echo: false
#| eval: true
import geopandas as gpd
import pandas as pd
pd.set_option('display.max_columns', None)
pd.set_option('expand_frame_repr', False)
lgas = gpd.read_file("../data/LGA_2024_AUST_GDA2020.zip")
lgas.head()
```

Next let's filter our `lgas` object to only Mid-Western and plot its shape using {matplotlib}. Conveniently, this functionality is built into both {pandas} and {geopandas} for straightforward plotting of `GeoDataFrame` data.

```{python}
midwestern = lgas[lgas['LGA_NAME24'] == 'Mid-Western']
midwestern.plot(edgecolor = "#5A5A5A", linewidth = 0.5, facecolor = "white")
```

## Create a buffer 

Now, we will create a 5km buffer.  This will involve converting the shapefiles between different Coordinate Reference Systems (CRS)[^crs].

[^crs]: Check out [this section of a previous ALA Labs post](https://labs.ala.org.au/posts/2023-12-18_beginners-guide-make-a-map/#make-a-map) for a more complete explanation of what a CRS is.

We want to draw our buffers in meters, as we are looking at a relatively small area. To do this, we will complete the following steps for a range of buffers:

- Project our polygon `midwestern` using a CRS measured in metres, like Australian Albers (`EPSG:3577`)
- Create a buffer in metres around `midwestern`
- Reproject our polygon `midwestern` and buffer to the CRS of the data we intend to use, `EPSG:4326`[^ala-crs]
- Unify the buffers that overlap into one (as long as the shapes intersect)

[^ala-crs]: ALA data is projected using [CRS EPSG:4326](https://epsg.io/4326) (the same one used by Google Earth).

```{python}
# packages and variables
import shapely
from shapely.geometry import Polygon

# reproject to Australian Albers CRS
midwestern_meters = midwestern.to_crs(3577)

# loop over each buffer length to create the buffer
# then, reproject and unify any overlapping shapes
buffer_5km = midwestern_meters['geometry'].buffer(5000)
gdf_buffer_5km_degrees = buffer_5km.to_crs(4326)
union_buffer_5km_degrees = shapely.unary_union(gdf_buffer_5km_degrees)
```

Let's plot our 5km buffer on a map. <!-- I think there needs to be more explanation here about why you need a loop to plot this given how easy it was to plot our original polygon. Is this loop there because you need to join the buffers? -->

```{python}
#| echo: true
#| eval: false
# import matplotlib for plotting
import matplotlib.pyplot as plt

# set initial shapefile as axis
ax = midwestern.plot(edgecolor = "black", linewidth = 2.0, facecolor = "white")

# loop over buffers and plot on the same axis as original shapefile
if type(union_buffer_5km_degrees) is Polygon:
    plt.plot(*union_buffer_5km_degrees.exterior.xy,c='#00008b',lw=2.0,label=length)
else:
    for j,geom in enumerate(union_buffer_5km_degrees.geoms):
        if j==0:
            plt.plot(*geom.exterior.xy,c='#00008b',lw=2.0,label=length)
        else:
            plt.plot(*geom.exterior.xy,c='#00008b',lw=2.0)

# remove axis to make plot look prettier
ax.axis('off')
```

```{python}
#| echo: false
#| eval: true
# import matplotlib for plotting
import matplotlib.pyplot as plt

# set initial shapefile as axis
ax = midwestern.plot(edgecolor = "black", linewidth = 2.0, facecolor = "white")

# loop over buffers and plot on the same axis as original shapefile
if type(union_buffer_5km_degrees) is Polygon:
    plt.plot(*union_buffer_5km_degrees.exterior.xy,c='#00008b',lw=2.0,label='5km')
else:
    for j,geom in enumerate(union_buffer_5km_degrees.geoms):
        if j==0:
            plt.plot(*union_buffer_5km_degrees.exterior.xy,c='#00008b',lw=2.0,label='5km')
        else:
            plt.plot(*union_buffer_5km_degrees.exterior.xy,c='#00008b',lw=2.0)

# remove axis
a = ax.axis('off')
plt.show();
```

<!--
Perhaps it would be useful to show how to use the buffer to download data or filter data? Or is that too much? You could download data with a bounding box slightly larger than your polygon (in a folded code chunk) and show what the data look like in a table and an aside map? Then you could show how to filter your data to within your bounding box? Might be overkill, I can't quite tell
-->


# Obfuscation and why it's important for sensitive species

When we talk about a record being obfuscated, we mean that the coordinate location of this record has been obscured so that it is no longer exactly precise to where the record was originally recorded. There are several ways to obscure a record's location, but a common way is to reduce the number of decimals in latitude and longitude coordinates, therefore reducing the point's precision.

<!-- 
I think there could be merit for something to show this decimal rounding. The level of difficulty is up to you. At the lowest level, perhaps a table showing a few longer decimalLongitude and decimalLatitude coordinates in one column, and their obfuscated counterpart coordinates in another column. At the highest level, you could create an animation where the first frame shows a few point locations, then the dots smoothly transition to a second frame showing where they end up after obfuscation.

Shandiya did this once in a previous labs post: https://labs.ala.org.au/posts/2023-08-28_alternatives-to-box-plots/#why-not-box-plots

If animation isn't that simple, I could probably make something in R if that's easier.
-->

When data is sent to data infrastructures like the [Atlas of Living Australia](), obfuscation of species records is performed in accordance with the state or territory the species is located, typically obscured to 1km, 10km or 50km of a species' original location[^witheld]. Alternatively, iNaturalist pre-obfuscates data at a 30km resolution prior to sharing data with the Atlas of Living Australia.

[^witheld]: Some records, if the species is very sensitive, may be witheld altogether.

How this affects our ability to know the true location of a species in an area is illustrated in the diagram below. Reducing the number of decimals in longitude/latitude coordinates tends to appear as if points were snapped onto a grid as point precision is lost. The *true* location of the point might be anywhere in a 5km radius. Where *exactly* the point was depends on how the point was rounded, and so it's equally possible that a point could 
  * Appear inside a specified area when its true location is outside the area (left), 
  * Appear inside a specified area when its true location is in the area (middle, the ideal) 
  * Appear outside a specified area when its true location is inside the area (right) 

<!-- 
I think these scenarios are a little off. Would you mind editing them slightly in the dataviz? I've edited the text above to reflect them, but the three scenarios I think we should communicate are
  1. a point appears inside the area when it's actually outside 
  2. a point appears inside the area when it is actually there
  3. a point appears outside the area when it's actually inside

Additionally, this plot needs a legend somewhere to specify what the points represent (which one is the true location and which one is the obscured location?). In my opinion, it might be better to have the true data point in a dark colour, then the obfuscated point in a lighter shade of that colour (perhaps a lower opacity?), and the radius can be made a touch more see-through too to accommodate.
-->

```{python}
#| echo: false
#| eval: true
#| fig-caption: "Three theoretical but possible scenarios where obfuscation of the original point (in green) results in the obscured location ending up (1) inside an area, (2) in the buffered area, or (3) outside the area and the buffered area."
fig,ax = plt.subplots(1,3)
from shapely.geometry import Point

for i in range(len(ax)):

    # plot initial shape and point
    a = midwestern.plot(ax=ax[i],edgecolor = "black", linewidth = 2.0, facecolor = "None", alpha = 1, figsize = (12,6))
    a = ax[i].plot(149.9,-33.15,'o',c='green')

    # create buffer around point
    point = gpd.GeoDataFrame({'geometry': Point([149.9,-33.15])},index=[0]).set_crs(4326)
    point_meters = point.to_crs(3577)
    buffered_point = point_meters['geometry'].buffer(50000)
    buffered_point_degrees = buffered_point.to_crs(4326)
    buffered_point_degrees.plot(ax=ax[i],edgecolor='orange',linewidth=2.0, facecolor='orange',alpha = 0.35)
    
    # buffer midwestern
    buffer = midwestern_meters['geometry'].buffer(25000)
    gdf_buffers_degrees = buffer.to_crs(4326)
    union_buffers_degrees = shapely.unary_union(gdf_buffers_degrees)
    
    if type(union_buffers_degrees) is Polygon:
        a = ax[i].plot(*union_buffers_degrees.exterior.xy,c='#00008b',lw=2.0,label=buffer)
    else:
        for j,geom in enumerate(union_buffers_degrees.geoms):
            if j==0:
                a = ax[i].plot(*geom.exterior.xy,c='#00008b',lw=2.0,label=length)
            else:
                a = ax[i].plot(*geom.exterior.xy,c='#00008b',lw=2.0)

    # add demonstration points
    if i == 0:
        a = ax[i].set_title('In Original Area',fontsize=10)
        a = ax[i].plot(149.8,-32.82,'o',c='purple')
    if i == 1:
        a = ax[i].set_title('In Buffer Area',fontsize=10)
        a = ax[i].plot(150.2,-33.03,'o',c='purple')
    if i == 2:
        a = ax[i].set_title('Outside Buffer Area',fontsize=10)
        a = ax[i].plot(149.7,-33.5,'o',c='purple')

    # set axis limits and remove numbers for better visualisation
    a = ax[i].set_ylim([-33.65,-31.7])
    a = ax[i].set_xlim([148.7,150.8])
    a = ax[i].axis('off')

plt.show()
```

In ecological assessment, it is generally better to capture more than less due to species' interactions with their broader ecosystems (outside of our human-defined boundaries). Therefore, the goal we are trying to achieve by using a buffer is to realistically estimate how many species are influenced by the health of our defined area. 

# Example: The stuttering frog

Let's see an example of how buffer size affects our ability to detect sensitive species in our area of interest.

The stuttering frog (*Mixophyes balbus*) is a large Australian species of frog that inhabits temperate and sub-tropical rainforest and wet sclerophyll forest.  They have a brown back and a yellow underbelly, with a light blue iris that diffuses into gold above the pupil. <!--Another characteristic is a dark head stripe that starts before the nostril as a triangle, goes through the eye, and finishes over the shoulder.--><!-- Maybe one description too many. What about a behavioural description, or a description of why they are called the stuttering frog?-->

<!-- You might want to choose a different 3rd picture as it's getting chopped off slightly unfortunately-->

::: {layout-ncol="3" style="margin-left: auto; margin-right: auto;"}
<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/3/7/1/1/67afd228-c7ce-4cae-94bf-fcd76baf1173/original" class="rounded"/></img>

<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/a/6/9/8/5a8b9d78-cd00-4d64-b8c3-91521a3a896a/original" class="rounded"/></img>

<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/1/d/b/7/f33896e7-e677-4f2d-8672-62ee7ed27bd1/original" class="rounded"/></img>
:::

::: figure-caption
Left: [*Mixophyes balbus* (Darren Fielder CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/e20b3c82-d995-4ad4-bed0-cd8769ec5b1f), 
Middle: [*Mixophyes balbus* (liznoble CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/62bf735b-6c70-410f-aea3-006d12fb011f), Right: [*Mixophyes balbus* (Matt Clancy CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/0d25faa5-694c-4e14-88c5-62863848cd6c)
:::

## Download data

Let's download occurrence records of stuttering frogs in a bounding box that encompasses an area slightly larger than Mid-western LGA.

<!-- 
Object naming suggestion: 
Your object names become more and more verbose in this section, but you are only dealing with one species of frog in one area. So to cut words I'd suggest renaming `stuttering_frogs_midwestern` to `frogs` for brevity, and continue that change throughout the rest of the code below
-->

```{python}
#| echo: true
#| eval: false
import galah
import shapely
galah.galah_config(email="<your-email-address>")
#                              xmin,  ymin,  xmax,   ymax
bbox_midwestern = shapely.box(148.5, -33.6, 151.1, -31.6)
stuttering_frogs_midwestern = galah.atlas_occurrences(
    taxa='Mixophyes balbus',
    bbox=bbox_midwestern
)
stuttering_frogs_midwestern
```

```{python}
#| echo: false
#| eval: true
import galah
import shapely
galah.galah_config(email="amanda.buyan@csiro.au")
bbox_midwestern = shapely.box(148.5, -33.6, 151.1, -31.6)
stuttering_frogs_midwestern = galah.atlas_occurrences(
    taxa='Mixophyes balbus',
    bbox=bbox_midwestern
)
stuttering_frogs_midwestern
```

:::{.callout-tip collapse="true"}

## Checking whether a species is sensitive/threatened
<!-- 
I don't think this is essential to your point. People should know how to check this, but *we* wouldn't need to check this if we already knew the species was sensitive. I've placed this in a pop-up so people can see it if they want.

Edit: I see you are using this because it gives information about obfuscation. There are other ways to do this too - I mention them in a later comment. Maybe we can decide what the best way is, but my sense is to not suggest a new argument that we haven't really tested yet (I have no idea what "raw" fields are retained in other lists)
-->

Sensitive species in the ALA are obfuscated by an amount specified by the state/territory where it is found. The ALA has up-to-date sensitive species lists for each state and territory which we can find using {galah-python}.  First, we search for available lists in New South Wales using `search_all()`. Our output shows a New South Wales sensitive species has the ID `dr487`.

```{python}
galah.search_all(lists="New South Wales")
```

We can pass this ID and the species are interested in to `search_values()` to determine whether the stuttering frog is listed. It's also possible to download the entire list using `show_values()`.

```{python}
galah.search_values(lists=True,field='dr487',value='Mixophyes balbus',column_name='scientificName',include_statuses=True)
```

<!-- what is this `include_statuses` argument? Is that meant to be equivalent to the `all_fields = TRUE` argument I mentioned is now in galah-R? Is it specific to only sensitive species lists? If not, I'd suggest changing the argument name to match galah-R because it doesn't only return status information (most of the additional columns are taxonomic). If you have a better name, we can discuss, but I think it's a bit confusing to have two differently named arguments do the same thing in 2 versions of the same package -->

:::

## Add a radius around points

Now, we know that in New South Wales, *Mixophyes balbus* is obfuscated to a radius of 10km. <!-- An alternative way to get that information is to add the `dataGeneralizations` and/or `generalisationInMetres` fields to a query. The advantage of this method is it's not dependent on a list look-up, but can be added to the original query -->  Therefore, it is best to represent these occurrences as circles with radii 10km <!-- Not sure I agree that it is 'best' (it's technically inaccurate), but it's a way for us to consider the uncertainty around these points (eventhough it's an inacccurate representation). I'd suggest fixing the wording here -->.  To add this radius, we'll first remove any records missing coordinates and convert our dataframe to a `GeoDataFrame`.

<!-- This section once again needs to be broken up. I've made a suggested break here-->

```{python}
# drop entries without coordinates, as well as duplicates
stuttering_frogs_midwestern_unique_points = stuttering_frogs.drop_duplicates(subset=['decimalLatitude','decimalLongitude']).dropna().reset_index(drop=True)

# change the pandas dataframe into a GeoDataFrame to add buffers
stuttering_frogs_midwestern_gdf = gpd.GeoDataFrame(
    stuttering_frogs_midwestern_unique_points, 
    geometry=gpd.points_from_xy(stuttering_frogs_midwestern_unique_points.decimalLongitude, stuttering_frogs_midwestern_unique_points.decimalLatitude), 
    crs="EPSG:4326"
)
```

Now we can add a buffer radius of 10km (10,000m) around each point using the same process we used earlier to create buffers. <!-- I don't think it's exactly the same (looking at your code), so maybe it needs a very short explanation here of what's going on. On a side note, why do you have to set the CRS so many times, and does it need to be a separate step everytime? Why not set it at the end of other steps? -->

```{python}
# change points to metres to add buffer
stuttering_frogs_midwestern_gdf_meters = stuttering_frogs_midwestern_gdf.to_crs(3577)

# add a buffer column to the same dataframe
stuttering_frogs_midwestern_gdf_meters['buffer'] = None
for i,row in stuttering_frogs_midwestern_gdf_meters.iterrows():
    stuttering_frogs_midwestern_gdf_meters.loc[i,'buffer'] = row["geometry"].buffer(10000)

# set the CRS again so GeoPandas knows what CRS the buffers are in
stuttering_frogs_midwestern_gdf_meters = stuttering_frogs_midwestern_gdf_meters.set_crs(3577)

# remove geometry column and replace with the buffered points
del(stuttering_frogs_midwestern_gdf_meters['geometry'])
stuttering_frogs_midwestern_gdf_meters = stuttering_frogs_midwestern_gdf_meters.rename(columns={'buffer': 'geometry'})

# set the CRS again so GeoPandas knows what CRS the buffers are in
stuttering_frogs_midwestern_gdf_meters = stuttering_frogs_midwestern_gdf_meters.set_crs(3577)

# change the points back to EPSG:4326 for parity with shape file
stuttering_frogs_midwestern_gdf_buffer_degrees = stuttering_frogs_midwestern_gdf_meters.to_crs(4326)
```

Our individual points are now replaced as buffers with a radius of 10km.

```{python}
stuttering_frogs_midwestern_gdf_buffer_degrees.plot(facecolor='orange',alpha=0.15,linewidth=1.0, edgecolor='orange')
```

## How buffer size affects species detection

<!-- 
hmmm, your original text encompasses what we talked about but I'm not sure I agreed with the final point. A 25km buffer seems like it practically doubles the size of our original area, so that's a bit much I'd say. I think most people would choose somewhere between the 5-15km range given the size of the area.

I think what's worth mentioning here is that no buffer (or a small one) seems like it might miss detecting this species of frog, but 10-15km range would detect it. I've edited the text to reflect this but it might need a little more editing
-->

Let's consider how different buffer sizes impact our ability to detect sensitive species.  Below, we've created six buffers of increasing size around Midwestern. The stuttering frog observations are *just* outside of our area; without a buffer this frog species would go undetected, but with a 30km buffer we would detect several observations. Which should we choose?

Given the size of our area of interest, we'd likely choose a buffer between 5-15km. 

Although a larger buffer of 25-30km captures more species records, there is a risk that our buffer also captures too many species --- more than are realistically interacting with our area. When we draw our buffer, considering things like topography, river systems, and nutrient gradients might help us determine how big our buffer should practically be.  Ultimately, buffer size will depend on the question we trying to answer, whether that's for research, monitoring, conservation or environmental impact assessment prior to development.

<!-- Maybe double check the code notes in this chunk, some seem unfinished? Also, is there a reason why you need two separate code blocks for this? Could you delete one? -->

```{python}
#| echo: true
#| eval: false
#| code-fold: true
fig,ax = plt.subplots(2,3) #,figsize=(15,10))
extra = 0

# initialise buffer data for visualisation
buffer_shapes = {}
buffer_lengths = {"5km": 5000, "10km": 10000,"15km": 15000,"20km": 20000,"25km": 25000,"30km": 30000}
buffer_distances = list(buffer_lengths.keys())

# get shapefile into Australian Albers CRS
midwestern_meters = midwestern.to_crs(3577)

# loop over each buffer length to create the buffer
# then, convert it back to degrees for conformance with the ALA CRS and unify any overlapping shapes
for length in buffer_lengths:
  buffer = midwestern_meters['geometry'].buffer(buffer_lengths[length])
  gdf_buffers_degrees = buffer.to_crs(4326)
  union_buffers_degrees = shapely.unary_union(gdf_buffers_degrees)
  buffer_shapes[length] = union_buffers_degrees

# loop over all aces for plotting
for i in range(len(ax)):
    for j in range(len(ax[i])):

        # plot circles on map for reference
        stuttering_frogs_midwestern_gdf_buffer_degrees.plot(
            ax=ax[i][j],facecolor='#d4af37',alpha=0.5,linewidth=2.0, edgecolor='#d4af37',label='label'
        ) 

        # if it is first plot, there are
        if i == 0 and j == 0:

            # there is no buffer; plot the original shape file
            ax[i][j].set_title("No Buffer",fontsize=14)
            midwestern.plot(ax=ax[i][j],edgecolor = "black", linewidth = 2.0, facecolor = "None")

            # get count of 
            count=galah.atlas_occurrences(taxa='Mixophyes balbus',polygon=midwestern['geometry'][74]).drop_duplicates(subset=['decimalLatitude','decimalLongitude']).dropna().reset_index(drop=True)
            ax[i][j].text(150.2,-31.85,'Count={}'.format(count.shape[0]),fontsize=12,color='#6E260E')

        # else, draw buffer around shape and plot it
        else:

            # get buffer 
            buffer = buffer_distances[i+j+extra-1]
            
            # set title and plot original shape
            ax[i][j].set_title("{} Buffer".format(buffer),fontsize=14)
            midwestern.plot(ax=ax[i][j],edgecolor = "black", linewidth = 2.0, facecolor = "None", alpha = 1)

            # get raw number of sensitive species, drop duplicates and records without lat/long
            count=galah.atlas_occurrences(taxa='Mixophyes balbus',polygon=buffer_shapes[buffer]).drop_duplicates(subset=['decimalLatitude','decimalLongitude']).dropna().reset_index(drop=True)

            # add number of counts to graph for reference
            ax[i][j].text(150.2,-31.85,'Count={}'.format(count.shape[0]),fontsize=12,color='#6E260E')
            
            # draw buffer on plot
            if type(buffer_shapes[buffer]) is Polygon:
                ax[i][j].plot(*buffer_shapes[buffer].exterior.xy,c='#00008b',lw=2.0,label=buffer)
            else:
                for j,geom in enumerate(buffer_shapes[buffer].geoms):
                    if j==0:
                        ax[i][j].plot(*geom.exterior.xy,c='#00008b',lw=2.0,label=length)
                    else:
                        ax[i][j].plot(*geom.exterior.xy,c='#00008b',lw=2.0)

        # change limits of graph and set whitespace for better looking plot
        ax[i][j].set_ylim([-33.75,-31.7])
        ax[i][j].set_xlim([148.7,150.8])
        plt.setp(ax[i][j].get_xticklabels(), visible=False)
        plt.setp(ax[i][j].get_xticklines(), visible=False)
        plt.setp(ax[i][j].get_yticklabels(), visible=False)
        plt.setp(ax[i][j].get_yticklines(), visible=False)
        ax[i][j].set_aspect('equal')
        plt.subplots_adjust(wspace=0, hspace=0.15)

    # ensure that we get subplots on both lines of the overall plot
    extra += 3
```

```{python}
#| echo: false
#| eval: true

# set axis here
fig,ax = plt.subplots(2,3,figsize=(15,10))
extra = 0

# initialise buffer data for visualisation
buffer_shapes = {}
buffer_lengths = {"5km": 5000, "10km": 10000,"15km": 15000,"20km": 20000,"25km": 25000,"30km": 30000}
buffer_distances = list(buffer_lengths.keys())

# get shapefile into Australian Albers CRS
midwestern_meters = midwestern.to_crs(3577)

# loop over each buffer length to create the buffer
# then, convert it back to degrees for conformance with the ALA CRS and unify any overlapping shapes
for length in buffer_lengths:
  buffer = midwestern_meters['geometry'].buffer(buffer_lengths[length])
  gdf_buffers_degrees = buffer.to_crs(4326)
  union_buffers_degrees = shapely.unary_union(gdf_buffers_degrees)
  buffer_shapes[length] = union_buffers_degrees

# loop over all aces for plotting
for i in range(len(ax)):
    for j in range(len(ax[i])):

        # plot circles on map for reference
        a = stuttering_frogs_midwestern_gdf_buffer_degrees.plot(
            ax=ax[i][j],facecolor='#d4af37',alpha=0.5,linewidth=2.0, edgecolor='#d4af37',label='label'
        ) 

        # if it is first plot, there are
        if i == 0 and j == 0:

            # there is no buffer; plot the original shape file
            a = ax[i][j].set_title("No Buffer",fontsize=24)
            a = midwestern.plot(ax=ax[i][j],edgecolor = "black", linewidth = 2.0, facecolor = "None")

            # get count of 
            count=galah.atlas_occurrences(taxa='Mixophyes balbus',polygon=midwestern['geometry'][74]).drop_duplicates(subset=['decimalLatitude','decimalLongitude']).dropna().reset_index(drop=True)
            a = ax[i][j].text(150.05,-31.85,'Count={}'.format(count.shape[0]),fontsize=20,color='#6E260E')

        # else, draw buffer around shape and plot it
        else:

            # get buffer 
            buffer = buffer_distances[i+j+extra-1]
            
            # set title and plot original shape
            a = ax[i][j].set_title("{} Buffer".format(buffer),fontsize=24)
            a = midwestern.plot(ax=ax[i][j],edgecolor = "black", linewidth = 2.0, facecolor = "None", alpha = 1)

            # get raw number of sensitive species, drop duplicates and records without lat/long
            count=galah.atlas_occurrences(taxa='Mixophyes balbus',polygon=buffer_shapes[buffer]).drop_duplicates(subset=['decimalLatitude','decimalLongitude']).dropna().reset_index(drop=True)

            # add number of counts to graph for reference
            a = ax[i][j].text(150.05,-31.85,'Count={}'.format(count.shape[0]),fontsize=20,color='#6E260E')
            
            # draw buffer on plot
            if type(buffer_shapes[buffer]) is Polygon:
                a = ax[i][j].plot(*buffer_shapes[buffer].exterior.xy,c='#00008b',lw=2.0,label=buffer)
            else:
                for j,geom in enumerate(buffer_shapes[buffer].geoms):
                    if j==0:
                        a = ax[i][j].plot(*geom.exterior.xy,c='#00008b',lw=2.0,label=length)
                    else:
                        a = ax[i][j].plot(*geom.exterior.xy,c='#00008b',lw=2.0)

        # change limits of graph and set whitespace for better looking plot
        a = ax[i][j].set_ylim([-33.75,-31.7])
        a = ax[i][j].set_xlim([148.7,150.8])
        a = plt.setp(ax[i][j].get_xticklabels(), visible=False)
        a = plt.setp(ax[i][j].get_xticklines(), visible=False)
        a = plt.setp(ax[i][j].get_yticklabels(), visible=False)
        a = plt.setp(ax[i][j].get_yticklines(), visible=False)
        a = ax[i][j].set_aspect('equal')
        plt.subplots_adjust(wspace=0, hspace=0.15)
    # ensure that we get subplots on both lines of the overall plot
    extra += 3

# show the plot
plt.show()
```

# Final thoughts

We hope this post has helped you understand how to draw buffers around a shape, as well as the importance of considering buffer size when determining sensitive/threatened species in an area.

For other Python posts, check out [our beginnerâ€™s guide to map species observations](https://labs.ala.org.au/posts/2023-12-18_beginners-guide-make-a-map/) or see [how to cross reference a species list with a conservation list](https://labs.ala.org.au/posts/2024-02-12_species-lists/).

<details><summary style = "color: #E06E53;">Expand for session info</summary>

```{python}
#| echo: false
import math
import natsort
import pandas
import session_info

session_info.show()
```

</details>
