---
title: "Add buffers to a shapefile"
description: |
  Knowing what species have been observed in a local area is a regular task for ecosystem management. Here we show how to add a buffer to a shapefile using {shapely} and {geopandas}. Then we use {galah-python} and {matplotlib} to demonstrate how data points that have been obfuscated (obscured by reducing their precision) may affect the size of the buffer needed in order to confidently capture species in the area.
  - name: "Amanda Buyan"
  - name: "Dax Kellie"
date: "2025-05-30"
title-block-banner: "#B8573E"
toc: true
toc-location: left
toc-depth: 2
categories:
  - Eukaryota
  - Animalia
  - Amphibia
  - Summaries
  - Python
# image: waffle-chart.png
freeze: true
engine: knitr
jupyter: python3
draft: true
editor_options: 
  chunk_output_type: console
---

```{r}
#| include: false
library(htmltools)
```

<!-- remove metadata section -->
<style>
  #title-block-header.quarto-title-block.default .quarto-title-meta {
      display: none;
  }
</style>



<!-- Author card -->

:::{.author-card}
:::{.author-card-text}

#### Author
[Amanda Buyan](https://labs.ala.org.au/people/Buyan_Amanda/index.html)  
[Dax Kellie](https://labs.ala.org.au/people/Kellie_Dax/index.html)  

#### Date
12 February 2024

:::

:::{.author-card-image}
```{r, out.width='120px', out.extra='style="clip-path: circle();"', echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/amanda.jpg")
```
:::

:::{.author-card-image}
```{r, out.width='120px', out.extra='style="clip-path: circle();"', echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/dax.jpg")
```
:::

:::

<!------------------------ Post starts here ------------------------>

Ecological data is often used to understand what species are found in a given location. This information is a frequent requirement for conservation monitoring, and for environmental impact assessment prior to land development. A common method for this task is to use a **buffer**, an outward boundary around a given area location. Adding a buffer helps to capture all the species in an area, including those that have been observed just outside the area but might live in, or be affected by that area.

Choosing a buffer size, however, can be tougher than it seems. Individual organisms move, either over the course of a day or an entire season (e.g. migration, perennial growth), so species' lifecycles and behaviours may determine the size of our final buffer. A more difficult challenge occurs when species are considered sensitive or endangered. These species' exact point locations are often obfuscated (aka their location is made less precise) to keep these species safe. This added imprecision will again affect our final decision on buffer size.

In this post, we'll show how to add a buffer around a shapefile with [{geopandas}](https://geopandas.org/en/stable/), [{shapely}](https://shapely.readthedocs.io/en/stable/) and [{matplotlib}](https://matplotlib.org/). Then we will use [{galah-python}](galah.ala.org.au/Python) to download data of Stuttering frogs (*Mixophyes balbus*) to demonstrate how the size of a buffer can affect the detection of sensitive species in an area.

# Draw a buffer

For our example, our area of interest is Mid-Western, a Local Government Area (LGA) in New South Wales. We'll first need to get a shapefile of our area, which we can get by downloading a [shapefile of all LGAs from the Australian Bureau of Statistics](https://www.abs.gov.au/statistics/standards/australian-statistical-geography-standard-asgs-edition-3/jul2021-jun2026/access-and-downloads/digital-boundary-files). Download the zip file of "Local Government Areas - 2024", then place the zip file in your local directory. We can then read in the shapefile and show what it looks like using {geopandas}.

::: aside

For those unfamiliar with Australian geography, the LGA of Mid-Western is located here:

```{python}
#| echo: false
#| eval: true
import geopandas as gpd
import matplotlib
import matplotlib.pyplot as plt
# lgas = gpd.read_file("../data/LGA_2024_AUST_GDA2020.zip")
# this needs to be changed
lgas = gpd.read_file("/Users/buy003/Documents/GitHub/ala-labs/posts/2024-10-18_adding-buffers-in-python/LGA_2024_AUST_GDA2020.zip")
ax = lgas[lgas['STE_NAME21'] == 'New South Wales'].plot(edgecolor = "#5A5A5A", linewidth = 0.5, facecolor = "white")
a = lgas[lgas['LGA_NAME24'] == 'Mid-Western'].plot(ax=ax,facecolor='#00008b')
a = ax.axis('off')
plt.show()
```

:::


```{python}
#| echo: true
#| eval: false
import geopandas as gpd
lgas = gpd.read_file("LGA_2024_AUST_GDA2020.zip")
lgas.head()
```

```{python}
#| echo: false
#| eval: true
import geopandas as gpd
import pandas as pd
pd.set_option('display.max_columns', None)
pd.set_option('expand_frame_repr', False)
lgas = gpd.read_file("./LGA_2024_AUST_GDA2020.zip")
lgas.head()
```

Now, we will create a 5km buffer.  This will involve converting the shapefiles between different Coordinate Reference Systems (CRS)[^crs].

[^crs]: Check out [this section of a previous ALA Labs post](https://labs.ala.org.au/posts/2023-12-18_beginners-guide-make-a-map/#make-a-map) for a more complete explanation of what a CRS is.

We want to draw our buffers in metres, as we are looking at a relatively small area. To do this, we will complete the following steps for a range of buffers:

- Project our polygon `midwestern` using a CRS measured in metres, like Australian Albers (`EPSG:3577`)
- Create a buffer in metres around `midwestern`
- Reproject our polygon `midwestern` and buffer to the CRS of the data we intend to use, `EPSG:4326`[^ala-crs]
- Unify any shapes that overlap into one (shapes will be unified if they intersect)

[^ala-crs]: ALA data is projected using [CRS EPSG:4326](https://epsg.io/4326) (the same one used by Google Earth).

```{python}
# packages
import shapely
from shapely.geometry import Polygon

# get midwestern lga into its own variable
midwestern = lgas[lgas['LGA_NAME24'] == 'Mid-Western']

# reproject to Australian Albers CRS
midwestern_metres = midwestern.to_crs(3577)

# loop over each buffer length to create the buffer
# then, reproject and unify any overlapping shapes
buffer_5km = midwestern_metres['geometry'].buffer(5000)
buffer_5km_degrees = buffer_5km.to_crs(4326)
union_buffer_5km_degrees = shapely.unary_union(buffer_5km_degrees)
```

Let's plot our 5km buffer on a map.  

```{python}
#| echo: true
#| eval: false
# import matplotlib for plotting
import matplotlib.pyplot as plt

# set initial shapefile as axis
ax = midwestern.plot(edgecolor = "black", linewidth = 2.0, facecolor = "white")

# loop over buffers and plot on the same axis as original shapefile
plt.plot(*union_buffer_5km_degrees.exterior.xy,c='#00008b',lw=2.0,label=length)

# remove axis to make plot look prettier
ax.axis('off')
```

```{python}
#| echo: false
#| eval: true
# import matplotlib for plotting
import matplotlib.pyplot as plt

# set initial shapefile as axis
ax = midwestern.plot(edgecolor = "black", linewidth = 2.0, facecolor = "white")

# loop over buffers and plot on the same axis as original shapefile
a = plt.plot(*union_buffer_5km_degrees.exterior.xy,c='#00008b',lw=2.0,label='5km')

# remove axis
a = ax.axis('off')
plt.show();
```

Now that we've drawn our buffer around the Mid-Western LGA, let's go over the role of obfuscation with sensitive species.

# Obfuscation and why it's important for sensitive species

When we talk about a record being obfuscated, we mean that the coordinate location of this record has been obscured.  There are several ways to obscure a record's location, though the most common common way is to reduce the number of decimals, and therefore the points's precision, in latitude and longitude coordinates. <!-- Dax, I'm unsure if it is the most common way - thoughts? --> This is illustrated in the figure below: as the decimal points are removed, the data shifts to a more 'grid-like' representation of the data.  

![](obfuscation.gif)

```{python}
#| echo: true
#| eval: false
#| code-fold: true
# import plotting and animation packages
import matplotlib.animation as animation
import pandas as pd
from IPython.display import display, Javascript
# use below if you are running in jupyter notebook
%matplotlib ipympl

# create dataframe of points for plotting purposes
points = pd.DataFrame({
    'orig_long': [149.9153,149.9181,149.9204,149.9233,149.9101,149.9258,149.9121,149.9163,
                  149.9295,149.9175,149.9287,149.9236,149.9109,149.9091,149.9113,149.9211,
                  149.9073,149.9087,149.9236,149.9241,149.9289], 
    'orig_lat': [-33.3874,-33.3509,-33.3694,-33.3479,-33.3341,-33.3789,-33.3475,-33.3748,
                 -33.3554,-33.3723,-33.3808,-33.3798,-33.3475,-33.3607,-33.3521,-33.3871,
                 -33.3541,-33.3633,-33.3799,-33.3833,-33.3423]
})

# make columns rounded to 3 and 2 decimal places
for i in range(3,1,-1):
    points['round{}_long'.format(i)] = points['orig_long'].round(i)
    points['round{}_lat'.format(i)] = points['orig_lat'].round(i)

# create initial figure
fig,ax = plt.subplots(1,2)

# create dictionary for columns - will be easier to use in update function
column_labels = {0: ['orig_long','orig_lat'], 
                 1: ['round3_long','round3_lat'], 
                 2: ['round2_long','round2_lat']}

# create function to update each frame in animation 
def update(frame):
    
    # first, create a table on the left-hand side of the figure - remove previous plots and change labels
    ax[0].clear()
    ax[0].table(cellText=points[column_labels[frame]].values,colLabels=['Latitude','Longitude'],loc='center')
    ax[0].axis('off')

    # create scatterplot of points
    ax[1].clear()
    ax[1].scatter(points[column_labels[frame][0]],points[column_labels[frame][1]],c='purple')
    ax[1].get_xaxis().set_visible(False)
    ax[1].get_yaxis().set_visible(False)

    # return the figure for plotting
    return fig,ax

# create the animation with matplotlib, and save the animation to a gif
ani = animation.FuncAnimation(fig=fig, func=update, frames=3, interval=1000, repeat=False)
ani.save('obfuscation.gif')
```

When data is sent to data infrastructures like the [Atlas of Living Australia](ala.org.au), obfuscation of species records is performed in accordance with the state or territory the species is located.  This is typically obscured to distances of 1km, 10km or 50km of a species' original location[^witheld]. Alternatively, iNaturalist pre-obfuscates data at a 30km resolution prior to sharing data with the Atlas of Living Australia.

[^witheld]: Some records, if the species is very sensitive, may be witheld altogether.

How this affects our ability to know the true location of a species in an area is illustrated in the diagram below. Reducing the number of decimals in longitude/latitude coordinates tends to appear as if points were snapped onto a grid, as point precision is lost (see the figure above). The *true* location of the point, however, might be anywhere in a 5km radius. Where *exactly* the point was depends on how the point was rounded, and so it's equally possible that a point could 

- Appear inside a specified area when its true location is outside the area (left), 
- Appear inside a specified area when its true location is in the area (middle, the ideal) 
- Appear outside a specified area when its true location is inside the area (right) 

```{python}
#| echo: false
#| eval: true
#| fig-caption: "Three theoretical but possible scenarios where obfuscation of the original point (in green) results in the obscured location ending up (1) inside an area, (2) in the buffered area, or (3) outside the area and the buffered area."
fig,ax = plt.subplots(1,3)
from shapely.geometry import Point

orig_points = {0: [149.9,-33.3], 1: [149.9,-32.5], 2: [150.1,-32.7]}
obf_points = {0: [149.8,-33], 1: [149.9,-32.7], 2: [150.5,-32.7]}
titles = {0: '1', 1: '2', 2: '3'}
    
for i in range(len(ax)):

    # plot initial shape and point
    a = midwestern.plot(ax=ax[i],edgecolor = "grey", linewidth = 2.0, facecolor = "None", alpha = 1, figsize = (12,6))

    # add demonstration points
    a = ax[i].plot(orig_points[i][0], orig_points[i][1],'o',c='black',label='original')
    
    # create buffer around point
    point = gpd.GeoDataFrame({'geometry': Point(orig_points[i])},index=[0]).set_crs(4326)
    point_metres = point.to_crs(3577)
    buffered_point = point_metres['geometry'].buffer(50000)
    buffered_point_degrees = buffered_point.to_crs(4326)
    buffered_point_degrees.plot(ax=ax[i],edgecolor=None,linewidth=2.0, facecolor='orange',alpha = 0.15)

    a = ax[i].plot(obf_points[i][0], obf_points[i][1],'o',c='purple',label='obfuscated', alpha = 0.5)
    
    # set axis limits and remove numbers for better visualisation
    a = ax[i].set_title(titles[i])
    a = ax[i].set_ylim([-33.8,-32])
    a = ax[i].set_xlim([148.7,150.8])
    a = ax[i].axis('off')

handles, labels = ax[0].get_legend_handles_labels()
fig.legend(handles, labels, loc=(0.4,0.2))
plt.show()
```

In ecological assessment, it is generally better to capture more than less due to species' interactions with their broader ecosystems (outside of our human-defined boundaries). Therefore, the goal we are trying to achieve by using a buffer is to realistically estimate how many species are influenced by the health of our defined area, especially sensitive species.

# Example: The stuttering frog

Let's see an example of how buffer size affects our ability to detect sensitive species in our area of interest.

The stuttering frog (*Mixophyes balbus*) is a large Australian species of frog that inhabits temperate, sub-tropical rainforest and wet sclerophyll forest.  They have a brown back and a yellow underbelly, with a light blue iris that diffuses into gold above the pupil.  Their call is a "kook kook kook kra-a-ak kruk kruk", which lasts 1-2 seconds[^wikipedia].

[^wikipedia]: https://en.wikipedia.org/wiki/Stuttering_frog

::: {layout-ncol="3" style="margin-left: auto; margin-right: auto;"}
<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/3/7/1/1/67afd228-c7ce-4cae-94bf-fcd76baf1173/original" class="rounded"/></img>

<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/a/6/9/8/5a8b9d78-cd00-4d64-b8c3-91521a3a896a/original" class="rounded"/></img>

<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/5/9/e/7/0c871c80-dae1-4e13-9e21-b311ca0e7e95/original" class="rounded"/></img>
:::

::: figure-caption
Left: [*Mixophyes balbus* (Darren Fielder CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/e20b3c82-d995-4ad4-bed0-cd8769ec5b1f), 
Middle: [*Mixophyes balbus* (liznoble CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/62bf735b-6c70-410f-aea3-006d12fb011f), 
Right: [*Mixophyes balbus* (lachlan_harriman CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/b37f6a21-2841-439a-9b25-e9073a3fedb6)
:::

## Download data

Let's download occurrence records of stuttering frogs in a bounding box that encompasses an area slightly larger than the Mid-Western LGA.  

::: aside

Downloading all occurrence records using a bounding box for your shapefile, then filtering the records afterwards, can be a quicker way to subset records, rather than waiting for the API to process your shapefile.  A more in-depth article on this in Python exists here: https://galah.ala.org.au/Python/galah_user_guide/Spatial_Filtering.html#spatial-filtering

:::

```{python}
#| echo: true
#| eval: false
import galah
import shapely
galah.galah_config(email="<your-email-address>")
#                              xmin,  ymin,  xmax,   ymax
bbox_midwestern = shapely.box(148.5, -33.6, 151.1, -31.6)
frogs = galah.atlas_occurrences(
    taxa='Mixophyes balbus',
    bbox=bbox_midwestern
)
frogs
```

```{python}
#| echo: false
#| eval: true
import galah
import shapely
galah.galah_config(email="amanda.buyan@csiro.au")
bbox_midwestern = shapely.box(148.5, -33.6, 151.1, -31.6)
frogs = galah.atlas_occurrences(
    taxa='Mixophyes balbus',
    bbox=bbox_midwestern
)
frogs
```

## Add a radius around points

Previously, we mentioned that sensitive records can be obfuscated to different radii, depending on the state or territory the species occurs in.  To get this information, the ALA has a field called `generalisationInMetres`, which will give you the distance a particular species' decimal location should be obfuscated.

```{python}
frogs = galah.atlas_occurrences(
    taxa='Mixophyes balbus',
    bbox=bbox_midwestern,
    fields=["basic","generalisationInMetres"]
)
frogs
```

Now that we have this information, we can consider the uncertainty around these points.  As we mentioned above, the most common method of obfuscation is to remove decimal points, so the obfuscation of a species may not be exactly 10km.  However, a point is not sufficient to represent this uncertainty.  Therefore, we will be drawing circles around these points to better represent what is happening with sensitive species' location.  To do this, we will be removing any points that do not have coordinate locations, as well as removing points with the same latitude and longitude.  We will then convert the `pandas` `DataFrame` to a `GeoDataFrame`, which involves specifying the CRS (in this case, what Google Earth uses), as well as the `geometry`.  **Note that these points are not duplicates, but are obfuscated enough that they look like duplicates.**

::: aside

Every `GeoDataFrame` has to have a `geometry` column specified.

:::

```{python}
# drop entries without coordinates, as well as duplicates
frogs_set = frogs.drop_duplicates(subset=['decimalLatitude','decimalLongitude']).dropna().reset_index(drop=True)

# change the pandas dataframe into a GeoDataFrame
frogs_set_gdf = gpd.GeoDataFrame(
    frogs_set, 
    geometry=gpd.points_from_xy(frogs_set.decimalLongitude, frogs_set.decimalLatitude), 
    crs="EPSG:4326"
)
```

Now we can add a buffer radius of 10km (10,000m) around each point. What we will be doing is similar to the previous section about drawing buffers, in that we will be converting our `GeoDataFrame` to a CRS that is represented in meters, and drawing a buffer (in this instance, around a point, rather than a Polygon).  However, since we are interested in keeping all the information about the points, and not just the buffer shapes, we will have to create a separate column titled `buffer`, and then tell the `GeoDataFrame` that we want the `buffer` column to be our new `geometry`.

```{python}
# change points to metres to add buffer
frogs_set_gdf_metres = frogs_set_gdf.to_crs(3577)

# add a buffer column to the same dataframe
frogs_set_gdf_metres['buffer'] = None
for i,row in frogs_set_gdf_metres.iterrows():
    frogs_set_gdf_metres.loc[i,'buffer'] = row["geometry"].buffer(frogs_set_gdf_metres.loc[i,'generalisationInMetres'])

# set the CRS again so GeoPandas knows what CRS the buffer column is in
frogs_set_gdf_metres = frogs_set_gdf_metres.set_crs(3577)

# remove geometry column and replace with the buffered points
del(frogs_set_gdf_metres['geometry'])
frogs_set_gdf_metres = frogs_set_gdf_metres.rename(columns={'buffer': 'geometry'})

# set the CRS again so GeoPandas knows what CRS the geometry column is in
frogs_set_gdf_metres = frogs_set_gdf_metres.set_crs(3577)

# change the points back to EPSG:4326 for parity with shape file
frogs_set_gdf_degrees = frogs_set_gdf_metres.to_crs(4326)
```

Our individual points are now replaced as circles with a radius of 10km.

```{python}
frogs_set_gdf_degrees.plot(facecolor='orange',alpha=0.15,linewidth=1.0, edgecolor='orange')
```

## How buffer size affects species detection

Let's consider how different buffer sizes impact our ability to detect sensitive species.  Below, we've created six buffers of increasing size around Midwestern. The stuttering frog observations are *just* outside of our area; without a buffer this frog species would go undetected, but with a 30km buffer we would detect several observations. Which should we choose?

Given the size of our area of interest, we'd likely choose a buffer between 5-15km. 

Although a larger buffer of 25-30km captures more species records, there is a risk that our buffer also captures too many species --- more than are realistically interacting with our area. When we draw our buffer, considering things like topography, river systems, and nutrient gradients might help us determine how big our buffer should practically be.  Ultimately, buffer size will depend on the question we trying to answer, whether that's for research, monitoring, conservation or environmental impact assessment prior to development.

```{python}
#| echo: true
#| eval: false
#| code-fold: true
fig,ax = plt.subplots(2,3,figsize=(15,10))
extra = 0

# initialise buffer data for visualisation
buffer_shapes = {}
buffer_lengths = {"5km": 5000, "10km": 10000,"15km": 15000,"20km": 20000,"25km": 25000,"30km": 30000}
buffer_distances = list(buffer_lengths.keys())

# get shapefile into Australian Albers CRS
midwestern_metres = midwestern.to_crs(3577)

# loop over each buffer length to create the buffer
# then, convert it back to degrees for conformance with the ALA CRS and unify any overlapping shapes
for length in buffer_lengths:
  buffer = midwestern_metres['geometry'].buffer(buffer_lengths[length])
  gdf_buffers_degrees = buffer.to_crs(4326)
  union_buffers_degrees = shapely.unary_union(gdf_buffers_degrees)
  buffer_shapes[length] = union_buffers_degrees

# loop over all axes for ease of plotting
for i in range(len(ax)):
    for j in range(len(ax[i])):

        # plot frogs as circles on map for reference
        frogs_set_gdf_degrees.plot(
            ax=ax[i][j],facecolor='#d4af37',alpha=0.5,linewidth=2.0, edgecolor='#d4af37',label='label'
        ) 

        # if this is the first subplot, there is no buffer, so you only draw the original shape and species counts
        if i == 0 and j == 0:

            # there is no buffer; plot the original shape file
            ax[i][j].set_title("No Buffer",fontsize=14)
            midwestern.plot(ax=ax[i][j],edgecolor = "black", linewidth = 2.0, facecolor = "None")

            # get number of unique points within original shape 
            points = [(x,y) for x,y in zip(frogs_set_gdf_degrees["decimalLongitude"],frogs_set_gdf_degrees["decimalLatitude"]) if shapely.contains_xy(midwestern['geometry'][74],x,y)]
            count = len(points)
            
            ax[i][j].text(150.2,-31.85,'Count={}'.format(count),fontsize=12,color='#6E260E')

        # else, draw the buffer around the original shape and include species counts
        else:

            # get buffer 
            buffer = buffer_distances[i+j+extra-1]
            
            # set title and plot original shape
            ax[i][j].set_title("{} Buffer".format(buffer),fontsize=14)
            midwestern.plot(ax=ax[i][j],edgecolor = "black", linewidth = 2.0, facecolor = "None", alpha = 1)

            # get number of unique points within buffered shape 
            points = [(x,y) for x,y in zip(frogs_set_gdf_degrees["decimalLongitude"],frogs_set_gdf_degrees["decimalLatitude"]) if shapely.contains_xy(buffer_shapes[buffer],x,y)]
            count = len(points)
            
            # add number of counts to graph for reference
            ax[i][j].text(150.2,-31.85,'Count={}'.format(count),fontsize=12,color='#6E260E')
            
            # draw buffer on plot
            ax[i][j].plot(*buffer_shapes[buffer].exterior.xy,c='#00008b',lw=2.0,label=buffer)
                
        # change limits of graph and set whitespace for better looking plot
        ax[i][j].set_ylim([-33.75,-31.7])
        ax[i][j].set_xlim([148.7,150.8])
        plt.setp(ax[i][j].get_xticklabels(), visible=False)
        plt.setp(ax[i][j].get_xticklines(), visible=False)
        plt.setp(ax[i][j].get_yticklabels(), visible=False)
        plt.setp(ax[i][j].get_yticklines(), visible=False)
        ax[i][j].set_aspect('equal')
        plt.subplots_adjust(wspace=0, hspace=0.15)

    # add offset to ensure that we get subplots on both lines of the overall plot
    extra += 3
```


```{python}
#| echo: false
#| eval: true
fig,ax = plt.subplots(2,3,figsize=(15,10))
extra = 0

# initialise buffer data for visualisation
buffer_shapes = {}
buffer_lengths = {"5km": 5000, "10km": 10000,"15km": 15000,"20km": 20000,"25km": 25000,"30km": 30000}
buffer_distances = list(buffer_lengths.keys())

# get shapefile into Australian Albers CRS
midwestern_metres = midwestern.to_crs(3577)

# loop over each buffer length to create the buffer
# then, convert it back to degrees for conformance with the ALA CRS and unify any overlapping shapes
for length in buffer_lengths:
  buffer = midwestern_metres['geometry'].buffer(buffer_lengths[length])
  gdf_buffers_degrees = buffer.to_crs(4326)
  union_buffers_degrees = shapely.unary_union(gdf_buffers_degrees)
  buffer_shapes[length] = union_buffers_degrees

# loop over all axes for ease of plotting
for i in range(len(ax)):
    for j in range(len(ax[i])):

        # plot frogs as circles on map for reference
        a = frogs_set_gdf_degrees.plot(
            ax=ax[i][j],facecolor='#d4af37',alpha=0.5,linewidth=2.0, edgecolor='#d4af37',label='label'
        ) 

        # if this is the first subplot, there is no buffer, so you only draw the original shape and species counts
        if i == 0 and j == 0:

            # there is no buffer; plot the original shape file
            a = ax[i][j].set_title("No Buffer",fontsize=14)
            midwestern.plot(ax=ax[i][j],edgecolor = "black", linewidth = 2.0, facecolor = "None")

            # get count of 
            # points = [(x,y) for x,y in zip(lorikeet_brisbane["decimalLongitude"], lorikeet_brisbane["decimalLatitude"]) if shapely.contains_xy(park["geometry"],x,y)]
            points = [(x,y) for x,y in zip(frogs_set_gdf_degrees["decimalLongitude"],frogs_set_gdf_degrees["decimalLatitude"]) if shapely.contains_xy(midwestern['geometry'][74],x,y)]
            count = len(points)
            
            a = ax[i][j].text(150.2,-31.85,'Count={}'.format(count),fontsize=12,color='#6E260E')

        # else, draw the buffer around the original shape and include species counts
        else:

            # get buffer 
            buffer = buffer_distances[i+j+extra-1]
            
            # set title and plot original shape
            a = ax[i][j].set_title("{} Buffer".format(buffer),fontsize=14)
            midwestern.plot(ax=ax[i][j],edgecolor = "black", linewidth = 2.0, facecolor = "None", alpha = 1)

            # get raw number of sensitive species, drop duplicates and records without lat/long
            points = [(x,y) for x,y in zip(frogs_set_gdf_degrees["decimalLongitude"],frogs_set_gdf_degrees["decimalLatitude"]) if shapely.contains_xy(buffer_shapes[buffer],x,y)]
            count = len(points)
            
            # add number of counts to graph for reference
            a = ax[i][j].text(150.2,-31.85,'Count={}'.format(count),fontsize=12,color='#6E260E')
            
            # draw buffer on plot
            a = ax[i][j].plot(*buffer_shapes[buffer].exterior.xy,c='#00008b',lw=2.0,label=buffer)
                
        # change limits of graph and set whitespace for better looking plot
        a = ax[i][j].set_ylim([-33.75,-31.7])
        a = ax[i][j].set_xlim([148.7,150.8])
        a = plt.setp(ax[i][j].get_xticklabels(), visible=False)
        a = plt.setp(ax[i][j].get_xticklines(), visible=False)
        a = plt.setp(ax[i][j].get_yticklabels(), visible=False)
        a = plt.setp(ax[i][j].get_yticklines(), visible=False)
        a = ax[i][j].set_aspect('equal')
        a = plt.subplots_adjust(wspace=0, hspace=0.15)

    # add offset to ensure that we get subplots on both lines of the overall plot
    extra += 3

plt.show();
```

# Final thoughts

We hope this post has helped you understand how to draw buffers around a shape, as well as the importance of considering buffer size when determining sensitive/threatened species in an area.

For other Python posts, check out [our beginnerâ€™s guide to map species observations](https://labs.ala.org.au/posts/2023-12-18_beginners-guide-make-a-map/) or see [how to cross reference a species list with a conservation list](https://labs.ala.org.au/posts/2024-02-12_species-lists/).

<details><summary style = "color: #E06E53;">Expand for session info</summary>

```{python}
#| echo: false
import math
import natsort
import pandas
import session_info

session_info.show()
```

</details>
