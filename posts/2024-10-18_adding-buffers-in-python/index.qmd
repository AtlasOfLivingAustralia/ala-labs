---
title: "Add buffers to a shapefile"
description: |
  Knowing what species have been observed in a local area is a regular task for ecosystem management. Here we show how to add a buffer to a shapefile using {shapely} and {geopandas}. Then we use {galah-python} and {matplotlib} to demonstrate how data points that have been obfuscated (obscured by reducing their precision) may affect the buffer size required to confidently capture species in the area.
  - name: "Amanda Buyan"
  - name: "Dax Kellie"
date: "2025-05-30"
title-block-banner: "#B8573E"
toc: true
toc-location: left
toc-depth: 2
categories:
  - Eukaryota
  - Animalia
  - Amphibia
  - Summaries
  - Python
# image: waffle-chart.png
freeze: true
engine: knitr
jupyter: python3
draft: true
editor_options: 
  chunk_output_type: console
---

```{r}
#| include: false
library(htmltools)
```

<!-- remove metadata section -->
<style>
  #title-block-header.quarto-title-block.default .quarto-title-meta {
      display: none;
  }
</style>



<!-- Author card -->

:::{.author-card}
:::{.author-card-text}

#### Author
[Amanda Buyan](https://labs.ala.org.au/people/Buyan_Amanda/index.html)  
[Dax Kellie](https://labs.ala.org.au/people/Kellie_Dax/index.html)  

#### Date
12 February 2024

:::

:::{.author-card-image}
```{r, out.width='120px', out.extra='style="clip-path: circle();"', echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/amanda.jpg")
```
:::

:::{.author-card-image}
```{r, out.width='120px', out.extra='style="clip-path: circle();"', echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/dax.jpg")
```
:::

:::

<!------------------------ Post starts here ------------------------>

Ecological data is often used to understand what species are found in a given location, especially for conservation monitoring and environmental impact assessment prior to land development. A common method for this task is to use a **buffer**, an outward boundary around a given area location. Adding a buffer helps to capture all the species in an area, including those that have been observed just outside the area and probably live there, too.

Choosing a buffer size, however, can be tougher than it seems. Individual organisms move, either over the course of a day or an entire season (e.g. migration, perennial growth), so species' lifecycles and behaviours may determine the size of our final buffer. A more difficult challenge occurs when species are considered sensitive or endangered. These species' exact point locations are often obfuscated (aka their location is made less precise) to keep these species safe. This added imprecision will again affect our final decision on buffer size.

In this post, we'll show how to add a buffer around a shapefile with [{geopandas}](https://geopandas.org/en/stable/), [{shapely}](https://shapely.readthedocs.io/en/stable/) and [{matplotlib}](https://matplotlib.org/). Then we will use [{galah-python}](galah.ala.org.au/Python) to download data of Stuttering frogs (*Mixophyes balbus*) to demonstrate how the size of a buffer can affect the detection of sensitive species in an area.  Lastly, we will use [{scipy}](https://docs.scipy.org/doc/scipy/#) and [{matplotlib}](https://matplotlib.org/) to show the effect of buffers on detecting threatened species in an area.

# Draw a buffer

For this example, our area of interest is Mid-Western, a Local Government Area (LGA) in New South Wales. We'll first need to download a shapefile of our area, which we can get by downloading a [shapefile of all LGAs from the Australian Bureau of Statistics](https://www.abs.gov.au/statistics/standards/australian-statistical-geography-standard-asgs-edition-3/jul2021-jun2026/access-and-downloads/digital-boundary-files) and filtering to our area. Download the zip file of "Local Government Areas - 2024", then place the zip file in your local directory. We can then read in the shapefile and show what it looks like using {geopandas}.

::: aside

For those unfamiliar with Australian geography, the LGA of Mid-Western is located here:

```{python}
#| echo: false
#| eval: true
import geopandas as gpd
import matplotlib
import matplotlib.pyplot as plt
lgas = gpd.read_file("../data/LGA_2024_AUST_GDA2020.zip")
ax = lgas[lgas['STE_NAME21'] == 'New South Wales'].plot(edgecolor="#292C26", linewidth=0.5, facecolor="white")
a = lgas[lgas['LGA_NAME24'] == 'Mid-Western'].plot(ax=ax, facecolor='#358BA5')
a = ax.axis('off')
plt.show()
```

:::


```{python}
#| echo: true
#| eval: false
import geopandas as gpd
import shapely
from shapely.geometry import Polygon
lgas = gpd.read_file("LGA_2024_AUST_GDA2020.zip")
lgas.head()
```

```{python}
#| echo: false
#| eval: true
import geopandas as gpd
import pandas as pd
import shapely
from shapely.geometry import Polygon
pd.set_option('display.max_columns', None)
pd.set_option('expand_frame_repr', False)
lgas = gpd.read_file("../data/LGA_2024_AUST_GDA2020.zip")
lgas.head()
```

Then we'll filter to Mid-Western.

```{python}
midwestern = lgas[lgas['LGA_NAME24'] == 'Mid-Western']
```


Now, we will create a 5 km buffer around Mid-Western, as we are looking at a relatively small area. To do this, we'll need to convert the shapefiles between different Coordinate Reference Systems (CRS)[^crs] to allow us to draw our buffer. 

First, we'll reproject our polygon `midwestern` to a CRS measured in metres, like Australian Albers (`EPSG:3577`). Then we can create a buffer in metres around `midwestern`. Finally, we'll reproject `midwestern` match the CRS of the data we intend to use, `EPSG:4326`[^ala-crs], and unify any intersecting shapes.

[^crs]: Check out [this section of a previous ALA Labs post](https://labs.ala.org.au/posts/2023-12-18_beginners-guide-make-a-map/#make-a-map) for a more complete explanation of what a CRS is.

[^ala-crs]: ALA data is projected using [CRS EPSG:4326](https://epsg.io/4326) (the same one used by Google Earth).

```{python}
# reproject to Australian Albers CRS
midwestern_metres = midwestern.to_crs(3577)

# create buffer, reproject, unify any overlapping shapes
buffer_5km = midwestern_metres['geometry'].buffer(5000)
buffer_5km_degrees = buffer_5km.to_crs(4326)
union_buffer_5km_degrees = shapely.unary_union(buffer_5km_degrees)
```

Let's plot our 5km buffer on a map.  

```{python}
#| echo: true
#| eval: false
# import matplotlib for plotting
import matplotlib.pyplot as plt

# set initial shapefile as axis
ax = midwestern.plot(edgecolor="#292C26", linewidth = 2.0, facecolor="white")

# plot buffer on same axis as original shapefile
plt.plot(*union_buffer_5km_degrees.exterior.xy, c='#358BA5', lw=2.0, label=length)
ax.axis('off') # remove axis to make plot look prettier
```

```{python}
#| echo: false
#| eval: true
import matplotlib.pyplot as plt

# set initial shapefile as axis
ax = midwestern.plot(edgecolor="#292C26", linewidth=2.0, facecolor="white")

# plot buffer on same axis as original shapefile
a = plt.plot(*union_buffer_5km_degrees.exterior.xy, c='#358BA5', lw=2.0, label='5km')
a = ax.axis('off') # remove axis to make plot look prettier
plt.show();
```

Now that we've drawn our buffer around the Mid-Western LGA, let's discuss how data obfuscation affects our ability to detect sensitive species.

# Obfuscation and why it's important for sensitive species

When we talk about a record being **obfuscated**, we mean that the coordinate location of this record has been obscured in some way.  There are several methods to obscure a record's location. One of the more straightforward methods is to reduce the number of decimals in the record's lat/lon coordinates, lowering the point's precision. This figure below illustrates this; as the decimal points are removed, the data appears more 'grid-like' as the data loses resolution.  

```{python}
#| echo: true
#| eval: false
#| code-fold: true
# import plotting and animation packages
import matplotlib.animation as animation
import pandas as pd
from IPython.display import display, Javascript
# use below if you are running in jupyter notebook
%matplotlib ipympl

# create dataframe of points
points = pd.DataFrame({
    'orig_long': [149.9153,149.9181,149.9204,149.9233,149.9101,149.9258,149.9121,149.9163,
                  149.9295,149.9175,149.9287,149.9236,149.9109,149.9091,149.9113,149.9211,
                  149.9073,149.9087,149.9236,149.9241,149.9289], 
    'orig_lat': [-33.3874,-33.3509,-33.3694,-33.3479,-33.3341,-33.3789,-33.3475,-33.3748,
                 -33.3554,-33.3723,-33.3808,-33.3798,-33.3475,-33.3607,-33.3521,-33.3871,
                 -33.3541,-33.3633,-33.3799,-33.3833,-33.3423]
})

# Round to 3 and 2 decimal places
for i in range(3,1,-1):
    points['round{}_long'.format(i)] = points['orig_long'].round(i)
    points['round{}_lat'.format(i)] = points['orig_lat'].round(i)

# create initial figure
fig,ax = plt.subplots(1,2)

# create dictionary for columns - will be easier to use in update function
column_labels = {0: ['orig_long', 'orig_lat'], 
                 1: ['round3_long', 'round3_lat'], 
                 2: ['round2_long', 'round2_lat']}

# create function to update each frame in animation 
def update(frame):
    
    # first, create a table on the left-hand side of the figure - remove previous plots and change labels
    ax[0].clear()
    ax[0].table(cellText=points[column_labels[frame]].values, colLabels=['Latitude','Longitude'],loc='center')
    ax[0].axis('off')

    # create scatterplot of points
    ax[1].clear()
    ax[1].scatter(points[column_labels[frame][0]], points[column_labels[frame][1]], c='#5A2A57', alpha=0.5)
    ax[1].get_xaxis().set_visible(False)
    ax[1].get_yaxis().set_visible(False)

    # return the figure for plotting
    return fig,ax

# create the animation with matplotlib, and save the animation to a gif
ani = animation.FuncAnimation(fig=fig, func=update, frames=3, interval=1000, repeat=False)
ani.save('obfuscation.gif')
```

![](obfuscation.gif)

When data is sent to data infrastructures like the [Atlas of Living Australia](ala.org.au), obfuscation of species records is performed in accordance with the state or territory the species is located, typically to distances of 1km, 10km or 50km from a species' original location[^witheld]. 

[^witheld]: Some records, if the species is very sensitive, may be witheld altogether.

::: aside
Alternatively, iNaturalist pre-obfuscates data at a 30km resolution prior to sharing data with the Atlas of Living Australia.
:::

How this affects our ability to know the true location of a species in an area is illustrated in the diagram below. The *true* location of the point might be anywhere in its defined radius, and its the new obscured location point will depend which direction the decimal was rounded (and by how many decimal points its resolution has been reduced). It's equally possible that an obfuscated record could be located

1.  Inside a specified area when its true location is outside the area (left), 
2.  Inside a specified area when its true location is inside the area (middle) 
3.  Outside a specified area when its true location is inside the area (right) 

```{python}
#| echo: false
#| eval: true
#| fig-caption: "Three theoretical but possible scenarios where obfuscation of the original point (in green) results in the obscured location ending up (1) inside an area, (2) in the buffered area, or (3) outside the area and the buffered area."
fig,ax = plt.subplots(1,3)
from shapely.geometry import Point

orig_points = {0: [150.2,-33], 1: [149.9,-32.5], 2: [150.1,-32.7]}
obf_points = {0: [149.8,-32.8], 1: [149.9,-32.7], 2: [150.5,-32.7]}
titles = {0: '1', 1: '2', 2: '3'}

# create buffer around point
point = gpd.GeoDataFrame({'geometry': Point([150.1,-32.7])}, index=[0]).set_crs(4326)
point_metres = point.to_crs(3577)
buffered_point = point_metres['geometry'].buffer(50000)
buffered_point_degrees = buffered_point.to_crs(4326)

for i in range(len(ax)):

    # plot initial shape and point
    a = midwestern.plot(ax=ax[i], edgecolor="#292C26", linewidth=2.0, facecolor="None", alpha=1, figsize=(12,6))

    buffered_point_degrees.plot(ax=ax[i], edgecolor=None, linewidth=2.0, facecolor='orange', alpha = 0.15)
    
    # add demonstration points
    a = ax[i].plot(orig_points[i][0], orig_points[i][1], 'o', c='black', label='original')
    a = ax[i].plot(obf_points[i][0], obf_points[i][1], 'o', c='#5A2A57', label='obfuscated', alpha = 0.5)
    
    # set axis limits and remove numbers for better visualisation
    a = ax[i].set_title(titles[i])
    a = ax[i].set_ylim([-33.8,-32])
    a = ax[i].set_xlim([148.7,150.8])
    a = ax[i].axis('off')

handles, labels = ax[0].get_legend_handles_labels()
fig.legend(handles, labels, loc=(0.4,0.2))
plt.show()
```

Thanks to obfuscation, we can't know which of these three scenarios might be true for our individual record!

The main takeaway is that obfuscation makes it harder to know that you are accurately capturing all the species in a defined area. In ecological assessment, it's generally better to capture more rather than less because species interact with their broader ecosystems (outside of our human-defined boundaries). Therefore, the goal *we* are trying to achieve by using a buffer is to realistically estimate how many species are influenced by the health of our defined area, not just what has been observed within a predefined boundary.

# Example: The stuttering frog

Let's see an example of how buffer size affects our ability to detect sensitive species in our area of interest.

The stuttering frog (*Mixophyes balbus*) is a large Australian species of frog that inhabits temperate, sub-tropical rainforest and wet sclerophyll forest.  They have a brown back and a yellow underbelly, with a light blue iris that diffuses into gold above the pupil.  Their call is a "kook kook kook kra-a-ak kruk kruk", which lasts 1-2 seconds[^wikipedia].

[^wikipedia]: https://en.wikipedia.org/wiki/Stuttering_frog

::: {layout-ncol="3" style="margin-left: auto; margin-right: auto;"}
<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/3/7/1/1/67afd228-c7ce-4cae-94bf-fcd76baf1173/original" class="rounded"/></img>

<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/a/6/9/8/5a8b9d78-cd00-4d64-b8c3-91521a3a896a/original" class="rounded"/></img>

<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/5/9/e/7/0c871c80-dae1-4e13-9e21-b311ca0e7e95/original" class="rounded"/></img>
:::

::: figure-caption
Left: [*Mixophyes balbus* (Darren Fielder CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/e20b3c82-d995-4ad4-bed0-cd8769ec5b1f), 
Middle: [*Mixophyes balbus* (liznoble CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/62bf735b-6c70-410f-aea3-006d12fb011f), 
Right: [*Mixophyes balbus* (lachlan_harriman CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/b37f6a21-2841-439a-9b25-e9073a3fedb6)
:::

### Download data

Let's download occurrence records of stuttering frogs in a bounding box that encompasses an area slightly larger than the Mid-Western LGA[^bbox]. We will also include a column with the distance each record's location has been obfuscated, `generalisationInMetres`.

[^bbox]: Downloading all occurrence records using a bounding box *then* filtering the records to fit a shapefile can be a quicker way to subset records (rather than waiting for the API to process a more complex shapefile polygon shape). You can find a more in-depth article on this [here](https://galah.ala.org.au/Python/galah_user_guide/Spatial_Filtering.html#spatial-filtering).


```{python}
#| echo: true
#| eval: false
import galah
import shapely
galah.galah_config(email="<your-email-address>")
#                              xmin,  ymin,  xmax,  ymax
bbox_midwestern = shapely.box(148.5, -33.6, 151.1, -31.6)
frogs = galah.atlas_occurrences(
    taxa='Mixophyes balbus',
    bbox=bbox_midwestern,
    fields=["basic","generalisationInMetres"]
)
frogs
```

```{python}
#| echo: false
#| eval: true
import galah
import shapely
galah.galah_config(email="amanda.buyan@csiro.au")
bbox_midwestern = shapely.box(148.5, -33.6, 151.1, -31.6)
frogs = galah.atlas_occurrences(
    taxa='Mixophyes balbus',
    bbox=bbox_midwestern,
    fields=["basic","generalisationInMetres"]
)
frogs
```

### How buffer size affects species detection

Let's consider how different buffer sizes impact our ability to detect sensitive species.  Below, we've created six buffers of increasing size around Mid-Western, with a radius of 10km drawn around each unique point representing the stuttering frog. This isn't a perfect representation of obfuscation---the true location could be anywhere inside 10 km, not directly in the middle of each circle---but it gives an idea. The stuttering frog observations are *just* outside of our area; without a buffer this frog species would go undetected, but with a 30km buffer we would detect several observations. Which should we choose?

```{python}
#| warning: false
#| message: false
#| code-fold: true
#| eval: true
# drop duplicates and NAs
frogs_set = frogs.drop_duplicates(subset=['decimalLatitude','decimalLongitude']).dropna().reset_index(drop=True)

# convert to GeoDataFrame
frogs_set_gdf = gpd.GeoDataFrame(
    frogs_set, 
    geometry=gpd.points_from_xy(frogs_set.decimalLongitude,frogs_set.decimalLatitude), 
    crs="EPSG:4326"
)

# Reproject to CRS that uses metres to add buffer
frogs_set_gdf_metres = frogs_set_gdf.to_crs(3577)

# add a buffer column to the same dataframe
frogs_set_gdf_metres['buffer'] = None
for i,row in frogs_set_gdf_metres.iterrows():
    frogs_set_gdf_metres.loc[i,'buffer'] = row["geometry"].buffer(frogs_set_gdf_metres.loc[i,'generalisationInMetres'])

# replace `geometry` column with buffered points
del(frogs_set_gdf_metres['geometry'])
frogs_set_gdf_metres = frogs_set_gdf_metres.rename(columns={'buffer': 'geometry'})

# define that buffered points are in CRS 3577, then convert back to CRS 4326
frogs_set_gdf_metres = frogs_set_gdf_metres.set_crs(3577)
frogs_set_gdf_degrees = frogs_set_gdf_metres.to_crs(4326)

# start plots
fig,ax = plt.subplots(2,3,figsize=(15,10))
extra = 0

# initialise buffer data for visualisation
buffer_shapes = {}
buffer_lengths = {"5km": 5000, "10km": 10000,"15km": 15000,"20km": 20000,"25km": 25000,"30km": 30000}
buffer_distances = list(buffer_lengths.keys())

# get shapefile into Australian Albers CRS
midwestern_metres = midwestern.to_crs(3577)

# loop over each buffer length to create the buffer
# then, convert it back to degrees for conformance with the ALA CRS and unify any overlapping shapes
for length in buffer_lengths:
  buffer = midwestern_metres['geometry'].buffer(buffer_lengths[length])
  gdf_buffers_degrees = buffer.to_crs(4326)
  union_buffers_degrees = shapely.unary_union(gdf_buffers_degrees)
  buffer_shapes[length] = union_buffers_degrees

# loop over all axes for ease of plotting
for i in range(len(ax)):
    for j in range(len(ax[i])):

        # plot frogs as circles on map for reference
        a = frogs_set_gdf_degrees.plot(
            ax=ax[i][j],facecolor='#d4af37',alpha=0.5,linewidth=2.0, edgecolor='#d4af37',label='label'
        ) 

        # if this is the first subplot, there is no buffer, so you only draw the original shape and species counts
        if i == 0 and j == 0:

            # there is no buffer; plot the original shape file
            a = ax[i][j].set_title("No Buffer",fontsize=14)
            midwestern.plot(ax=ax[i][j],edgecolor = "#292C26", linewidth = 2.0, facecolor = "None")

            # get count of frogs in midwestern
            points = [(x,y) for x,y in zip(frogs_set_gdf_degrees["decimalLongitude"],frogs_set_gdf_degrees["decimalLatitude"]) if shapely.contains_xy(midwestern['geometry'][74],x,y)]
            count = len(points)
            
            a = ax[i][j].text(150.2,-31.85,'Count={}'.format(count),fontsize=12,color='#6E260E')

        # else, draw the buffer around the original shape and include species counts
        else:

            # get buffer 
            buffer = buffer_distances[i+j+extra-1]
            
            # set title and plot original shape
            a = ax[i][j].set_title("{} Buffer".format(buffer),fontsize=14)
            midwestern.plot(ax=ax[i][j],edgecolor = "#292C26", linewidth = 2.0, facecolor = "None", alpha = 1)

            # get raw number of sensitive species, drop duplicates and records without lat/long
            points = [(x,y) for x,y in zip(frogs_set_gdf_degrees["decimalLongitude"],frogs_set_gdf_degrees["decimalLatitude"]) if shapely.contains_xy(buffer_shapes[buffer],x,y)]
            count = len(points)
            
            # add number of counts to graph for reference
            a = ax[i][j].text(150.2,-31.85,'Count={}'.format(count),fontsize=12,color='#6E260E')
            
            # draw buffer on plot
            a = ax[i][j].plot(*buffer_shapes[buffer].exterior.xy,c='#358BA5',lw=2.0,label=buffer)
                
        # change limits of graph and set whitespace for better looking plot
        a = ax[i][j].set_ylim([-33.75,-31.7])
        a = ax[i][j].set_xlim([148.7,150.8])
        a = plt.setp(ax[i][j].get_xticklabels(), visible=False)
        a = plt.setp(ax[i][j].get_xticklines(), visible=False)
        a = plt.setp(ax[i][j].get_yticklabels(), visible=False)
        a = plt.setp(ax[i][j].get_yticklines(), visible=False)
        a = ax[i][j].set_aspect('equal')
        a = plt.subplots_adjust(wspace=0, hspace=0.15)

    # add offset to ensure that we get subplots on both lines of the overall plot
    extra += 3

plt.show();
```

Given the size of our area of interest, we'd likely choose a buffer between 5-15km. 

Although a larger buffer of 25-30km captures more species records, there is a risk that our buffer also captures too many species --- more than are realistically interacting with our area. When we draw our buffer, considering other factors like topography, river systems, and nutrient gradients might help us determine how big our buffer should practically be.

# Summary of EPBC Act Threatened Species in Midwestern With/Without a Buffer

Now that we have considered how adding buffers to an area might affect sensitive or threatened species, we can download data for this region and compare how many threatened species we detect with and without a 10km buffer.  First, we are going to draw a 10km buffer around the Midwestern LGA, and then draw a bounding box around this buffer.  We will then query by this bounding box, as it is more efficient to query in `galah-python` using a bounding box.

```{python}
#| echo: true
#| eval: false
# make a 15km buffer
buffer = midwestern_metres['geometry'].buffer(10000)
gdf_buffers_degrees = buffer.to_crs(4326)
buffer_10km = shapely.unary_union(gdf_buffers_degrees)

# get bounding box around buffer for efficient querying
bds = buffer_10km.bounds
bbox_midwestern = shapely.box(bds[0],bds[1],bds[2],bds[3])

# get all species within the bounding box from the ALA
galah.galah_config(email='<your-email@example.com>')
species = galah.atlas_occurrences(
    bbox=bbox_midwestern
)
```

```{python}
#| echo: false
#| eval: true
buffer = midwestern_metres['geometry'].buffer(10000)
gdf_buffers_degrees = buffer.to_crs(4326)
buffer_10km = shapely.unary_union(gdf_buffers_degrees)

# get bounding box around buffer for efficient querying
bds = buffer_10km.bounds
bbox_midwestern = shapely.box(bds[0],bds[1],bds[2],bds[3])

# get all species within the bounding box from the ALA
galah.galah_config(email='amanda.buyan@csiro.au')
species = galah.atlas_occurrences(
    bbox=bbox_midwestern
)
```

We can see that that is a lot of occurrences seen in the area!  Since we are only interested in those mentioned in the EPBC Act, we will now filter out species that don't have a conservation status, as well as add statuses, using the `merge` function in `pandas`.  We will also be using a new feature of `show_values()`, called `all_fields`, which now allows users to download a full species list, including the status of the species. We will then determine which species are in Midwestern and the buffered region using `geopandas`.

```{python}
# get all species on the epbc list, as well as their statuses
epbc_list = galah.show_values(field='dr656',lists=True,all_fields=True)

# merge the epbc list with your extant species list to get only threatened species
threat_species = pd.merge(species,epbc_list[['scientificName','status']],on='scientificName')

# get species into a GeoDataFrame for straightforward spatial filtering
threat_species_gdf = gpd.GeoDataFrame(
    threat_species, 
    geometry=gpd.points_from_xy(threat_species.decimalLongitude, threat_species.decimalLatitude), 
    crs="EPSG:4326"
)

# first, get number of species within midwestern
midwestern = midwestern.to_crs(4326)
species_mw = threat_species[threat_species_gdf.geometry.within(midwestern['geometry'][74])]

# get all species within a 15km buffer
threat_species_10km = threat_species[threat_species_gdf.geometry.within(buffer_10km)]
```

Now, we can collate and sort the number of unique species in each area by their status.

```{python}
# set dictionary for getting number of species sorted by status
num_species_mid = {x:0 for x in list(set(species_mw['status']))}

# loop over each key and get the number of unique species for each status in Midwestern
for key in num_species_mid:
    temp = species_mw[species_mw['status'] == key]
    num_species_mid[key] = len(list(set(temp['scientificName'])))

# sort the species from most to least
num_species_mid_sorted = dict(sorted(num_species_mid.items(), key=lambda item: item[1]))

# set dictionary for getting number of species sorted by status
num_species_buff = {x:0 for x in list(set(threat_species_10km['status']))}

# loop over each key and get the number of unique species for each status in buffered region
for key in num_species_buff:
    temp = threat_species_10km[threat_species_10km['status'] == key]
    num_species_buff[key] = len(list(set(temp['scientificName'])))

# sort the buffered species from most to least
num_species_buff_sorted = dict(sorted(num_species_buff.items(), key=lambda item: item[1]))
```

Finally, we can plot them side-by-side.  This will show: i) that the number of threatened species detected markedly increases when adding a buffer, and ii) adding a buffer includes other hotspots of threatened species that would otherwise have been missed had we just considered the Midwestern LGA.

```{python}
#| echo: true
#| eval: false
# import numpy for arange
import numpy as np

# create plot
fig, ax = plt.subplots(1,2,figsize=(14,7))

# bar chart 
h, n = 0.4, np.arange(len(num_species_mid_sorted.keys()))
ax[0].set_yticks(range(len(num_species_mid_sorted.keys())), labels=num_species_mid_sorted.keys())
ax[0].barh(n + h/2, num_species_mid_sorted.values(), height=h, color='#292C26', label='Midwestern')
ax[0].barh(n - h/2, num_species_buff_sorted.values(), height=w, color='#358BA5', label='Buffer')
ax[0].legend()
ax[0].set_xlabel('Number of Unique Species')
# ax[0].set_aspect(aspect=12)

# density map
ax[1].scatter(threat_species_10km['decimalLongitude'],threat_species_10km['decimalLatitude'], alpha=0.3, color='#d4af37')
ax[1].plot(*midwestern['geometry'][74].exterior.xy,c='#292C26',lw=2)
ax[1].plot(*buffer_10km.exterior.xy,c='#358BA5',lw=2)
plt.axis('off')
plt.suptitle('Threatened Species in Mid-Western and Surrounds', fontsize=24, y=0.93)
# ax[1].set_aspect(aspect='equal')
```

<!-- , anchor=(0,0.89) -->

```{python}
#| column: page
#| fig-align: center
#| out-width: 11in
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| out-extra: "style=margin-left:auto;margin-right:auto;"
#| lightbox: 
#|   group: final-plot
# import numpy for arange
import numpy as np

# create plot
fig, ax = plt.subplots(1,2,figsize=(14,7))

# bar chart 
h, n = 0.4, np.arange(len(num_species_mid_sorted.keys()))
a = ax[0].set_yticks(range(len(num_species_mid_sorted.keys())), labels=num_species_mid_sorted.keys())
a = ax[0].barh(n + h/2, num_species_mid_sorted.values(), height=h, color='#292C26', label='Midwestern')
a = ax[0].barh(n - h/2, num_species_buff_sorted.values(), height=h, color='#358BA5', label='Buffer')
a = ax[0].legend()
a = ax[0].set_xlabel('Number of Unique Species')
a = ax[0].set_aspect(aspect=12)

a = ax[1].scatter(threat_species_10km['decimalLongitude'],threat_species_10km['decimalLatitude'], alpha=0.3, color='#d4af37')
a = ax[1].plot(*midwestern['geometry'][74].exterior.xy,c='#292C26',lw=2)
a = ax[1].plot(*buffer_10km.exterior.xy,c='#358BA5',lw=2)
a = plt.axis('off')
a = plt.suptitle('Threatened Species in Mid-Western and Surrounds', fontsize=24, y=0.93)
a = ax[1].set_aspect(aspect='equal')
plt.show();
```

<!-- , anchor=(0,2.3) -->
<!-- , anchor=(0,0.89) -->
<!-- , anchor='C' -->

# Final thoughts

We hope this post has helped you understand how to draw buffers around a shape, as well as the importance of considering buffer size when determining sensitive/threatened species in an area. Ultimately, buffer size will depend on the question we are trying to answer, whether that's for research, monitoring, conservation or environmental impact assessment prior to development.

For other Python posts, check out [our beginnerâ€™s guide to map species observations](https://labs.ala.org.au/posts/2023-12-18_beginners-guide-make-a-map/) or see [how to cross reference a species list with a conservation list](https://labs.ala.org.au/posts/2024-02-12_species-lists/).

<details><summary style = "color: #E06E53;">Expand for session info</summary>

```{python}
#| echo: false
import math
import natsort
import pandas
import session_info

session_info.show()
```

</details>
