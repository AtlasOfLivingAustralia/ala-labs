---
title: "Add a buffer to a shapefile and account for generalised species locations"
description: |
  Knowing what species have been observed in a local area is a regular task for ecosystem management. Here we show how to add a buffer to a shapefile using {shapely} and {geopandas}. We then demonstrate how data that have been obfuscated (generalised to reduce their precision) may affect the buffer size required to more confidently capture threatened species in the area using {galah-python} and {matplotlib}.
authors:
  - name: "Amanda Buyan"
  - name: "Dax Kellie"
date: "2025-07-30"
title-block-banner: "#B8573E"
toc: true
toc-location: left
toc-depth: 2
categories:
  - Eukaryota
  - Animalia
  - Amphibia
  - Summaries
  - Python
image: obfuscate.png
freeze: true
engine: knitr
jupyter: python3
draft: true
editor_options: 
  chunk_output_type: console
---

```{r}
#| include: false
library(htmltools)
```

<!-- remove metadata section -->
<style>
  #title-block-header.quarto-title-block.default .quarto-title-meta {
      display: none;
  }
</style>



<!-- Author card -->

:::{.author-card}
:::{.author-card-text}

#### Author
[Amanda Buyan](https://labs.ala.org.au/people/Buyan_Amanda/index.html)  
[Dax Kellie](https://labs.ala.org.au/people/Kellie_Dax/index.html)  

#### Date
7 July 2025

:::

:::{.author-card-image}
```{r, out.width='120px', out.extra='style="clip-path: circle();"', echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/amanda.jpg")
```
:::

:::{.author-card-image}
```{r, out.width='120px', out.extra='style="clip-path: circle();"', echo=FALSE}
knitr::include_graphics("https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/dax.jpg")
```
:::

:::

<!------------------------ Post starts here ------------------------>

Ecological data is often used to understand what species are found in a given location, especially for conservation monitoring and environmental impact assessment prior to land development. A common method for this task is to use a **buffer**, an outward boundary around a given area location. Adding a buffer helps to capture all the species in an area, including those that have been observed just outside the area and probably live there, too.

Choosing a buffer size, however, can be tougher than it seems. Individual organisms move, either over the course of a day or an entire season (e.g. migration, perennial growth), so species' lifecycles and behaviours may determine the size of our final buffer. A more difficult challenge occurs when species are considered sensitive or endangered. These species' exact point locations are often obfuscated (aka their location is made less precise) to keep these species safe. This added imprecision will again affect our final decision on buffer size.

In this post, we'll show how to add a buffer around a shapefile with [{geopandas}](https://geopandas.org/en/stable/), [{shapely}](https://shapely.readthedocs.io/en/stable/) and [{matplotlib}](https://matplotlib.org/). Then we will use [{galah-python}](galah.ala.org.au/Python) to download data of Stuttering frogs (*Mixophyes balbus*) to demonstrate how the size of a buffer can affect the detection of sensitive species in an area.  Lastly, we will use [{scipy}](https://docs.scipy.org/doc/scipy/#) and [{matplotlib}](https://matplotlib.org/) to show the effect of buffers on detecting threatened species in an area.

# Draw a buffer

For this example, our area of interest is Mid-Western, a Local Government Area (LGA) in New South Wales. We'll first need to download a shapefile of our area, which we can get by downloading a [shapefile of all LGAs from the Australian Bureau of Statistics](https://www.abs.gov.au/statistics/standards/australian-statistical-geography-standard-asgs-edition-3/jul2021-jun2026/access-and-downloads/digital-boundary-files) and filtering to our area. Download the zip file of "Local Government Areas - 2024", then place the zip file in your local directory. We can then read in the shapefile and show what it looks like using {geopandas}.

::: aside

For those unfamiliar with Australian geography, the LGA of Mid-Western is located here:

```{r}
#| echo: false
#| eval: true
library(reticulate)
py_require(c("matplotlib"))
py_require(c("geopandas"))
py_require(c("galah-python"))
py_require(c("numpy"))
py_require(c("natsort"))
py_require(c("session_info"))
```

```{python}
#| echo: false
#| eval: true
import matplotlib
import geopandas as gpd

import matplotlib.pyplot as plt
lgas = gpd.read_file("../data/LGA_2024_AUST_GDA2020.zip")
ax = lgas[lgas['STE_NAME21'] == 'New South Wales'].plot(edgecolor="#292C26", linewidth=0.5, facecolor="white")
a = lgas[lgas['LGA_NAME24'] == 'Mid-Western'].plot(ax=ax, facecolor='#F26649')
a = ax.axis('off')
plt.show()
```

:::


```{python}
#| echo: true
#| eval: false
import geopandas as gpd
import shapely
from shapely.geometry import Polygon
lgas = gpd.read_file("LGA_2024_AUST_GDA2020.zip")
lgas.head()
```

```{python}
#| echo: false
#| eval: true
import geopandas as gpd
import pandas as pd
import shapely
from shapely.geometry import Polygon
pd.set_option('display.max_columns', None)
pd.set_option('expand_frame_repr', False)
lgas = gpd.read_file("../data/LGA_2024_AUST_GDA2020.zip")
lgas.head()
```

Then we'll filter to Mid-Western.

```{python}
midwestern = lgas[lgas['LGA_NAME24'] == 'Mid-Western']
```


Now, we will create a 5 km buffer around Mid-Western, as we are looking at a relatively small area. To do this, we'll need to convert the shapefiles between different Coordinate Reference Systems (CRS)[^crs] to allow us to draw our buffer. 

First, we'll reproject our polygon `midwestern` to a CRS measured in metres, like Australian Albers (`EPSG:3577`). Then we can create a buffer in metres around `midwestern`. Finally, we'll reproject `midwestern` match the CRS of the data we intend to use, `EPSG:4326`[^ala-crs], and unify any intersecting shapes.

[^crs]: Check out [this section of a previous ALA Labs post](https://labs.ala.org.au/posts/2023-12-18_beginners-guide-make-a-map/#make-a-map) for a more complete explanation of what a CRS is.

[^ala-crs]: ALA data is projected using [CRS EPSG:4326](https://epsg.io/4326) (the same one used by Google Earth).

```{python}
# reproject to Australian Albers CRS
midwestern_metres = midwestern.to_crs(3577)

# create buffer, reproject, unify any overlapping shapes
buffer_5km = midwestern_metres['geometry'].buffer(5000)
buffer_5km_degrees = buffer_5km.to_crs(4326)
union_buffer_5km_degrees = shapely.unary_union(buffer_5km_degrees)
```

Let's plot our 5km buffer on a map.  

```{python}
#| echo: true
#| eval: false
# import matplotlib for plotting
import matplotlib.pyplot as plt

# set initial shapefile as axis
ax = midwestern.plot(edgecolor="#292C26", linewidth = 2.0, facecolor="white")

# plot buffer on same axis as original shapefile
plt.plot(*union_buffer_5km_degrees.exterior.xy, c='#358BA5', lw=2.0, label=length)
ax.axis('off') # remove axis to make plot look prettier
```

```{python}
#| echo: false
#| eval: true
import matplotlib.pyplot as plt

# set initial shapefile as axis
ax = midwestern.plot(edgecolor="#292C26", linewidth=2.0, facecolor="white")

# plot buffer on same axis as original shapefile
a = plt.plot(*union_buffer_5km_degrees.exterior.xy, c='#358BA5', lw=2.0, label='5km')
a = ax.axis('off') # remove axis to make plot look prettier
plt.show();
```

Now that we've drawn our buffer around the Mid-Western LGA, let's discuss how data obfuscation of sensitive species data might impact our decision about buffer size.

# Obfuscation and why it's important for sensitive species

When we talk about a record being **obfuscated**, we mean that the coordinate location of this record has been obscured either by *generalisation* or *randomisation*.  The [Atlas of Living Australia](ala.org.au) *generalises* coordinate locations by reducing the number of decimals in the record's lat/lon coordinates, lowering the point's precision. This figure below illustrates this; as the decimal points are removed, the data appears more 'grid-like' as the data loses resolution.  

```{python}
#| echo: true
#| eval: false
#| code-fold: true
# import plotting and animation packages
import matplotlib.animation as animation
import math
import pandas as pd
from IPython.display import display, Javascript
# use below if you are running in jupyter notebook
%matplotlib ipympl

# create dataframe of points
points = pd.DataFrame({
    'orig_long': [149.9153,149.9181,149.9204,149.9233,149.9101,149.9258,149.9121,149.9163,
                  149.9295,149.9175,149.9287,149.9236,149.9109,149.9091,149.9113,149.9211,
                  149.9073,149.9087,149.9236,149.9241,149.9289], 
    'orig_lat': [-33.3874,-33.3509,-33.3694,-33.3479,-33.3341,-33.3789,-33.3475,-33.3748,
                 -33.3554,-33.3723,-33.3808,-33.3798,-33.3475,-33.3607,-33.3521,-33.3871,
                 -33.3541,-33.3633,-33.3799,-33.3833,-33.3423]
})

# Round to 3 and 2 decimal places
for i in range(3,1,-1):
    factor = 10 ** i
    points['round{}_long'.format(i)] = points['orig_long'].apply(lambda x: math.floor(x * factor) / factor)
    points['round{}_lat'.format(i)] = points['orig_lat'].apply(lambda x: math.ceil(x * factor) / factor)

# create initial figure
fig,ax = plt.subplots(1,2)

# create dictionary for columns - will be easier to use in update function
column_labels = {0: ['orig_long', 'orig_lat'], 
                 1: ['round3_long', 'round3_lat'], 
                 2: ['round2_long', 'round2_lat']}

artists = []
for i in range(3):
    
    ax[0].axis('off')
    table = ax[0].table(cellText=points[column_labels[i]].values,colLabels=['Latitude','Longitude'],loc='center')

    ax[1].set_xticks(list(np.arange(149.90,149.93,0.01)))
    ax[1].set_yticks(list(np.arange(-33.39,-33.32,0.01)))
    ax[1].set_xticklabels([])  # Remove x-axis ticks
    ax[1].set_yticklabels([])  # Remove y-axis ticks
    ax[1].tick_params(which='major', bottom=False, left=False)
    ax[1].grid(True)
    scatter = ax[1].scatter(points[column_labels[i][0]],points[column_labels[i][1]],c='purple',alpha=0.5)
    artists.append([table,scatter])

ani = animation.ArtistAnimation(fig=fig, artists=artists, interval=1000, repeat=True)
ani.save('obfuscation.gif')
plt.show()
```

![](obfuscation.gif)

Generalisation of species records is performed in accordance with the state or territory the species is located, typically rounded to distances of 1km, 10km or 50km from a species' original location[^witheld]. 

[^witheld]: Some records, if the species is very sensitive, may be witheld altogether.

::: aside
Alternatively, iNaturalist *randomises* their coordinate locations at a 30km resolution prior to sharing data with the Atlas of Living Australia.
:::

How this affects our ability to know the true location of a species in an area is illustrated in the diagram below. The *true* location of the point is nearby[^nearby], but the process of generalisation has moved the point by snapping it to a new location dependent on the a distance of generalisation. Whether the point snaps up or down will depend on which direction the point was rounded[^snapping]. What this means is that it's possible that a given data point falls within any of the following three scenarios:

1.  A point falls inside a specified area when its true location is outside the area (left), 
2.  A point falls inside a specified area when its true location is inside the area (middle) 
3.  A point falls outside a specified area when its true location is inside the area (right) 

[^nearby]: *How* nearby is relative to the degree of generalisation, so what we mean by "near" is relative

[^snapping]: This directional grid snapping can even cause data points to appear in the ocean despite the true location being on land.

```{python}
#| echo: false
#| eval: true
#| fig-caption: "Three theoretical but possible scenarios where obfuscation of the original point (in green) results in the obscured location ending up (1) inside an area, (2) in the buffered area, or (3) outside the area and the buffered area."
import numpy as np
from shapely.geometry import Point

fig,ax = plt.subplots(1,3)

orig_points = {0: [150.2,-33], 1: [149.8,-32.45], 2: [149.7,-32.2]}
obf_points = {0: [149.9,-32.7], 1: [149.5,-32.3], 2: [149.5,-31.9]}
titles = {0: '1', 1: '2', 2: '3'}

for i in range(len(ax)):

    # plot initial shape and point
    a = midwestern.plot(ax=ax[i], edgecolor="#292C26", linewidth=2.0, facecolor="None", alpha=1, figsize=(12,6))

    # add demonstration points
    a = ax[i].plot(orig_points[i][0], orig_points[i][1], 'o', c='#5A2A57', label='original')
    a = ax[i].plot(obf_points[i][0], obf_points[i][1], 'o', c='#d4af37', label='generalised')
    
    # set axis limits and remove numbers for better visualisation
    a = ax[i].set_title(titles[i])
    a = ax[i].set_ylim([-33.5,-31.8]) # was -32
    a = ax[i].set_xlim([148.7,150.8])
    a = ax[i].set_xticks(list(np.arange(148.7,150.8,0.4)))
    a = ax[i].set_yticks(list(np.arange(-33.5,-31.8,0.4)))
    a = ax[i].set_xticklabels([])  # Remove x-axis ticks
    a = ax[i].set_yticklabels([])  # Remove y-axis ticks
    a = ax[i].tick_params(which='major', bottom=False, left=False)
    a = ax[i].set_axisbelow(True)

    # add grid to show obfuscation
    a = ax[i].grid(True)

handles, labels = ax[0].get_legend_handles_labels()
a = fig.legend(handles, labels, loc=(0.4,0.15))
plt.show()
```

Thanks to generalisation, points can appear in places that they actually aren't! When dealing with many species' point locations, this can make it difficult to keep track of which of these three scenarios might affect each generalised species record.

The main takeaway is that obfuscation makes it harder to know that you are accurately capturing all the species in a defined area. In ecological assessment, it's generally better to capture more rather than less because species interact with their broader ecosystems (outside of our human-defined boundaries). Therefore, the goal *we* are trying to achieve by using a buffer is to realistically estimate how many species are influenced by the health of our defined area, not just what has been observed within a pre-defined boundary.

::: {.callout-note collapse="true" title="Uncertainty"} 

Things get even more complicated when you consider that the location of every observation has a degree of uncertainty around it. This information, held in `coordinateUncertaintyInMetres`, adds yet another layer of complexity to knowing the *true* location of a given species observation. For many species, this uncertainty reflects the opportunistic nature of an observation (e.g., an organism was observed at a distance before moving somewhere else). For others, this is due to inaccurate measurement or documentation. Whatever the reason, considering uncertainty is another important step---and difficult challenge---for accurate species lists.

:::

# Example: The stuttering frog

Let's see an example of how buffer size affects our ability to detect sensitive species in our area of interest.

The stuttering frog (*Mixophyes balbus*) is a large Australian species of frog that inhabits temperate, sub-tropical rainforest and wet sclerophyll forest.  They have a brown back and a yellow underbelly, with a light blue iris that diffuses into gold above the pupil.  Their call is a "kook kook kook kra-a-ak kruk kruk", which lasts 1-2 seconds[^wikipedia].

[^wikipedia]: [https://en.wikipedia.org/wiki/Stuttering_frog](https://en.wikipedia.org/wiki/Stuttering_frog)

::: {layout-ncol="3" style="margin-left: auto; margin-right: auto;"}
<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/3/7/1/1/67afd228-c7ce-4cae-94bf-fcd76baf1173/original" class="rounded"/></img>

<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/a/6/9/8/5a8b9d78-cd00-4d64-b8c3-91521a3a896a/original" class="rounded"/></img>

<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/5/9/e/7/0c871c80-dae1-4e13-9e21-b311ca0e7e95/original" class="rounded"/></img>
:::

::: figure-caption
Left: [*Mixophyes balbus* (Darren Fielder CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/e20b3c82-d995-4ad4-bed0-cd8769ec5b1f), 
Middle: [*Mixophyes balbus* (liznoble CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/62bf735b-6c70-410f-aea3-006d12fb011f), 
Right: [*Mixophyes balbus* (lachlan_harriman CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/b37f6a21-2841-439a-9b25-e9073a3fedb6)
:::

### Download data

Let's download occurrence records of stuttering frogs in a bounding box that encompasses an area slightly larger than the Mid-Western LGA[^bbox]. We will also include a column with the distance each record's location has been obfuscated, `generalisationInMetres`.

[^bbox]: Downloading all occurrence records using a bounding box *then* filtering the records to fit a shapefile can be a quicker way to subset records (rather than waiting for the API to process a more complex shapefile polygon shape). You can find a more in-depth article on this [here](https://galah.ala.org.au/Python/galah_user_guide/Spatial_Filtering.html#spatial-filtering).


```{python}
#| echo: true
#| eval: false
import galah
import shapely
galah.galah_config(email="<your-email-address>")
#                              xmin,  ymin,  xmax,  ymax
bbox_midwestern = shapely.box(148.5, -33.6, 151.1, -31.6)
frogs = galah.atlas_occurrences(
    taxa='Mixophyes balbus',
    bbox=bbox_midwestern,
    fields=["basic","generalisationInMetres"]
)
frogs.head(10) # first 10 rows
```

```{python frogs-download}
#| echo: false
#| eval: true
import galah
import shapely
galah.galah_config(email="amanda.buyan@csiro.au")
bbox_midwestern = shapely.box(148.5, -33.6, 151.1, -31.6)
frogs = galah.atlas_occurrences(
    taxa='Mixophyes balbus',
    bbox=bbox_midwestern,
    fields=["basic","generalisationInMetres"]
)
frogs.head(10) # first 10 rows
```

A good first step is to view the degree of generalisation applied to our stuttering frog data. Here we can see that all records in our query have been generalised to 10 km.

<!-- We need to mention this as a first step -->

```{python}
frogs['generalisationInMetres'].value_counts()
```

### How buffer size affects species detection

Let's consider how different buffer sizes impact our ability to detect sensitive species.  Below, we've created six buffers of increasing size around Mid-Western, then overlayed a grid of 10 km blocks over our map. You'll notice the points have snapped to a corner in our grid. Observations of stuttering frog observations are *just* outside of Mid-Western; without a buffer this frog species would go undetected, but with a 30km buffer we would detect multiple observations. Which should we choose?

```{python main-example}
#| warning: false
#| message: false
#| code-fold: true
#| eval: true
# drop duplicates and NAs
frogs_set = frogs.drop_duplicates(subset=['decimalLatitude','decimalLongitude']).dropna().reset_index(drop=True)

# convert to GeoDataFrame
frogs_set_gdf = gpd.GeoDataFrame(
    frogs_set, 
    geometry=gpd.points_from_xy(frogs_set.decimalLongitude,frogs_set.decimalLatitude), 
    crs="EPSG:4326"
)

# start plots
fig,ax = plt.subplots(2,3,figsize=(15,10))
extra = 0

# initialise buffer data for visualisation
buffer_shapes = {}
buffer_lengths = {"5km": 5000, "10km": 10000,"15km": 15000,"20km": 20000,"25km": 25000,"30km": 30000}
buffer_distances = list(buffer_lengths.keys())

# get shapefile into Australian Albers CRS
midwestern_metres = midwestern.to_crs(3577)

# loop over each buffer length to create the buffer
# then, convert it back to degrees for conformance with the ALA CRS and unify any overlapping shapes
for length in buffer_lengths:
  buffer = midwestern_metres['geometry'].buffer(buffer_lengths[length])
  gdf_buffers_degrees = buffer.to_crs(4326)
  union_buffers_degrees = shapely.unary_union(gdf_buffers_degrees)
  buffer_shapes[length] = union_buffers_degrees

# loop over all axes for ease of plotting
for i in range(len(ax)):
    for j in range(len(ax[i])):

        # if this is the first subplot, there is no buffer, so you only draw the original shape and species counts
        if i == 0 and j == 0:

            # there is no buffer; plot the original shape file
            a = ax[i][j].set_title("No Buffer",fontsize=14)
            midwestern.plot(ax=ax[i][j],edgecolor = "#292C26", linewidth = 2.0, facecolor = "None")

            # plot frogs as circles on map for reference
            a = frogs_set_gdf.plot(
                ax=ax[i][j],facecolor='#d4af37',edgecolor='#d4af37',label='label'
            ) 
    
            # get count of frogs in midwestern
            points = [(x,y) for x,y in zip(frogs_set_gdf["decimalLongitude"],frogs_set_gdf["decimalLatitude"]) if shapely.contains_xy(midwestern['geometry'][74],x,y)]
            count = len(points)
            
            # add number of counts to graph for reference
            a = ax[i][j].text(150.2,-31.85,'Count={}'.format(count),fontsize=12,color='#6E260E')

            # draw grid on plot
            ax[i][j].set_xticks(list(np.arange(148.7,150.8,0.1)))
            ax[i][j].set_yticks(list(np.arange(-33.7,-31.7,0.1)))
            ax[i][j].set_xticklabels([])  # Remove x-axis ticks
            ax[i][j].set_yticklabels([])  # Remove y-axis ticks
            ax[i][j].tick_params(which='major', bottom=False, left=False)
            ax[i][j].set_axisbelow(True)
            ax[i][j].grid()

        # else, draw the buffer around the original shape and include species counts
        else:

            # get buffer 
            buffer = buffer_distances[i+j+extra-1]
            
            # draw buffer on plot
            a = ax[i][j].plot(*buffer_shapes[buffer].exterior.xy,c='#358BA5',lw=2.0,label=buffer)
            
            # set title and plot original shape
            a = ax[i][j].set_title("{} Buffer".format(buffer),fontsize=14)
            midwestern.plot(ax=ax[i][j],edgecolor = "#292C26", linewidth = 2.0, facecolor = "None", alpha = 1)

            # plot frogs as circles on map for reference
            a = frogs_set_gdf.plot(
                ax=ax[i][j],facecolor='#d4af37',edgecolor='#d4af37',label='label'
            ) 
    
            # get raw number of sensitive species, drop duplicates and records without lat/long
            points = [(x,y) for x,y in zip(frogs_set_gdf["decimalLongitude"],frogs_set_gdf["decimalLatitude"]) if shapely.contains_xy(buffer_shapes[buffer],x,y)]
            count = len(points)
            
            # add number of counts to graph for reference
            a = ax[i][j].text(150.2,-31.85,'Count={}'.format(count),fontsize=12,color='#6E260E')
            
            # draw grid on plot
            ax[i][j].set_xticks(list(np.arange(148.7,150.8,0.1)))
            ax[i][j].set_yticks(list(np.arange(-33.7,-31.7,0.1))) # -33.75
            ax[i][j].set_xticklabels([])  # Remove x-axis ticks
            ax[i][j].set_yticklabels([])  # Remove y-axis ticks
            ax[i][j].tick_params(which='major', bottom=False, left=False)
            ax[i][j].set_axisbelow(True)
            ax[i][j].grid()

        # change limits of graph and set whitespace for better looking plot
        a = ax[i][j].set_ylim([-33.75,-31.7])
        a = ax[i][j].set_xlim([148.7,150.8])
        a = ax[i][j].set_aspect('equal')
        a = plt.subplots_adjust(wspace=0, hspace=0.15)

    # add offset to ensure that we get subplots on both lines of the overall plot
    extra += 3

plt.show();
```

If we are interested in just this species, the best thing to do is to consider the distance of generalisation applied to these data. As we saw in the `generalisationInMetres` column, stuttering frog records are generalised to a distance of 10 km, so a 10 km buffer is probably the best option.

If we are interested in more than one species and there are multiple degrees of generalisation (2 km, 5 km, 10 km, 50 km), then we might need to consider the goal of our species search. Using a large buffer risks capturing too many species---more than are realistically interacting with our area. In this situation, we might need to consider other factors like topography, river systems, and nutrient gradients to help us determine how big our buffer should practically be.

# Threatened species in area

As a final step, let's download and visualise where threatened species have been observed in our buffered area on a map. To start, let's download occurrence records in our area with {galah-python}, with a 10 km buffer around our area (which seems reasonable given our example above). To download records, we'll once again create a buffer around Mid-Western, then use the bounding box around this area to download occurrence records using `atlas_occurrences()`[^bbox]. We'll also add the `generalisationInMetres` column to our query again.

[^bbox]: It's faster to use a bounding box than polygon shape to download records - a box has fewer points than a complicated polygon shape, making for a far simpler query to process!

```{python}
#| echo: true
#| eval: false
# make a 10km buffer
buffer = midwestern_metres["geometry"].buffer(10000)
gdf_buffers_degrees = buffer.to_crs(4326)
buffer_10km = shapely.unary_union(gdf_buffers_degrees)

# get bounding box around buffer for efficient querying
bds = buffer_10km.bounds
bbox_midwestern = shapely.box(bds[0], bds[1], bds[2], bds[3])

# get all occurrence records within bounding box from the ALA
galah.galah_config(email="<your-email@example.com>")
occs = galah.atlas_occurrences(
    bbox=bbox_midwestern, 
    fields=["basic","generalisationInMetres"]
)

occs.head(10)  # first 10 rows
```

```{python}
#| echo: false
#| eval: true
buffer = midwestern_metres["geometry"].buffer(10000)
gdf_buffers_degrees = buffer.to_crs(4326)
buffer_10km = shapely.unary_union(gdf_buffers_degrees)

# get bounding box around buffer for efficient querying
bds = buffer_10km.bounds
bbox_midwestern = shapely.box(bds[0], bds[1], bds[2], bds[3])

# get all occurrence records within bounding box from the ALA
galah.galah_config(email="amanda.buyan@csiro.au")
occs = galah.atlas_occurrences(
    bbox=bbox_midwestern,
    fields=["basic","generalisationInMetres"]
)

occs.head(10)  # first 10 rows
```

Let's once again check the `generalisationInMetres` of our data as a starting point. Our results show that records in our area have been generalised to 1 km and 10 km distances.

<!-- Same as earlier, we just need to make the point to check the data generalisations of our data first -->

```{python}
occs['generalisationInMetres'].value_counts()
```

Next we'll use `show_values()` to download a list of species on the EPBC Act Threatened species list (see the tab below for more information on how to find species list IDs). By adding `all_fields=True`, we can append all original columns of the list, which for conservation lists like this includes status information.

::: {.callout-tip collapse="true" title="How to find species list IDs"}

Search for species lists available in galah using `search_all(lists=True)`. The `species_list_uid` for the EPBC Act Threatened Species list is `dr656`. We can use this information to filter downloads.

```{python}
galah.search_all(lists="epbc act")
```

:::

```{python}
# get all species on epbc list + status info
epbc_list = galah.show_values(field='dr656',lists=True,all_fields=True)
epbc_list.head(10)
```

By merging our species list to our occurrence records `occs`, our data will filter to only occurrence records of species on the EPBC list.

```{python}
# merge epbc list with occurrences
threatened_species = pd.merge(occs,epbc_list[['scientificName','status']],on='scientificName')
threatened_species.head(10)
```

Finally, we'll filter our observations to only those within the buffered area around Mid-Western. 

```{python}
# convert to GeoDataFrame
threatened_species_gdf = gpd.GeoDataFrame(
    threatened_species, 
    geometry=gpd.points_from_xy(threatened_species.decimalLongitude, threatened_species.decimalLatitude), 
    crs="EPSG:4326"
)

# filter to species within our 10km buffer
threatened_species_10km = threatened_species[threatened_species_gdf.geometry.within(buffer_10km)]
```

We can now plot our observations on a map using {matplotlib}, adjusting the opacity of our points (`alpha`) so we can see areas with many overlapping points more easily. To understand just how many additional species our 10 km buffer captures, we've added an additional bar plot comparing the number of species in Mid-Western *vs* Mid-Western + our 10 km buffer. Notice that the number of threatened species detected markedly increases with the addition of our buffer because we captured a few noticeable hotspots of threatened species observations near the edge of the Mid-Western border.

```{python}
#| echo: true
#| eval: false
# map
fig, ax = plt.subplots()
ax.scatter(threatened_species_10km['decimalLongitude'],threatened_species_10km['decimalLatitude'], alpha=0.3, color='#5A2A57')
ax.plot(*midwestern['geometry'][74].exterior.xy,c='#292C26',lw=2)
ax.plot(*buffer_10km.exterior.xy,c='#358BA5',lw=2)
plt.axis('off')
ax.set_aspect(aspect='equal')
plt.show();
```

```{python}
#| echo: true
#| eval: false
#| code-fold: true
#| code-summary: Code to make bar plot
# import numpy for arange
import numpy as np

# get number of species within midwestern
midwestern = midwestern.to_crs(4326)
species_mw = threatened_species[threatened_species_gdf.geometry.within(midwestern['geometry'][74])]

# set dictionary for get number of species in midwestern, sorted by status
num_species_mid = {x:0 for x in list(set(species_mw['status']))}

# loop over each key, get the number of unique species for each status in Midwestern
for key in num_species_mid:
    temp = species_mw[species_mw['status'] == key]
    num_species_mid[key] = len(list(set(temp['scientificName'])))

# sort species from most to least
num_species_mid_sorted = dict(sorted(num_species_mid.items(), key=lambda item: item[1]))

# set dictionary to get number of species in buffer, sorted by status
num_species_buff = {x:0 for x in list(set(threatened_species_10km['status']))}

# loop over each key, get the number of unique species for each status in buffered region
for key in num_species_buff:
    temp = threatened_species_10km[threatened_species_10km['status'] == key]
    num_species_buff[key] = len(list(set(temp['scientificName'])))

# sort buffered species from most to least
num_species_buff_sorted = dict(sorted(num_species_buff.items(), key=lambda item: item[1]))

# create plot
fig, ax = plt.subplots()
h, n = 0.4, np.arange(len(num_species_mid_sorted.keys()))
bar = ax.barh(n + h/2, num_species_mid_sorted.values(), height=h, color='#292C26', label='Mid-Western')

# set ticks
bar = ax.set_yticks(range(len(num_species_mid_sorted.keys())), labels=num_species_mid_sorted.keys())
bar = ax.barh(n - h/2, num_species_buff_sorted.values(), height=h, color='#358BA5', label='Mid-Western + buffer')
bar = ax.legend()
bar = ax.set_xlabel('Number of Unique Species')
bar = ax.set_aspect(aspect=12)
```


```{python}
#| echo: false
#| column: page
#| fig-align: center
#| out-width: 11in
#| layout-nrow: 1
#| layout-ncol: 2
#| message: false
#| warning: false
#| out-extra: "style=margin-left:auto;margin-right:auto;"
#| lightbox: 
#|   group: final-plot
#| fig-subcap:
#|   - "Number of threatened species observed in Mid-Western only vs Mid-Western + a buffer of 10 km"
#|   - "Map of observations of threatened species within the buffered area around Mid-Western"

# import numpy for arange
import numpy as np

# get number of species within midwestern
midwestern = midwestern.to_crs(4326)
species_mw = threatened_species[threatened_species_gdf.geometry.within(midwestern['geometry'][74])]

# set dictionary for get number of species in midwestern, sorted by status
num_species_mid = {x:0 for x in list(set(species_mw['status']))}

# loop over each key, get the number of unique species for each status in midwestern
for key in num_species_mid:
    temp = species_mw[species_mw['status'] == key]
    num_species_mid[key] = len(list(set(temp['scientificName'])))

# sort species from most to least
num_species_mid_sorted = dict(sorted(num_species_mid.items(), key=lambda item: item[1]))

# set dictionary to get number of species in buffer, sorted by status
num_species_buff = {x:0 for x in list(set(threatened_species_10km['status']))}

# loop over each key, get the number of unique species for each status in buffered region
for key in num_species_buff:
    temp = threatened_species_10km[threatened_species_10km['status'] == key]
    num_species_buff[key] = len(list(set(temp['scientificName'])))

# sort buffered species from most to least
num_species_buff_sorted = dict(sorted(num_species_buff.items(), key=lambda item: item[1]))

# bar plot
fig, ax = plt.subplots(figsize=(11,8))
h, n = 0.4, np.arange(len(num_species_mid_sorted.keys()))
ax.barh(n + h/2, num_species_mid_sorted.values(), height=h, color='#292C26', label='Mid-Western')
# set ticks
ax.set_yticks(range(len(num_species_mid_sorted.keys())), labels=num_species_mid_sorted.keys())
ax.barh(n - h/2, num_species_buff_sorted.values(), height=h, color='#358BA5', label='Mid-Western + buffer')
ax.legend()
ax.set_xlabel('Number of Unique Species')
ax.set_aspect(aspect=12)
plt.show();

# map
fig, ax = plt.subplots()
a = ax.scatter(threatened_species_10km['decimalLongitude'],threatened_species_10km['decimalLatitude'], alpha=0.3, color='#6A5380')
a = ax.plot(*midwestern['geometry'][74].exterior.xy,c='#292C26',lw=2)
a = ax.plot(*buffer_10km.exterior.xy,c='#358BA5',lw=2)
a = plt.axis('off')
a = ax.set_aspect(aspect='equal')
plt.show();
```

::: {.callout-tip collapse="true" title="Is there an unexpected species your area?"}

In our example, record locations were generalised to 1 km or 10 km distances. However, it's possible to return species locations generalised to greater distances of 50 km. In these situations, a species that lives quite far from our specified area might appear in our query! To ensure species lists are accurate, it's always important to use `generalisationInMetres` to identify these data points, determine whether they are realistic or not, and clean them accordingly!

:::

# Final thoughts

We hope this post has helped you understand how to draw buffers around a shape, as well as the importance of considering buffer size when determining sensitive/threatened species in an area. Ultimately, buffer size will depend on the question we are trying to answer, whether that's for research, monitoring, conservation or environmental impact assessment prior to development.

For other Python posts, check out [our beginner’s guide to map species observations](https://labs.ala.org.au/posts/2023-12-18_beginners-guide-make-a-map/) or see [how to cross reference a species list with a conservation list](https://labs.ala.org.au/posts/2024-02-12_species-lists/).

<details><summary style = "color: #E06E53;">Expand for session info</summary>

```{python}
#| echo: false
import math
import natsort
import pandas
import session_info

session_info.show()
```

</details>
