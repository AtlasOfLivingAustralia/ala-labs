---
title: "Modelling the Impact of the Black Summer (2019/20) Bush Fires on the Southern Greater Glider (Petauroides volans) Distribution in Southern NSW"
description: |
  Major fire events impact flora and fauna, particularly those that dwell in areas where fire dramatically alters the livable habitat area. Here we investigate how greater gliders, a tree-dwelling marsupial species, were impacted by the 2019-2020 bush fires using species distribution models and general linear modelling.
author:
  - name: "Jarod Wright"
  - name: "Dax Kellie"
date: "2025-02-10"
title-block-banner: "#B8573E"
toc: true
toc-location: left
toc-depth: 2
categories:
  - Eukaryota
  - Animalia
  - Marsupialia
  - Bush fires
  - Maps
  - R
image: sdm-map.png
freeze: true
draft: true
editor_options: 
  chunk_output_type: console
---

```{r}
#| cache: true
#| include: false
library(htmltools)
```

<!-- remove metadata section -->

```{=html}
<style>
  #title-block-header.quarto-title-block.default .quarto-title-meta {
      display: none;
  }
</style>
```

<!-- Author card -->

::::::: author-card
::: author-card-text
#### Author

Jarod Wright\
[Dax Kellie](https://labs.ala.org.au/about/Kellie_Dax/index.html)

#### Date

11 February 2025
:::

::::: {.row-b layout-ncol="3" style="margin-left: auto; margin-right: auto; margin-top: auto; margin-bottom: auto;"}
::: {.author-card-image style="width: auto; height: 120px; margin-right: auto !important;"}
<img src="https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/jarod.jpg" style="object-fit: cover; border-radius: 50% !important; width: 140px;"/></img>
:::

::: {.author-card-image style="width: auto; height: 120px; margin-right: auto;"}
<img src="https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/dax.jpg" style="object-fit: cover; border-radius: 50% !important; width: 140px;"/></img>
:::
:::::
:::::::

<!------------------------ Post starts here ------------------------>

Bush fires are a frequent and natural part of Australia’s ecosystems. Australia's flora and fauna have adapted alongside fire, with some plants [needing fire to germinate and regenerate](https://www.dbca.wa.gov.au/wildlife-and-ecosystems/fire-and-environment/fire-plants-and-vegetation).

Aboriginal and Torres Strait Islander people have expertly [used fire for tens of thousands of years](https://www.sciencedirect.com/science/article/pii/S0016718521000233) to [care for Country](https://www.bushheritage.org.au/what-we-do/our-challenge/fire-management), managing vegetation, reducing wildfire risk, and fostering biodiversity. This deep connection between fire and the environment continues to influence modern land management practices today. Since European colonisation, however, the disruption of these practices has created a [build-up of fuel loads](https://wwf.org.au/blogs/new-study-confirms-indigenous-fire-management-equals-success/) and introduced invasive plant species. When combined with warming temperatures, Australia is increasingly at risk of larger, uncontrollable bush fires.

In 2019-2020, Australia experienced one of the most catastrophic bushfire seasons on record, with approximately [19 million hectares burnt and approximatelly 3 billion animals killed or displaced by the fires](https://wwf.org.au/what-we-do/australian-bushfires/). Over [900 species](https://www.nature.com/articles/s41586-024-08174-6) of plants and animals were severely impacted by the fires. Of the 19 million hectares burnt in those fires, 12.6 million were primarily forest and bushland.

In this post we will explore the impact of the 2019-2020 bushfires on a population of greater gliders (*Petauroides volans*), an arboreal marsupial species found along the east coast of Australia, increasingly under threat due to habitat destruction, climate change and intense bushfires. We will first use species distribution modelling (SDM) to predict the greater gliders' overal habitat range, then use general linear modelling to test whether greater glider observations were impacted by the 2019-2020 bush fires.

To begin, we can load the following packages.

```{r}
#| warning: false
#| message: false
library(galah)
library(tidyverse)
library(tidymodels) 
library(tidysdm) # devtools::install_github("EvolEcolGroup/tidysdm")
library(terra)
library(tidyterra)
library(here)
library(sf)
library(ozmaps)
library(elevatr)
library(geodata)
library(stacks)
```

# Download data

The Southern Greater Glider (*Petauroides volans*) is Australia’s largest gliding marsupial, found in tall eucalypt forests along the east coast, from Queensland to Victoria. They are an endagered nocturnal, tree-dwelling herbivore that primarily feed on eucalyptus leaves, much like the Koala! They grow up to 1m long from head to tail and glide up to 100 metres through the canopy. Gliders den in hollow bearing trees and can have multiple dens in their home range.

::: {layout-ncol="2" style="margin-left: auto; margin-right: auto;"}
<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/2/1/0/8/e0bec186-b95a-4a50-8ce3-824143268012/original" class="rounded"/></img>

<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/c/4/c/e/a0428bcf-f667-4f43-80b5-5ba1dc40ec4c/original" class="rounded"/></img>
:::

::: figure-caption
Left: [*Petauroides volans* (Josh Bowell \| CC-BY-NC 3.0 (Au))](https://biocache.ala.org.au/occurrences/fde509c4-f493-46fc-9ae5-bab9fe2fc621), Right: [*Petauroides volans* (David Sinnott \| CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/65b74308-6e20-40f1-ac34-0b8f65a468bd)
:::

We're going to focus on a region of South-East New South Wales and the Australian Captial Territory. Let's establish a bounding box around our area and pull in a map of Australia for later rendering and working with our rasters.

```{r}
#| warning: false
# define geographic region of bounding box
# tibble format is handy for plotting
se_nsw_bbox <- tibble(
  ymin = -37.5,
  ymax = -35,
  xmin = 148.5,
  xmax = 151
)
# Create a terra extent 
# SpatExtent objects are used for modifying raster layers later on
bbox_ext <- terra::ext(
  c(se_nsw_bbox[["xmin"]], 
    se_nsw_bbox[["xmax"]], 
    se_nsw_bbox[["ymin"]], 
    se_nsw_bbox[["ymax"]]
  ))

# Create an sf object of our bounding box
# sf object will help specify elevation data later on
bbox_sf <- st_as_sf(as.polygons(bbox_ext, crs = "EPSG:4326"))

# Get outline of Australia
aus <- ozmaps::ozmap_country |>
  st_transform(crs = "EPSG:4326")
```

::: aside
```{r}
#| echo: false
#| warning: false
ggplot() +
  geom_sf(data = ozmaps::ozmap_states, fill = "grey95", color = "grey30") +
  geom_sf(data = bbox_sf, fill = NA, color = "red", size = 1) +
  labs(title = "Study Area") +
  coord_sf(xlim = c(147.5, 152.5), 
         ylim = c(-38, -33)) +
  theme_minimal()
```
:::

Now lets download Greater Glider records in a 10-year time period (2014-2024) which captures observations of greater gliders before and after the 2019-2020 bushfires.

```{r}
#| warning: false
#| output: false
#| echo: false
galah_config(email = "jarod.wright@csiro.au", verbose = FALSE)

gliders <- galah_call() |>
  identify("Petauroides volans") |>
  filter(year >= 2014 & year <= 2024) |>
  galah_apply_profile(ALA) |>
  galah_geolocate(se_nsw_bbox, type = "bbox") |>
  atlas_occurrences()

# Create an sf object for spatial analysis & mapping
gliders_sf <- gliders |>
  st_as_sf(coords = c("decimalLongitude", "decimalLatitude")) |>
  st_set_crs(4326)
```

```{r}
#| eval: false
galah_config(email = "your-email-here") # Registered ALA email

# Collect all greater glider records between 2014 and 2024 for the region we defined
gliders <- galah_call() |>
  identify("Petauroides volans") |>
  filter(year >= 2014 & year <= 2024) |>
  galah_apply_profile(ALA) |>
  galah_geolocate(se_nsw_bbox, type = "bbox") |>
  atlas_occurrences()

# Create an sf object for spatial analysis & mapping
gliders_sf <- gliders |>
  st_as_sf(coords = c("decimalLongitude", "decimalLatitude")) |>
  st_set_crs(4326)

```

::: aside
```{r}
#| warning: false
#| echo: false
#| fig-cap: 
#|   - "Greater Glider Observations (2014-2024)"
ggplot() +
  geom_sf(data = aus, fill = "grey95", color = "grey30") +
  geom_rect(data = se_nsw_bbox,
            mapping = aes(xmin = xmin, 
                          ymin = ymin, 
                          xmax = xmax, 
                          ymax = ymax),
            colour = "grey50",
            fill = NA) + 
  geom_sf(data = gliders_sf, 
          colour = "#0F3F5C",
          size = 2, 
          alpha = 0.7) +
  coord_sf(xlim = c(se_nsw_bbox$xmin, se_nsw_bbox$xmax), 
           ylim = c(se_nsw_bbox$ymin, se_nsw_bbox$ymax)) +
  theme_void()
```
:::

Now that we have greater glider observations, we can start pulling in our raster data for our model.

# 1. Predict distribution (SDM)

## Spatial data

There are a few environmental factors that have a lot of influence over a greater glider's suitable habitat. Mainly, this would be dependent on tree cover (and hollow bearing trees), elevation (they're an alpine species) and climate (preferred range of temperature and precipitation).

So for our species distribution model, we will need to load quite a few raster files---**five** in total. Four of these raster layers provide geographic or environmental information to predict greater gliders' habitat range. Greater gliders are typically found in eucalypt forests at higher elevations, so with the help of previous studies on gliders (e.g. [Smith et al. 2007](https://www.publish.csiro.au/WR/WR06063); [Ridley et al. 2024](https://onlinelibrary.wiley.com/doi/full/10.1111/aec.13582)), we've chosen to download the following raster layers:

1.  Elevation (from the [elevatr package](https://github.com/USEPA/elevatr))
2.  Tree cover (from [Global Land Analysis & Discovery](https://glad.umd.edu/dataset/global-2010-tree-cover-30-m))
3.  Mean annual temperature (BIO1) (from [CHELSA](https://chelsa-climate.org/))
4.  Annual precipitation (BIO12) (from [CHELSA](https://chelsa-climate.org/))

To help answer our question about bush fire impact, we will also need to download a raster layer which maps the area burnt over the 2019-2020 bush fires:

5.  Extent of the 2019 bushfires (from the [NSW government](https://datasets.seed.nsw.gov.au/dataset/fire-extent-and-severity-mapping-fesm-2019-20))

Each raster layer will need to be wrangled so that they fit neatly together (same area, same projection, same resolution). We will perform a common series of modifications to each layer that generally fall into the following steps: 

  * **Crop** the layer to our study area 
  * **Mask** (or remove) the ocean from our layer so that it does not skew our model 
  * **Resample** each layer to the same resolution (so that every layer's grid aligns correctly)
  * **Rename** the layers to something sensible

These steps might not always be in the same order, but you will recognise them as we go through the next few sections to download our spatial data.

#### Elevation

First we'll download elevation data for our defined region using the `{elevatr}` package's handy `get_elev_raster()` function. By passing our bounding box `bbox_sf` to the `locations` argument we can return elevation data (in metres) for our specified area!


```{r}
#| warning: false
#| output: false
# Download elevation raster
elevation_data <- get_elev_raster(locations = bbox_sf, 
                                  z = 9, 
                                  prj = "EPSG:4326")

# Remove raster information outside of the aus land boundary
elevation_aligned <- elevation_data |>
  terra::rast() |>      # convert to SpatRaster class
  terra::mask(aus) |>   # remove information outside of aus boundary
  terra::crop(bbox_ext) # crop layer to bbox

# Rename layer for simplicity
names(elevation_aligned) <- "elevation"

```


```{r}
#| code-fold: true
#| warning: false
#| fig-cap: 
#|   - "Elevation (Metres)"
ggplot() +
  geom_spatraster(data = elevation_aligned, aes(fill = elevation)) +
  scale_fill_terrain_c(na.value = NA) +
  guides(fill = guide_colorbar(title = "Elevation (Metres)")) +
  theme_minimal()
```


#### Tree cover

Next we'll download tree cover data. This tree cover raster layer contains satellite data from [Hansen et al (2010)](https://glad.umd.edu/dataset/global-2010-tree-cover-30-m) where tree cover is recorded as a percentage (`0` = no cover and `100` = complete tree cover). 

Spatial data are held on the [Global Land Analysis and Discovery website](https://glad.umd.edu/). Tree cover data files are divided in tiles of 10 x 10 latitude/longitude. Because our study area crosses over two tiles (`30S_150` and `30S_140`), we will need to download and stitch together two rasters. We can then crop them down to our specified area. 

To download the files, go to the [global 2010 treecover dataset](https://glad.umd.edu/dataset/global-2010-tree-cover-30-m) --> click on the url link under the **Data Links** subheading near the bottom of the page --> click on the relevant data links to download. The two file names we are interested in are: `treecover2010_30S_140E.tif` and `treecover2010_30S_150E.tif`.

You can alternatively use the following code chunk to download files:

```{r}
#| eval: false
download.file("https://glad.umd.edu/Potapov/TCC_2010/treecover2010_30S_140E.tif", destfile="treecover2010_30S_140E.tif")
download.file("https://glad.umd.edu/Potapov/TCC_2010/treecover2010_30S_150E.tif", destfile="treecover2010_30S_150E.tif")
```

Let's load our files into R as rasters. 

```{r}
#| echo: false
#| warning: false
#| message: false
# Load the rasters
tree_cover_150 <- terra::rast(here::here("posts", "data", "tree-cover", "treecover2010_30S_150E.tif"))
tree_cover_140 <- terra::rast(here::here("posts", "data", "tree-cover", "treecover2010_30S_140E.tif"))
```

```{r}
#| eval: false
# Load the raster
tree_cover_150 <- terra::rast(here("treecover2010_30S_150E.tif"))
tree_cover_140 <- terra::rast(here("treecover2010_30S_140E.tif"))
```

Now we can crop them to our study area and merge them together.

```{r}
# Crop to bbox
tree_cover_150_cropped <- tree_cover_150 |>
  terra::crop(bbox_ext)

tree_cover_140_cropped <- terra::crop(tree_cover_140, bbox_ext)

# Merge
tree_cover <- merge(tree_cover_150_cropped, tree_cover_140_cropped)

# Rename for simplicity
names(tree_cover) <- "treecover"
```

:::{.callout-note collape="TRUE"}
## Best practice 

When working with spatial data we tend to use up a lot of memory! That's a big reason why we are performing these cropping steps, so that we can use up the least amount of memory necessary to get our model to function. Because of this, after we have stitched our two rasters into our composite `tree_cover_2010` raster, we can safely delete the other two as we will no longer require them.

```{r}
# We can now safely delete the first two raster files to save memory
rm(tree_cover_140); rm(tree_cover_150)
```

:::

```{r}
#| warning: false
#| code-fold: true
#| fig-cap: 
#|   - "Tree cover (%)"
ggplot() +
  geom_spatraster(data = tree_cover, aes(fill = treecover)) +
  scale_fill_viridis_c(direction = -1, begin = 0.8, end = 0.1) +
  guides(fill = guide_colorbar(title = "Tree Cover (%)")) +
  theme_minimal()
```


#### Temperature & precipitation

Next we’ll download two bioclimatic raster layers from [CHELSA](https://chelsa-climate.org/). CHELSA hosts climate projections at high resolutions intended for ecological use ([here's the paper about it](https://doi.org/10.1038/sdata.2017.122)). Climate projections extend from 1981 to 2100. Vegetation that greater gliders inhabit is sensitive to temperature and precipitation changes, so we decided to use climate projections for 2011-2040 for the following two climate variables: 

  * BIO1: Mean Annual Temperature
  * BIO12: Annual Precipitation

To download these layers on the [CHELSA website](https://chelsa-climate.org/), click on 'Downloads' in the top bar, under version 2.1 click the 'Download' button, then navigate to `GLOBAL/*` --> `climatologies/` --> `UKESM1-0-LL` --> `ssp370/` --> `bio/`. Then select the files with names beginning with `CHELSA_bio1_2011-2040` and `CHELSA_bio12_2011-2040`. Save these files in your local directory.

Alternatively, you can use the code below to download these files.

```{r}
#| eval: false
# Download our two raster files
download.file("https://os.zhdk.cloud.switch.ch/chelsav2/GLOBAL/climatologies/2011-2040/UKESM1-0-LL/ssp370/bio/CHELSA_bio1_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif",
              destfile="CHELSA_bio1_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif", mode="wb")  

download.file("https://os.zhdk.cloud.switch.ch/chelsav2/GLOBAL/climatologies/2011-2040/UKESM1-0-LL/ssp370/bio/CHELSA_bio12_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif",
              destfile="CHELSA_bio12_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif", mode="wb") 
```


```{r}
#| warning: false
#| message: false
#| echo: false
temp <- rast(
  here("posts",
       "data",
       "CHELSA_bioclim",
       "CHELSA_bio1_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif"
       ))
precip <- rast(
  here("posts",
       "data",
       "CHELSA_bioclim",
       "CHELSA_bio12_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif"
       ))
```

Let's load our files into R as rasters.

```{r}
#| eval: false
temp <- rast("CHELSA_bio1_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif")
precip <- rast("CHELSA_bio12_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif")
```

Now we'll mask and crop each layer, then rename them.

```{r}
# mask and crop to study area
temp <- temp |>
  terra::mask(aus) |>   # remove oceans
  terra::crop(bbox_ext) # crop to bbox

precip <- precip |>
  terra::mask(aus) |>   # remove oceans
  terra::crop(bbox_ext) # crop to bbox

# Rename for simplicity
names(temp) <- "temp_bio1"
names(precip) <- "precip_bio12"
```


```{r}
#| echo: false
#| message: false
#| warning: false
# Temperature
temp_map <- ggplot() +
  geom_spatraster(data = temp, aes(fill = temp_bio1)) +
  scale_fill_viridis_c(option = "inferno", 
                       end = 0.9, 
                       na.value = "transparent") +
  guides(fill = guide_colorbar(title = "Mean Annual\nTemperature (°C)")) +
  theme_minimal()

# Precipitation
precip_map <- ggplot() +
  geom_spatraster(data = precip, aes(fill = precip_bio12)) +
  scale_fill_viridis_c(option = "mako", 
                       direction = -1, 
                       begin = 0.1, 
                       na.value = "transparent") +
  guides(fill = guide_colorbar(title = "Annual\nPrecipitation (mm)")) +
  theme_minimal()
```

```{r}
#| echo: false
#| fig-column: body-outset
#| fig-align: center
#| layout-ncol: 2
#| layout-nrow: 1
#| fig-cap: 
#|   - "Mean Annual Temperature (BIO1)"
#|   - "Annual Precipitation (BIO12)"
temp_map
precip_map
```

#### Fire extent

Finally, we will download a fire extent raster layer, documenting the area burnt by the 2019-2020 bushfires in New South Wales. We don't need to use this layer just yet for our species distribution model, but it's easiest to download and wrangle it now so everything is in order later.

The NSW Government’s [Fire Extent and Severity Mapping (FESM) 2019/20 dataset](https://datasets.seed.nsw.gov.au/dataset/fire-extent-and-severity-mapping-fesm-2019-20) contains information on the extent and severity of burnt areas across the state. To download, navigate to the [NSW Government website](https://datasets.seed.nsw.gov.au/dataset/fire-extent-and-severity-mapping-fesm-2019-20), click on 'Dataset Packages', then select the download icon next to 'FESM v3-data in IMG and TIFF format'. Save this zip folder in your working directory and uncompress the folder.

:::{.callout-important collapse="true"}
## Warning: Big zip folder
While the download itself is only several hundred megabytes, when uncompressed the .tif file is *very* large (10.3 GB). Please keep this in mind when choosing a place to store the folder!
:::

Let's load the fire extent layer into R as a raster.

```{r}
#| warning: false
#| message: false
#| echo: false
# Load raster
fire_extent_cropped <- rast(here("posts",
                         "data", 
                         "fire_extent",
                         "cvmsre_NSW_20192020_ag1l0.tif"))

fire_extent <- rast(here("posts", "2025-02-07_greater-gliders", "cvmsre_NSW_20192020_ag1l0.tif"))
```

```{r}
#| eval: false
# Load raster
fire_extent <- rast("cvmsre_NSW_20192020_ag1l0.tif")
```

This file is pretty huge *and* it's in the wrong projection (you can see this under `coord. ref` when we view the object). Our desired CRS is `WGS84`/`EPSG:4326`, but this raster is projected using CRS `GDA_94_Lambert`, which affects the longitude and latitude coordinates. 

```{r}
fire_extent
```


This poses an issue for us. Reprojecting the entire file to `WGS84` (like we have for other rasters) will take up a lot of processing time and memory if we do this reprojection as a first step.

To save time and memory, let's use an alternative method of cropping first and reprojecting second. We'll first crop `fire_extent` to our desired study area by taking our original `bbox_ext` object and matching its projection to the CRS of `fire_extent`. We'll use `bbox_ext_gda94` to crop `fire_extent` to a much smaller area. Then, second, we can reproject our `fire_extent_cropped` object to the correct projection (and crop again to be certain our layer matches our other layers).

First let's convert our bounding box `bbox_ext`, convert it to a polygon and reproject that polygon to use the CRS of `fire_extent`.

```{r}
# Convert bbox to polygon with new projection that matches fire_extent
bbox_ext_gda94 <- bbox_ext |> 
  terra::as.polygons(
    crs = gliders_sf           # set crs to match glider data
    ) |>
  terra::project(fire_extent)  # reproject crs to match fire_extent

bbox_ext_gda94
```

Now we can use our new bounding box `bbox_ext_gda94` to crop `fire_extent` to our study area, then reproject it to our desired CRS `WGS84`. When complete, you'll notice the `extent` and `coord. ref.` or `fire_extent_cropped` have changed to match our expected bounding box and CRS.

:::{.callout-important}
## This process takes a while to run
This series step to crop and reproject `fire_extent` takes ~5 minutes to run.
:::

<!-- This was failing but now it works. Keep an eye on it -->

```{r}
#| eval: false
# Crop fire_extent using the reprojected bbox, then reproject to WGS84
fire_extent_cropped <- fire_extent |>
  terra::crop(bbox_ext_gda94) |>
  terra::project(crs(gliders_sf))   # reproject to match glider data

fire_extent_cropped
```

There are a few tailing decimal places that appeared while converting the `extent` of `fire_extent_cropped`. To make sure it matches other rasters, we'll crop it again using `bboc_ext`. You'll see the `extent` slightly but noticeably changes.

```{r}
#| eval: false
fire_extent_cropped <- fire_extent_cropped |>
  terra::crop(bbox_ext)

fire_extent_cropped
```

We'll now mask out the ocean and rename the raster layer like we did for other layers.

```{r}
#| warning: false
# Remove ocean
fire_extent_cropped <- fire_extent_cropped |>
    terra::mask(aus)

# Rename for simplicity
names(fire_extent) <- "fire_extent"
```

```{r}
#| code-fold: true
#| warning: false
#| message: false
#| fig-cap: 
#|   - "Fire Severity"
ggplot() +
  geom_spatraster(data = fire_extent_cropped, aes(fill = fire_extent)) +
  scale_fill_princess_c(palette = "america")  +
  guides(fill = guide_colorbar(title = "Fire Severity in South-East NSW (2019-2020)")) +
  theme_minimal()
```



### Match resolution

A final important step is make sure our layers are projected at the same resolution. Aligning rasters allows for more accurate and reliable results because grid cells won't overlap in unexpected ways (which would affect our model). Typically, the resolution should match the layer with the lowest resolution. In our case, this is `elevation_aligned` layer, which you can see if you print the object to the console and compare with other layers.

```{r}
elevation_aligned
```

Let's resample each layer to match the resolution of `elevation_aligned` using `terra::resample()`.

```{r}
# Resample our tree cover to the resolution of the elevation data
tree_cover <- terra::resample(tree_cover, elevation_aligned)
temp <- terra::resample(temp, elevation_aligned)
precip <- terra::resample(precip, elevation_aligned)
fire_extent <- terra::resample(fire_extent, elevation_aligned)
```



### Combine spatial layers

We can now combine all of our raster layers into one object containing: 

-   Elevation
-   Mean annual temperature (BIO1)
-   Annual precipitation (BIO12)
-   Extent of the 2019 bushfires
-   Tree cover

We can then feed this into our model to extract environmental values at each glider occurrence (or absence) location.

```{r}
combined_rasters <- c(elevation_aligned, temp, precip, fire_extent_cropped, tree_cover)

combined_rasters
```

Phew! That was a lot of data preparation. But now that we have our spatial layers ready to go, we can begin the modelling process!

## Build our model

If you're new to species distribution modeling (SDM) or want a deeper dive into the details of species distribution modelling, check out this ALA Labs post: [An introduction to species distribution modelling using {tidysdm} & {tidymodels}](https://labs.ala.org.au/posts/2024-04-30_sdm-tidymodels/). 

This post will use a similar workflow but will spend less time explaining the ins-and-outs of how species distribution modelling works.

### Prepare data

First, we will **thin** our data so that there is only one glider observation in any individual grid cell, so that each grid cell contains a "presence" or "absence".

```{r}
gliders_thin <- tidysdm::thin_by_cell(gliders_sf, 
                                      raster = combined_rasters)

```

::: aside
```{r}
#| echo: false
#| code-fold: true
#| code-summary: Code for map
#| message: false
#| warning: false
#| fig-cap: "Thinned observations"
# see thinned data
ggplot() +
  geom_spatraster(data = temp, 
                  aes(fill = temp_bio1),
                  alpha = 0.1) +
  geom_rect(data = se_nsw_bbox,
            mapping = aes(xmin = xmin, 
                          ymin = ymin, 
                          xmax = xmax, 
                          ymax = ymax),
            colour = "grey50",
            fill = NA) +  
  geom_sf(data = gliders_thin,
          size = 2,
          colour = "#312108") +
  scale_fill_viridis_c(option = "inferno", 
                       end = 0.9, 
                       na.value = "transparent") +
  guides(fill = "none") +
  theme_void()
```
:::


Next, we will add *pseudo-absences*[^pseudo] to our data because our glider observations from the ALA are presence-only[^presonly].

[^pseudo]: Pseudo-absences, also called background points, are points that represent true absences in our data for modelling. They are there to help our model make predictions about what variables more strongly predict a presence vs an absence. Because we don't have true presence data, this is one way to provide a model this information, though it is less informative for our interpretation.

[^presonly]: They only provide information about the conditions of when a glider was observed but no information about when gliders *aren't* observed

```{r}
# Generate pseudo-absences
gliders_pseudoabs <- tidysdm::sample_pseudoabs(
  gliders_thin,
  n = 3 * nrow(combined_rasters), 
  raster = combined_rasters,
  method = c("dist_min", tidysdm::km2m(5))
  )

# Extract environmental data for each pseudo-absence
gliders_pseudoabs <- gliders_pseudoabs |>
  # Extract tree cover, elevation and climate values for pseudoabs points
  bind_cols(
  terra::extract(combined_rasters,
                 gliders_pseudoabs,
                 ID = FALSE)
  )

gliders_pseudoabs
```

And we'll join our pseudo-absences to our thinned presence data `gliders_thin`.

```{r}
gliders_events <- gliders_pseudoabs |>
    st_join(
    gliders_thin, 
    left = TRUE
    )

gliders_events
```

::: aside
```{r}
#| echo: false
#| code-fold: true
#| code-summary: Code for map
#| message: false
#| warning: false
#| fig-cap: "Presence and pseudo-absence points"
# see pseudo absences
ggplot() +
  geom_spatraster(data = temp, 
                  aes(fill = temp_bio1),
                  alpha = 0.1) +
  geom_rect(data = se_nsw_bbox,
            mapping = aes(xmin = xmin, 
                          ymin = ymin, 
                          xmax = xmax, 
                          ymax = ymax),
            colour = "grey50",
            fill = NA) +  
  geom_sf(data = gliders_pseudoabs,
          aes(col = class),
          size = 2) +
  scale_colour_manual(values = c("#312108", "#8A6A35")) +
  scale_fill_viridis_c(option = "inferno", 
                       end = 0.9, 
                       na.value = "transparent") +
  guides(fill = "none") +
  theme_void()
```
:::




### Train our model

Our data is ready to be used for model training and testing. Let's **split** our data into training and testing datasets, allocating ~75% of points to training and ~25% to testing.

```{r}
set.seed(100)

# Allocate data into training or testing datasets
gliders_split <- 
  gliders_events |>
  initial_split()
gliders_split

# Create datasets
gliders_train <- training(gliders_split)
gliders_test <- testing(gliders_split)
```

:::{.panel-tabset .nav-pills}

## Train

```{r}
gliders_train |> head(5L)
```

## Test

```{r}
gliders_test |> head(5L)
```

:::

Now we'll **resample** our data into *folds* (i.e. smaller resampled datasets) using *block cross-validation*, a type of resampling better-suited to spatial data (for more info on what this means, see [this section from another ALA Labs article](https://labs.ala.org.au/posts/2024-04-30_sdm-tidymodels/#resampling)). We will use these folds to train and tune our model.

```{r}
# Perform Cross validation
gliders_cv <- spatial_block_cv(gliders_train, v = 5)

gliders_cv
```

Next, we'll define our model's "recipe". We wish to test how our response variable `class` (presence or absence) is affected by each predictor variable (`elevation`, `temp_bio1`, `temp_bio12`, `treecover` and `fire_extent`).

```{r}
gliders_recipe <- recipe(
  gliders_train, 
  formula = class ~ elevation + temp_bio1 + precip_bio12 + treecover + fire_extent
  )

gliders_recipe
```

Now we can set our workflow to use our "recipe" and training data to run several types of models (see [tidysdm](https://evolecolgroup.github.io/tidysdm/articles/a0_tidysdm_overview.html#fit-the-model-by-cross-validation) for more information).

```{r}
gliders_models <-
  workflow_set(
    preproc = list(default = gliders_recipe), # Use the same recipe for all
    models = list(
      glm = sdm_spec_glm(),        # Generalised Linear Model
      rf = sdm_spec_rf(),          # Random Forest
      gbm = sdm_spec_boost_tree(), # Gradient Boosting Machine
      maxent = sdm_spec_maxent()   # Maximum Entropy
    ),
    cross = TRUE 
  ) |>
  option_add(control = control_ensemble_grid())

gliders_models
```


### Tune our model

We're ready to use our workflow to tune and optimise our models using the cross validation blocks we generated earlier. This step helps us find which model parameters and hyperparameters make reasonable predictions.

Using `autoplot()`, we can quickly see which models performed best using three performance metrics for evaluating species distribution models (`boyce_cont`, `roc_auc` and `tss_max`). In general, results are pretty varied depending on the metric.

```{r}
#| warning: false
#| message: false
set.seed(9999)

# Tune the model using cross validation
gliders_models_tune <-
  gliders_models |>
  workflow_map("tune_grid",
               resamples = gliders_cv,     # Use our cross-validation blocks for tuning
               grid = 6,                   # number of tuning iterations
               metrics = sdm_metric_set(), # Evaluate model performance
               verbose = TRUE,
               control = stacks::control_stack_grid()
  )

gliders_models_tune
```

:::aside
```{r}
autoplot(gliders_models_tune)
```
:::

Let's "stack" our models into an [ensemble model that will blend predictions](https://stacks.tidymodels.org/articles/workflowsets.html) to help improve accuracy and generalisation. Again using `autoplot()`, we can see the relative weighting each model adds to our final prediction. 

```{r}
set.seed(98765)

gliders_stacked <- 
  stacks() |>                                # Initialize the stack
  add_candidates(gliders_models_tune) |>     # Add models
  blend_predictions() |>                     # Blend their predictions
  fit_members()                              # Fit the final model
```

:::aside
```{r}
# Visualise each models contribution
autoplot(gliders_stacked, 
         type = "weights")
```
:::

Now that we have our stacked ensemble model, it’s time to test how well it performs on new data. We do this by making predictions about the points in `gliders_test` and comparing them to the "true" results. 

```{r}
# Predict probability of presence 
gliders_test_predictions <-
  gliders_test %>%
  bind_cols(predict(gliders_stacked, ., 
                    type = "prob", 
                    save_pred = TRUE))

gliders_test_predictions
```

Using `tidysdm::sdm_metric_set()`, we can print several helpful metrics about our model's performance. Overall, our model seems to have performed very well[^overfit]. A high Boyce index and ROC AUC result tell us that our model is well-calibrated, with a TSS Max of 0.814 telling us we have good predictive power.

[^overfit]: So well, in fact, that it's plausible they might be [*overfitting*](https://www.tmwr.org/tuning#overfitting-bad), making our model a poor predictibe model outside of our small spatial bounding box in New South Wales. For our intended analysis, this doesn't matter, but for a model intended for use to make broad future predictions this could pose a problem.

```{r}
# Evaluate performance
gliders_test_predictions |> 
  sdm_metric_set()(truth = class, .pred_presence)
```

:::{.callout-note collapse="TRUE"}
## Specifics about estimates

  * `boyce_cont`: The Boyce index is from -1 to 1, where values closer to 1 indicate the model's predictions are consistent with the actual value.

  * `roc_auc`: The Relative Operating Characteristics Area Under the Curve (ROC AUC) is from 0.5 to 1, where a value of 0.5 indicates that the model's predictions are no better than random chance, whereas a value of 1 indicates perfect prediction.

  * `tss_max`: The True Skill Statistic is from -1 to 1, where values closer to 1 indicate better model performance.

:::

## Predict greater glider distribution

We're ready to make our final prediction of greater gliders' distribution. We'll use  `tidysdm::predict_raster()`, a very helpful function for spatial predictions, and maps our results!

```{r}
#| fig-width: 9
#| fig-height: 9
#| fig-align: center
#| fig-column: page
#| out-extra: "style=margin-left:auto;margin-right:auto;"
#| lightbox: 
#|   group: final-plot
#|   description: Predicted distribution of greater gliders

# Predict
prediction_present <- predict_raster(gliders_stacked, 
                                     combined_rasters, 
                                     type = "prob",
                                     wopt = list(steps=32))

# Map
ggplot() +
  geom_spatraster(data = prediction_present, 
                  aes(fill = .pred_presence)) +
  scale_fill_viridis_c(option = "E", na.value = NA) +
  guides(fill = guide_colorbar(
    title = "Relative\nHabitat\nSuitability")
    ) +
  labs(title = "Predicted distribution of greater gliders") +
  pilot::theme_pilot(grid="hv") +
  theme(
    legend.text = element_text(hjust = 0.5)
    )
```


```{r}
#| eval: false
#| echo: false
prediction_present_fire2 <- prediction_present_fire |>
  rename(.pred_presence_fire = .pred_presence)

big_combo <- c(prediction_present_nofire, prediction_present_fire2)

big_combo_col <- big_combo |>
  mutate(
    .pred_difference = .pred_presence_fire - .pred_presence
  )

# Map
ggplot() +
  geom_spatraster(data = big_combo_col, 
                  aes(fill = .pred_difference)) +
  scale_fill_viridis_c(option = "D", na.value = NA) +
  guides(fill = guide_colorbar(
    title = "Relative\nHabitat\nSuitability")
    ) +
  labs(title = "Predicted Suitable Habitat for Greater Gliders", subtitle = "Elevation, tree cover, mean annual temp, annual precipitation and fire events.") +
  pilot::theme_pilot(grid="hv") +
  theme(
    legend.text = element_text(hjust = 0.5)
    )

# ggsave("glider_fire_diff.png")

```

<!-- 
There needs to be some sort of conclusion or interpretation of this map here
-->

<!-- As you can see we have a very nice map showing us areas of suitable habitat, and unsuitable habitat. Now we have this, let's dive in and see what impact the bushfires have had on suitable habitat for the gliders! -->

# 2. Test bushfire impact (GLM)

As the second part of our investigation, we wanted to know whether the 2019/2020 bushfires had an impact on greater gliders. More specifically (given our data is observational), we are interested in testing whether observations of gliders changed in areas burnt by the 2019/2020 Black Summer bushfires.

That means there are two important variables we will use to answer our question:

  * Whether an observation was made before or after the fires (`pre_fire` vs `post_fire`)  
  * Whether an area was burnt by the fires (`burnt` vs `unburnt`)

Our hypothesised effect is that there are *fewer* occurrences after the fire, and a driver of this effect is that *an area was previously burnt* during the 2019/2020 bushfires. 

Let's add this information to our data.

### Before or after fire

Let's add a new column `fire_period` to categorise whether an observation was recorded before or after the fires. We will categorise our observations by using a cut-off date around when the fires swept through the area.

It's difficult to pick a specific date because the fires lasted over several months, so we decided to choose the 1st of December 2019 as a cut-off between `pre_fire` and `post_fire`. This date marks the beginning of peak bush fire season, and many of the largest bush fires had moved into our study area by this point in time.

```{r}
# Classify each glider record as pre or post fire
gliders_sf <- gliders_sf |>
  mutate(
    fire_period = if_else(eventDate < as.Date("2019-12-01"), "pre_fire", "post_fire"),
    .before = eventDate # position the col so we can see it
    )

```

::: aside
```{r}
#| warning: false
#| echo: false
#| message: false
#| fig-cap: "Glider observations"
ggplot() +
  geom_sf(data = aus, fill = "grey97", color = "grey40") +
  geom_rect(data = se_nsw_bbox,
            mapping = aes(xmin = xmin, 
                          ymin = ymin, 
                          xmax = xmax, 
                          ymax = ymax),
            colour = "grey50",
            fill = NA) + 
  geom_sf(data = gliders_sf, 
          aes(color = fire_period), 
          size = 2, 
          alpha = 0.7) +
  scale_colour_manual(values = c("#0F3F5C", "#CF5F37")) +
  labs(color = "Fire Period") +
  coord_sf(xlim = c(se_nsw_bbox$xmin, se_nsw_bbox$xmax), 
           ylim = c(se_nsw_bbox$ymin, se_nsw_bbox$ymax)) +
  theme_void()
```
:::


Next, let's generate some more pseudo-absences around our more complete `gliders_sf`. Then we'll need to categorise these pseudo-absences into the same `pre_fire` and `post_fire` categories. This will allow our model to generate a `probability` of presence in both conditions, pre- and post-fire.

First we'll generate pseudoabsences, then extract the relevant variable data for each point. Then we'll rejoin any missing columns in `gliders_sf` to use in our next step.

```{r}
# Generate pseudo-absences
gliders_pseudoabs2 <- tidysdm::sample_pseudoabs(
  gliders_sf,
  n = 2 * nrow(combined_rasters),
  raster = combined_rasters,
  method = c("dist_min", tidysdm::km2m(5))
)

gliders_pseudoabs2 <- gliders_pseudoabs2 |>
  # Extract environmental data for each pseudo-absence
  bind_cols(
    terra::extract(combined_rasters,
      gliders_pseudoabs2,
      ID = FALSE
    )
  )

# Join our missing columns from `gliders_sf` to our new `pseudoabs2`.
gliders_events <- gliders_pseudoabs2 |>
  st_join(
    gliders_sf,
    left = TRUE
  )

gliders_events
```

As a simple way to categorise our pseudo-absence points, we'll use `sample()` to randomly assign them to `pre_fire` or  `post-fire` which will assign a more-or-less equal number of randomly selected pseudo-absence points for both timeframes[^random]. Doing this with `case_when()` allows us to conditionally assign a new category only when there isn't one already (i.e. only for pseudo-absence points).

[^random]: For this analysis, it doesn't really matter whether we have a *perfect* split.

```{r}
# Join fire categories from true presences 
# Then sample categories
gliders_edited <- gliders_events |>
  mutate(
    fire_period = case_when(
      # If there is no category already, sample one
      is.na(fire_period) ~ sample(c("pre_fire", "post_fire"),
                                  size = nrow(gliders_events),
                                  replace = TRUE),
      .default = fire_period
    )
  ) |>
  select(1:2, fire_period, everything()) # reorder

gliders_edited
```

::: aside
```{r}
#| warning: false
#| message: false
#| echo: false
#| fig-cap: "Pseudo-absences, assigned to `pre-fire` or `post-fire`"
# see pseudo absences with fire_period categories assigned
ggplot() +
  geom_spatraster(data = temp, 
                  aes(fill = temp_bio1),
                  alpha = 0.1) +
  geom_rect(data = se_nsw_bbox,
            mapping = aes(xmin = xmin, 
                          ymin = ymin, 
                          xmax = xmax, 
                          ymax = ymax),
            colour = "grey50",
            fill = NA) +  
  geom_sf(data = gliders_edited |> filter(class == "pseudoabs"),
          aes(col = fire_period),
          size = 2) +
  scale_colour_manual(values = c("#0F3F5C", "#CF5F37")) +
  labs(color = "Fire Period") +
  scale_fill_viridis_c(option = "inferno", 
                       end = 0.9, 
                       na.value = "transparent") +
  guides(fill = "none") +
  theme_void()
```
:::

To make the results of our `fire_period` column easier to interpret, let's reformat our categories to a dummy variable format, where `pre_fire` is `-1` and `post_fire` is `1`. Whichever number our coefficient is closer to will tell us which period had more greater glider occurrences.

```{r}
# Change fire period to a dummy variable 
gliders_filtered <- gliders_edited |>
  mutate(
    fire_period = as.numeric(
      if_else(fire_period == "post_fire", 1, -1)
      )
    )

gliders_filtered |> head(5L)
```

Now that we have greater glider observations over the period of time and area we're interested in, classified by pre or post fire, we can start pulling in our raster data for our model.

### Burnt area

Earlier we added our fire extent layer to our data ([go to this section]()). We have already added `fire_extent` to `gliders_filtered` when we added our `combined raster` columns to our data. The `fire_extent` layer contains information of area burnt and the fire's severity on a scale from 0 (unburnt) to 5 (extreme).

:::{.callout-note collapse="TRUE"}

## Fire severity values

The `fire_extent` dataset categorises fire severity using the following values:

-   0 - Unburnt (0% canopy and understory burnt)
-   1 - Reserved (Experimental category, is not used in raster right now)
-   2 - Low (\> 10% burnt upderstory, \>90% green canopy)
-   3 - Moderate (20-90% canopy scorch)
-   4 - High (\> 90% canopy scorched, \<50% canopy consumed)
-   5 - Extreme (\>50% canopy biomass consumed)

:::

```{r}
gliders_filtered |>
  select(1:2, fire_extent) |> 
  head(10L)
```

For our purposes, we are mainly interested in whether the area was affected by fire or not, rather than its severity. For simplicity, let's recode `fire_extent` to whether an area is burnt or unburnt and save this info in a new column `burnt`. Again, we'll use a dummy variable to make our results easier to interpret where burnt is `1` and unburnt is `-1`.

We'll also make sure that our response variable `class` is ordered correctly, meaning that higher numbers in our model will indicate an effect on greater glider `presence` (or put more simply, that means more greater gliders).

```{r}
gliders_edited <- gliders_filtered |>
  st_drop_geometry() |>
  mutate(
    # make `burnt` column
    burnt = case_when(
      fire_extent > 0 ~ -1, # burnt
      fire_extent == 0 ~ 1, # unburnt
      .default = NA_integer_
    ),
    # reorder `class` levels
    class = forcats::fct_relevel(class, "presence", after = 1)
  )

gliders_edited |>
  select(1:2, fire_period, burnt, everything())
```

### Test effect of fire

We are finally ready to run our model. Here's what we are expecting to see given our hypothesis:

  * Fewer occurrences after the fire. This will appear as a significant, negative `fire_period` coefficient.
  * Fewer occurrences in burnt areas. This will appear as a significant, negative `burnt` coefficient.
  * An interaction between fire period and burnt area, because burnt areas after fire will have very few records. This will appear as a significant, negative coefficient.

<!-- (but interactions are complicated so maybe not) -->

```{r}
set.seed(100)
fire_model <- glm(
  class ~ fire_period + burnt + fire_period:burnt + 
               elevation + temp_bio1 + precip_bio12 + treecover, # controls
  data = gliders_edited, 
  family = "binomial"
  )
```

:::{.callout-note collapse="TRUE"}

## Checking model performance

It's always a good idea to check how your model performed, just in case issues with model assumptions affect your model's uncertainty. You can do this with `base::plot()`, but the `check_model()` function from the [performance package](https://easystats.github.io/performance/) provides really nice looking model checks. The output shows that our model performs reasonably well, though the residuals are a bit all over the place, meaning our model fit might lead to imperfect estimates.

```{r}
performance::check_model(fire_model)
```

:::

Let's view our model's results! You can use `summary()` or `broom::tidy()` depending on how you prefer the results are printed in the console.

:::{.panel-tabset .nav-pills}

## `tidy()`

```{r}
tidy(fire_model)
```

## `summary()`

```{r}
summary(fire_model)
```

:::

Overall, it looks like fire does have an effect, but it's a relatively small effect on greater glider occurrences. 

When running a model on this many data points, it's generally expected that most variables will be significant. It's easier to look at the size of the effect (i.e. `statistic`) and the estimate & standard error to figure out the direction and certainty of that estimate. Here we can see a few things:

  * As we might expect, elevation and tree cover are excellent predictors of greater gliders, which makes sense given they live in trees in alpine regions.
  * The positive estimate of `fire_period` suggests that there are more records of greater gliders after the fires than before. This is probably due to the growing number of records each year in the ALA (though the effect is relatively small).
  * The negative estimate of `burnt` suggests fewer records in burnt areas. However, the effect is pretty small.


# Final thoughts


 <!-- From Jarod below -->
 
Severe fires have a negative impact in glider distribution - The **more extreme** the fire events in the 2019 bushfire season, the **stronger the negative impact** on glider presence.

The pre vs post-fire effect is interesting. We saw a slight increase in post-fire glider presence in our model. This could be due to a number of factors, perhaps new tree hollows were formed in the fires, perhaps there increased survey efforts, or surviving gliders being more visible due to reduced canopy cover, gliders moving into less burnt areas, or even just more data entering into the ALA? There are so many questions here that are difficult to answer with the data we have on hand. It warrants further investigation.

This model gives us a solid look at how Southern Greater Gliders were affected by the Black Sumemr fires. Our model suggests that severe fires disrupted Glider habitat and had a strong negative impact. This is supported by research that has been done in the wake of the fires on greater gliders[^2].

[^2]: https://www.publish.csiro.au/wr/WR23129

### Change in habitat suitability for fire affected regions

As a final extra, let's create a map looking at the difference in habitat suitability for pre and post fire regions. To do this we will generate two separate models, those with data before and those with data after and subtract the two habitat suitability maps from each other to see what has changed due to fire!

<details>

<summary style="color: #E06E53;">

Expand for comparison map

</summary>

```{r}
#| warning: false
#| message: false
#| eval: false

# Collect all greater glider records in that period
gliders_2019 <- galah_call() |>
  identify("Petauroides volans") |>
  filter(year >= 2014 & year < 2020) |>
  galah_apply_profile(ALA) |>
  galah_geolocate(se_nsw_bbox, type = "bbox") |>
  atlas_occurrences()

gliders_2019 <- gliders_2019 |>
  mutate(year = year(eventDate),             # Extract the year
         month = month(eventDate))

gliders_sf_2019 <- gliders_2019 |>
  st_as_sf(coords = c("decimalLongitude", "decimalLatitude")) |>
  st_set_crs(4326)

gliders_sf_2019 <- gliders_2019 |>
  st_as_sf(coords = c("decimalLongitude", "decimalLatitude")) |>
  st_set_crs(4326)


gliders_thin <- tidysdm::thin_by_cell(gliders_sf_2019, 
                                      raster = combined_rasters)

gliders_pseudoabs <- tidysdm::sample_pseudoabs(
  gliders_thin,
  n = 3 * nrow(combined_rasters),
  raster = combined_rasters,
  method = c("dist_min", km2m(5)))


gliders_events_2019 <- gliders_pseudoabs |> 
  bind_cols(
    terra::extract(combined_rasters,
                   gliders_pseudoabs,
                   ID = FALSE))



gliders_events_2019 <- na.omit(gliders_events_2019)

predictor_vars <- c("elevation", "bio1", "bio12", "treecover")

gliders_filtered_2019 <- 
  gliders_events_2019 |> 
  select(all_of(c(predictor_vars, "class")))


# set training and testing data
set.seed(100)

gliders_split_2019 <- 
  gliders_filtered_2019 |>
  initial_split()

gliders_train <- training(gliders_split_2019)
gliders_test <- testing(gliders_split_2019)
gliders_cv <- spatial_block_cv(gliders_train, v = 5)


gliders_recipe <- recipe(
  gliders_train, 
  formula = class ~ elevation + bio1 + bio12 + treecover 
)

gliders_models <-
  # create the workflow_set
  workflow_set(
    preproc = list(default = gliders_recipe),
    models = list(
      glm = sdm_spec_glm(),        # the standard glm specs
      rf = sdm_spec_rf(),          # rf specs with tuning
      gbm = sdm_spec_boost_tree(), # boosted tree model (gbm) specs with tuning
      maxent = sdm_spec_maxent()   # maxent specs with tuning
    ),
    cross = TRUE # make all combinations of preproc and models
  ) |>
  # tweak controls to store information needed later to create the ensemble
  option_add(control = control_ensemble_grid())


set.seed(2345678) # for reproducability

gliders_models_tune <-
  gliders_models |>
  workflow_map("tune_grid",
               resamples = gliders_cv, 
               grid = 6,                   # increase for more iterations
               metrics = sdm_metric_set(),
               verbose = TRUE,
               control = stacks::control_stack_grid()
  )



set.seed(123456)

gliders_stacked <- 
  stacks() |>                                # initialize the stack
  add_candidates(gliders_models_tune) |> # add candidate members
  blend_predictions() |>                     # determine how to combine their predictions
  fit_members()                              # fit the candidates with nonzero stacking coefficients

gliders_test_predictions_2019 <-
  gliders_test %>%
  bind_cols(predict(gliders_stacked, ., 
                    type = "prob", 
                    save_pred = TRUE))


# predict class
gliders_test_predictions_class_2019 <-
  gliders_test %>%
  bind_cols(predict(gliders_stacked, ., 
                    type = "class", 
                    save_pred = TRUE))


prediction_present_2019 <- predict_raster(gliders_stacked, 
                                     combined_rasters, 
                                     type = "prob",
                                     wopt = list(steps=32))



#####Post fire
# Collect all greater glider records in that period
gliders_2024 <- galah_call() |>
  identify("Petauroides volans") |>
  filter(year > 2019 & year <= 2024) |>
  galah_apply_profile(ALA) |>
  galah_geolocate(se_nsw_bbox, type = "bbox") |>
  atlas_occurrences()

gliders_2024 <- gliders_2024|>
  mutate(year = year(eventDate),             # Extract the year
         month = month(eventDate))

gliders_sf_2024 <- gliders_2024|>
  st_as_sf(coords = c("decimalLongitude", "decimalLatitude")) |>
  st_set_crs(4326)



gliders_2024$burnt <- terra::extract(fire_extent, vect(gliders_sf_2024), ID = FALSE)



gliders_thin <- tidysdm::thin_by_cell(gliders_sf_2024, 
                                      raster = combined_rasters)

gliders_pseudoabs <- tidysdm::sample_pseudoabs(
  gliders_thin,
  n = 3 * nrow(combined_rasters),
  raster = combined_rasters,
  method = c("dist_min", km2m(5)))


gliders_events_2024 <- gliders_pseudoabs |> 
  bind_cols(
    terra::extract(combined_rasters,
                   gliders_pseudoabs,
                   ID = FALSE))

gliders_events_2024 <- na.omit(gliders_events_2024)

predictor_vars <- c("elevation", "bio1", "bio12", "treecover", "fire_extent")

gliders_filtered_2024 <- 
  gliders_events_2024 |> 
  select(all_of(c(predictor_vars, "class")))



combined_rasters <- combined_rasters[[predictor_vars]]
# set training and testing data
set.seed(100)

gliders_split_2024 <- 
  gliders_filtered_2024 |>
  initial_split()

gliders_train <- training(gliders_split_2024)
gliders_test <- testing(gliders_split_2024)

gliders_cv <- spatial_block_cv(gliders_train, v = 5)

gliders_recipe <- recipe(
  gliders_train, 
  formula = class ~ elevation + bio1 + bio12 + treecover + fire_extent
)

gliders_models <-
  # create the workflow_set
  workflow_set(
    preproc = list(default = gliders_recipe),
    models = list(
      glm = sdm_spec_glm(),        # the standard glm specs
      rf = sdm_spec_rf(),          # rf specs with tuning
      gbm = sdm_spec_boost_tree(), # boosted tree model (gbm) specs with tuning
      maxent = sdm_spec_maxent()   # maxent specs with tuning
    ),
    cross = TRUE # make all combinations of preproc and models
  ) |>
  # tweak controls to store information needed later to create the ensemble
  option_add(control = control_ensemble_grid())

set.seed(2345678) # for reproducability



gliders_models_tune <-
  gliders_models |>
  workflow_map("tune_grid",
               resamples = gliders_cv, 
               grid = 6,                   # increase for more iterations
               metrics = sdm_metric_set(),
               verbose = TRUE,
               control = stacks::control_stack_grid()
  )

set.seed(123456)

gliders_stacked <- 
  stacks() |>                                # initialize the stack
  add_candidates(gliders_models_tune) |> # add candidate members
  blend_predictions() |>                     # determine how to combine their predictions
  fit_members()                              # fit the candidates with nonzero stacking coefficients


gliders_test_predictions_2024 <-
  gliders_test %>%
  bind_cols(predict(gliders_stacked, ., 
                    type = "prob", 
                    save_pred = TRUE))


# predict class
gliders_test_predictions_class_2024<-
  gliders_test %>%
  bind_cols(predict(gliders_stacked, ., 
                    type = "class", 
                    save_pred = TRUE))



prediction_present_2024 <- predict_raster(gliders_stacked, 
                                         combined_rasters, 
                                         type = "prob",
                                         wopt = list(steps=32))

habitat_diff <- prediction_present_2024 - prediction_present_2019

# Only select regions where fire has impacted to get the difference in habitat suitability
fire_mask <- (fire_extent >= 2) & (fire_extent <= 5)
intersect_raster <- mask(habitat_diff, fire_mask, maskvalue=0)


ggplot() +
  geom_spatraster(data = intersect_raster, 
                  aes(fill = .pred_presence)) +
  scale_fill_whitebox_c(palette = "muted", direction = -1,
                        na.value = NA) +
  guides(fill = guide_colorbar(title="\nHabitat\nSuitability\nDifference")) +
  labs(title="Difference in predicted habitat suitability for fire impacted areas") +
  pilot::theme_pilot(grid="hv") +
  theme(
    legend.text = element_text(hjust = 0.5)) +
  theme_minimal()


```

</details>

<details>

<summary style="color: #E06E53;">

Expand for session info

</summary>

```{r, echo = FALSE}
library(sessioninfo)
# save the session info as an object
pkg_sesh <- session_info(pkgs = "attached")
# print it out
pkg_sesh
```

</details>

::::::::::::: :::::::::::::::
