---
title: "Modelling the Impact of the Black Summer (2019/20) Bush Fires on the Southern Greater Glider (Petauroides volans) Distribution in Southern NSW"
description: |
  Major fire events impact flora and fauna, particularly those that dwell in areas where fire dramatically alters the livable habitat area. Here we investigate how greater gliders, a tree-dwelling marsupial species, were impacted by the 2019-2020 bush fires using species distribution models and general linear modelling.
author:
  - name: "Jarod Wright"
  - name: "Dax Kellie"
date: "2025-02-10"
title-block-banner: "#B8573E"
toc: true
toc-location: left
toc-depth: 2
categories:
  - Eukaryota
  - Animalia
  - Marsupialia
  - Bush fires
  - Maps
  - R
image: sdm-map.png
freeze: true
draft: true
editor_options: 
  chunk_output_type: console
---

```{r}
#| cache: true
#| include: false
library(htmltools)
```

<!-- remove metadata section -->

```{=html}
<style>
  #title-block-header.quarto-title-block.default .quarto-title-meta {
      display: none;
  }
</style>
```

<!-- Author card -->

::::::: author-card
::: author-card-text
#### Author

Jarod Wright\
[Dax Kellie](https://labs.ala.org.au/about/Kellie_Dax/index.html)

#### Date

11 February 2025
:::

::::: {.row-b layout-ncol="3" style="margin-left: auto; margin-right: auto; margin-top: auto; margin-bottom: auto;"}
::: {.author-card-image style="width: auto; height: 120px; margin-right: auto !important;"}
<img src="https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/jarod.jpg" style="object-fit: cover; border-radius: 50% !important; width: 140px;"/></img>
:::

::: {.author-card-image style="width: auto; height: 120px; margin-right: auto;"}
<img src="https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/dax.jpg" style="object-fit: cover; border-radius: 50% !important; width: 140px;"/></img>
:::
:::::
:::::::

<!------------------------ Post starts here ------------------------>

Bush fires are a frequent and natural part of Australia’s ecosystems. Australia's flora and fauna have adapted alongside fire, with some plants [needing fire to germinate and regenerate](https://www.dbca.wa.gov.au/wildlife-and-ecosystems/fire-and-environment/fire-plants-and-vegetation).

Aboriginal and Torres Strait Islander people have expertly [used fire for tens of thousands of years](https://www.sciencedirect.com/science/article/pii/S0016718521000233) to [care for Country](https://www.bushheritage.org.au/what-we-do/our-challenge/fire-management), managing vegetation, reducing wildfire risk, and fostering biodiversity. This deep connection between fire and the environment continues to influence modern land management practices today. Since European colonisation, however, the disruption of these practices has created a [build-up of fuel loads](https://wwf.org.au/blogs/new-study-confirms-indigenous-fire-management-equals-success/) and introduced invasive plant species. When combined with warming temperatures, Australia is increasingly at risk of larger, uncontrollable bush fires.

In 2019-2020, Australia experienced one of the most catastrophic bushfire seasons on record, with approximately [19 million hectares burnt and approximatelly 3 billion animals killed or displaced by the fires](https://wwf.org.au/what-we-do/australian-bushfires/). Over [900 species](https://www.nature.com/articles/s41586-024-08174-6) of plants and animals were severely impacted by the fires. Of the 19 million hectares burnt in those fires, 12.6 million were primarily forest and bushland.

In this post we will explore the impact of the 2019-2020 bushfires on a population of greater gliders (*Petauroides volans*), an arboreal marsupial species found along the east coast of Australia, increasingly under threat due to habitat destruction, climate change and intense bushfires. We will use species distribution modelling (SDM) to predict the greater gliders' overal habitat range, then use general linear modelling to test whether greater glider observations were impacted by the 2019-2020 bush fires.

To begin, we can load the following packages.

```{r}
#| cache: true
#| warning: false
#| output: false
library(galah)
library(tidyverse)
library(tidymodels) 
library(tidysdm) # devtools::install_github("EvolEcolGroup/tidysdm")
library(terra)
library(tidyterra)
library(here)
library(sf)
library(ozmaps)
library(elevatr)
library(geodata)
library(stacks)
```

# Download data

The Southern Greater Glider (*Petauroides volans*) is Australia’s largest gliding marsupial, found in tall eucalypt forests along the east coast, from Queensland to Victoria. They are an endagered nocturnal, tree-dwelling herbivore that primarily feed on eucalyptus leaves, much like the Koala! They grow up to 1m long from head to tail and glide up to 100 metres through the canopy. Gliders den in hollow bearing trees and can have multiple dens in their home range.

::: {layout-ncol="2" style="margin-left: auto; margin-right: auto;"}
<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/2/1/0/8/e0bec186-b95a-4a50-8ce3-824143268012/original" class="rounded"/></img>

<img src="https://ala-images.s3.ap-southeast-2.amazonaws.com/store/c/4/c/e/a0428bcf-f667-4f43-80b5-5ba1dc40ec4c/original" class="rounded"/></img>
:::

::: figure-caption
Left: [*Petauroides volans* (Josh Bowell \| CC-BY-NC 3.0 (Au))](https://biocache.ala.org.au/occurrences/fde509c4-f493-46fc-9ae5-bab9fe2fc621), Right: [*Petauroides volans* (David Sinnott \| CC-BY-NC 4.0 (Int))](https://biocache.ala.org.au/occurrences/65b74308-6e20-40f1-ac34-0b8f65a468bd)
:::

We're going to focus on a region of South-East New South Wales and the Australian Captial Territory. Let's establish a bounding box around our area and pull in a map of Australia for later rendering and working with our rasters.

```{r}
#| cache: true
#| warning: false
#| output: false
# define geographic region
se_nsw_bbox <- tibble(
  ymin = -37.5,
  ymax = -35,
  xmin = 148.5,
  xmax = 151
)
# Create a terra extent for modifying the rasters later on
bbox_ext <- terra::ext(
  c(se_nsw_bbox[["xmin"]], 
    se_nsw_bbox[["xmax"]], 
    se_nsw_bbox[["ymin"]], 
    se_nsw_bbox[["ymax"]]
  ))

# Get the outline of Australia
aus <- ozmaps::ozmap_country |>
  st_transform(crs = "EPSG:4326")

# Create an sf object of our bounding box
bbox_sf <- st_as_sf(as.polygons(bbox_ext, crs = "EPSG:4326"))

```

::: aside
```{r}
#| cache: true
#| echo: false
#| warning: false
ggplot() +
  geom_sf(data = ozmaps::ozmap_states, fill = "lightgray", color = "black") +
  geom_sf(data = bbox_sf, fill = NA, color = "red", size = 1) +
  labs(title = "Study Area") +
  coord_sf(xlim = c(147.5, 152.5), 
         ylim = c(-38, -33)) +
  theme_minimal()
```
:::

Now lets download Greater Glider records in a 10-year time period (2014-2024) which captures observations of greater gliders before and after the 2019-2020 bushfires.

```{r}
#| cache: true
#| warning: false
#| output: false
#| echo: false
galah_config(email = "jarod.wright@csiro.au", verbose = FALSE)

gliders <- galah_call() |>
  identify("Petauroides volans") |>
  filter(year >= 2014 & year <= 2024) |>
  galah_apply_profile(ALA) |>
  galah_geolocate(se_nsw_bbox, type = "bbox") |>
  atlas_occurrences()
```

```{r}
#| eval: false
galah_config(email = "your-email-here") # Registered ALA email

# Collect all greater glider records between 2014 and 2024 for the region we defined
gliders <- galah_call() |>
  identify("Petauroides volans") |>
  filter(year >= 2014 & year <= 2024) |>
  galah_apply_profile(ALA) |>
  galah_geolocate(se_nsw_bbox, type = "bbox") |>
  atlas_occurrences()

```

We will also add a new column `fire_period` to categorise whether an observation was recorded before or after the fires.

The fires lasted over several months, so we decided to choose the 1st of December 2019 as a cut-off between `pre_fire` and `post_fire`. This date marks the beginning of peak bush fire season, and many of the largest bush fires had moved into our study area by this point in time.

```{r}
#| cache: true
#| warning: false
#| output: false
# Classify each glider record as pre or post fire
gliders <- gliders |>
  mutate(
    fire_period = if_else(eventDate < as.Date("2019-12-01"), "pre_fire", "post_fire")
    )

# Create an sf object so we can draw it later
gliders_sf <- gliders |>
  st_as_sf(coords = c("decimalLongitude", "decimalLatitude")) |>
  st_set_crs(4326)

```

::: aside
```{r}
#| cache: true
#| warning: false
#| echo: false
ggplot() +
  geom_sf(data = aus, fill = "lightgray", color = "black") +
  geom_sf(data = gliders_sf, aes(color = fire_period), size = 2, alpha = 0.7) +
  scale_color_manual(values = c("pre_fire" = "blue", "post_fire" = "red")) +
  labs(title = "Greater Glider Observations (2014-2024)",
       color = "Fire Period") +
  coord_sf(xlim = c(se_nsw_bbox$xmin, se_nsw_bbox$xmax), 
           ylim = c(se_nsw_bbox$ymin, se_nsw_bbox$ymax)) +
  theme_minimal()
```
:::

Now that we have greater glider observations over the period of time and area we're interested in, classified by pre or post fire, we can start pulling in our raster data for our model.

# Spatial data

Greater glider distribution is largely determined by availability of suitable habitat (tree cover and hollow bearing trees), elevation and climate data (precipitation and temperature).

We will need to load quite a few raster files[^1]---five in total. Four of these raster layers provide geographic or environmental information to predict greater gliders' habitat range. Greater gliders are typically found in eucalypt forests at higher elevations, so with the help of \[previous studies on gliders\](REFSxxx), we've chosen to download the following raster layers:

[^1]: https://www.dbca.wa.gov.au/wildlife-and-ecosystems/fire-and-environment/fire-plants-and-vegetation

1.  Elevation (from the [elevatr package](https://github.com/USEPA/elevatr))
2.  Tree cover (from [Global Land Analysis & Discovery](https://glad.umd.edu/dataset/global-2010-tree-cover-30-m))
3.  Mean annual temperature (BIO1) (from [CHELSA](https://chelsa-climate.org/))
4.  Annual precipitation (BIO12) (from [CHELSA](https://chelsa-climate.org/))

To help answer our question about bush fire impact, we will also need to download a raster layer which maps the area burnt over the 2019-2020 bush fires:

5.  Extent of the 2019 bushfires (from the [NSW government](https://datasets.seed.nsw.gov.au/dataset/fire-extent-and-severity-mapping-fesm-2019-20))

Each raster layer will need to be wrangled to fit neatly together for later modelling. So, we will perform a common series of modifications to each layer that generally fall into the following steps: **Rename** the layers to something more sensible, **crop** the layer to our study area, **mask** (or remove) the ocean from our layer so that it does not skew our model, and **resample** each layer to the same resolution (so that every layer's grid aligns correctly).


### Elevation

First we'll download elevation data for our defined region using the `{elevatr}` package's handy `get_elev_raster()` function. By passing our bounding box `bbox_sf` to the `locations` argument we can return elevation data (in metres) for our specified area!

Since we’ll be using multiple rasters in this post, we need to establish a "main" raster: one that defines our coordinate reference system (CRS) and resolution. The elevation raster has the coarsest resolution, so we'll use it as our reference for aligning all other rasters.

```{r}
#| cache: true
#| warning: false
#| output: false
# Download elevation raster
elevation_data <- get_elev_raster(locations = bbox_sf, 
                                  z = 9, 
                                  prj = "EPSG:4326")

# Remove raster information outside of the aus land boundary
elevation_aligned <- elevation_data |>
  terra::rast() |>      # convert to SpatRaster class
  terra::mask(aus) |>   # remove information outside of aus boundary
  terra::crop(bbox_ext) # crop layer to bbox

# Rename layer for simplicity
# colname <- names(elevation_aligned)
names(elevation_aligned) <- "elevation"

```


### Tree cover

Next we'll download tree cover data. This tree cover raster layer contains satellite data from [Hansen et al (2010)](https://glad.umd.edu/dataset/global-2010-tree-cover-30-m) where tree cover is recorded as a percentage (`0` = no cover and `100` = complete tree cover). 

Tree cover data is divided in tiles of 10 x 10 latitude/longitude. Because our study area crosses over two tiles (`30S_150` and `30S_140`), we will need to download and stitch together two rasters. We can then crop them down to our specified area. 

Files are held on this the [Global Land Analysis and Discovery website](). Navigate to the url under the **Data Links** subheading, then click on the relevant data links to download. The two file names we are interested in are: `treecover2010_30S_140E.tif` and `treecover2010_30S_150E.tif`.

You can alternatively use the following code chunk to download files:

```{r}
#| eval: false
download.file("https://glad.umd.edu/Potapov/TCC_2010/treecover2010_30S_140E.tif", destfile="treecover2010_30S_140E.tif")
download.file("https://glad.umd.edu/Potapov/TCC_2010/treecover2010_30S_150E.tif", destfile="treecover2010_30S_150E.tif")
```

Let's load our files into R as rasters. 

```{r}
#| cache: true
#| echo: false
#| warning: false
#| message: false
# Load the rasters
tree_cover_150 <- terra::rast(here("posts", "data", "tree-cover", "treecover2010_30S_150E.tif"))
tree_cover_140 <- terra::rast(here("posts", "data", "tree-cover", "treecover2010_30S_140E.tif"))
```

```{r}
#| eval: false
# Load the raster
tree_cover_150 <- terra::rast(here("treecover2010_30S_150E.tif"))
tree_cover_140 <- terra::rast(here("treecover2010_30S_140E.tif"))
```

Now we can crop them to our study area and merge them together.

```{r}
#| warning: false
#| output: false
# Crop to bbox
tree_cover_150_cropped <- tree_cover_150 |>
  terra::crop(bbox_ext)

tree_cover_140_cropped <- tree_cover_140 |>
  terra::crop(bbox_ext)

# Merge
tree_cover <- merge(tree_cover_150_cropped, tree_cover_140_cropped)

# Rename for simplicity
names(tree_cover) <- "treecover"
```

:::{.callout-important}
##Best practice 

When working with spatial data we tend to use up a lot of memory! That's a big reason why we are performing these cropping steps, so that we can use up the least amount of memory necessary to get our model to function. Because of this, after we have stitched our two rasters into our composite `tree_cover_2010` raster, we can safely delete the other two as we will no longer require them.

```{r}
#| cache: true
# We can now safely delete the first two raster files to save memory
rm(tree_cover_140); rm(tree_cover_150)
```

:::

Let's view the data in `tree_cover`.

::: aside

```{r}
#| cache: true
#| warning: false
#| echo: false
ggplot() +
  geom_spatraster(data = tree_cover, aes(fill = treecover)) +
  scale_fill_viridis_c(direction = -1, begin = 0.8, end = 0.1) +
  labs(title = "Tree Cover in South-East NSW",
       fill = "Tree Cover (%)") +
  theme_minimal()
```
:::

### Temperature & precipitation

Next we’ll download two bioclimatic raster layers from [CHELSA](https://chelsa-climate.org/). CHELSA hosts climate projections at high resolutions intended for ecological use ([here's the paper about it](https://doi.org/10.1038/sdata.2017.122)). Climate projections extend from 1981 to 2100. Vegetation that greater gliders inhabit is sensitive to temperature and precipitation changes, so we decided to use climate projections for 2011-2040 for the following two climate variables: 

  * BIO1: Mean Annual Temperature
  * BIO12: Annual Precipitation

To download these layers on the [CHELSA website](https://chelsa-climate.org/), click on **Downloads** in the top bar --> under version 2.1 click the **Download** button --> then navigate to **GLOBAL/** --> **climatologies/** --> **UKESM1-0-LL** --> **ssp370/** --> **bio/**. Then select the files with names beginning with `CHELSA_bio1_2011-2040` and `CHELSA_bio12_2011-2040`. 

Alternatively, you can use the code below to download these files.

```{r}
#| eval: false

# Download our two raster files
download.file("https://os.zhdk.cloud.switch.ch/chelsav2/GLOBAL/climatologies/2011-2040/UKESM1-0-LL/ssp370/bio/CHELSA_bio1_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif",
              destfile="CHELSA_bio1_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif", mode="wb")  

download.file("https://os.zhdk.cloud.switch.ch/chelsav2/GLOBAL/climatologies/2011-2040/UKESM1-0-LL/ssp370/bio/CHELSA_bio12_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif",
              destfile="CHELSA_bio12_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif", mode="wb") 
```


```{r}
#| cache: true
#| warning: false
#| message: false
#| echo: false
temp <- rast(
  here("posts",
       "data",
       "CHELSA_bioclim",
       "CHELSA_bio1_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif"
       ))
precip <- rast(
  here("posts",
       "data",
       "CHELSA_bioclim",
       "CHELSA_bio12_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif"
       ))
```

Let's load our files into R as rasters.

```{r}
#| eval: false
temp <- rast("CHELSA_bio1_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif")
precip <- rast("CHELSA_bio12_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif")
```


```{r}
# mask and crop to study area
temp <- temp |>
  terra::mask(aus) |>   # remove oceans
  terra::crop(bbox_ext) # crop to bbox

precip <- precip |>
  terra::mask(aus) |>   # remove oceans
  terra::crop(bbox_ext) # crop to bbox

# Rename for simplicity
names(temp) <- "temp_bio1"
names(precip) <- "precip_bio12"
```

Let's view the data in `temp` and `precip`.

::: aside
```{r}
#| cache: true
#| echo: false
#| message: false
#| warning: false
# Temperature
ggplot() +
  geom_spatraster(data = temp, aes(fill = temp_bio1)) +
  scale_fill_viridis_c(option = "inferno", 
                       end = 0.9, 
                       na.value = "transparent") +
  labs(title = "Mean Annual Temperature (BIO1)",
       fill = "°C") +
  theme_minimal()

# Precipitation
ggplot() +
  geom_spatraster(data = precip, aes(fill = precip_bio12)) +
  scale_fill_viridis_c(option = "mako", 
                       direction = -1, 
                       begin = 0.1, 
                       na.value = "transparent") +
  labs(title = "Annual Precipitation (BIO12)",
       fill = "mm") +
  theme_minimal()
```
:::


### Fire extent

Finally, we will download a raster layer of burnt area due to 2019-2020 Black Summer Bushfires across New South Wales. The NSW Government’s [Fire Extent and Severity Mapping (FESM) 2019/20 dataset](https://datasets.seed.nsw.gov.au/dataset/fire-extent-and-severity-mapping-fesm-2019-20) contains information on the extent and severity of burnt areas across the state. 

To download, navigate to the [NSW Government website](https://datasets.seed.nsw.gov.au/dataset/fire-extent-and-severity-mapping-fesm-2019-20) --> click on **Dataset Packages** --> then select the download icon next to **FESM v3-data in IMG and TIFF format**. Save this zip folder in your working directory and uncompress the folder.

:::{.callout-important collapse="true"}
## Big zip folder
While the download itself is only several hundred megabytes, when uncompressed, the .tif file is *very* large (10.3 GB). Please keep this in mind before downloading!
:::

Once downloaded, let's load the uncompressed fire extent layer into R as a raster.


```{r}
#| cache: true
#| warning: false
#| message: false
#| echo: false
# Load raster
fire_extent_cropped <- rast(here("posts",
                         "data", 
                         "fire_extent",
                         "cvmsre_NSW_20192020_ag1l0.tif"))

fire_extent <- rast(here("posts", "2025-02-07_greater-gliders", "cvmsre_NSW_20192020_ag1l0.tif"))
```

```{r}
#| eval: false
# Load raster
fire_extent <- rast("cvmsre_NSW_20192020_ag1l0.tif")
```

This file is pretty huge and it's in the wrong projection, which you can see under `coord. ref` when we view the object. Our desired CRS is `WGS84`/`EPSG:4326`, but this raster is projected using CRS `GDA_94_Lambert`, which affects the longitude and latitude coordinates. 

```{r}
fire_extent
```


This poses an issue for us. Reprojecting the entire file to `WGS84` first like we have for other rasters will take up a lot of processing time and memory.

To save time and memory, we'll need to crop `fire_extent` to our desired study area first. To do that, let's take our original `bbox_ext` object and reproject it to the CRS of `fire_extent`. We can then use that reprojected bounding box, `bbox_ext_gda94`, to crop `fire_extent` to a much smaller area. Finally, we can reproject our `fire_extent_cropped` object to the correct projection and crop again just to be certain our layer matches our other layers.

:::{.callout-note}
## This process takes a while
Note that this series of steps to crop `fire_extent` takes ~5 minutes to run.
:::

First let's convert our bounding box `bbox_ext`, convert it to a polygon and reproject that polygon to use the CRS of `fire_extent`.

```{r}
#| eval: false
# Convert bbox to polygon with new projection that matches fire_extent
bbox_ext_gda94 <- bbox_ext |> 
  terra::as.polygons(
    crs = gliders_sf           # set crs to match glider data
    ) |>
  terra::project(fire_extent)  # reproject crs to match fire_extent

bbox_ext_gda94
```

Now we can use our new bounding box `bbox_ext_gda94` to crop `fire_extent` to our study area, then reproject it to our desired CRS `WGS84`.

# START HERE: Need to make sure this reprojection thing works

```{r}
#| eval: false
# Crop fire_extent using the reprojected bbox, then reproject to WGS84
fire_extent_cropped <- fire_extent |>
  terra::crop(bbox_ext_gda94) |>
  terra::project(crs(gliders_sf))   # reproject to match glider data

fire_extent_cropped
```

Finally, we'll crop it again to make sure the `extent` matches our other raster files. You'll see the `extent` slightly but noticeably changes.

```{r}
#| eval: false
fire_extent_cropped <- fire_extent_cropped |>
  terra::crop(bbox_ext)

fire_extent_cropped
```

We can also mask out the ocean and rename the raster layer like we did for other layers.

```{r}
#| warning: false
# Remove ocean
fire_extent_cropped <- fire_extent_cropped |>
    terra::mask(aus)

# Rename for simplicity
names(fire_extent) <- "fire_extent"
```

Let's view the data in `fire_extent`.

```{r}
#| cache: true
#| warning: false
#| message: false
#| echo: false
ggplot() +
  geom_spatraster(data = fire_extent_cropped, aes(fill = fire_extent)) +
  scale_fill_whitebox_c(palette = "muted",
                        na.value = NA)  +
  labs(title = "Fire Severity in South-East NSW (2019-2020)",
       fill = "Severity") +
  theme_minimal()
```


## Match resolution

As a final important step, we need to make sure all of our layers are projected at the same resolution. When working with spatial data for modelling, it is critical that rasters are in the same dimensions, resolution and projection. Otherwise, the raster pixels won't align with each other and we can't make any predictions! The resolution will typically match to the layer with the lowest resolution. In our case, this is `elevation_aligned` layer.

```{r}
elevation_aligned
```

Let's resample our data to match the resolution of `elevation_aligned`.

```{r}
# Resample our tree cover to the resolution of the elevation data
tree_cover <- terra::resample(tree_cover, elevation_aligned)
temp <- terra::resample(temp, elevation_aligned)
precip <- terra::resample(precip, elevation_aligned)
fire_extent <- terra::resample(fire_extent, elevation_aligned)
# fire_extent <- round(fire_extent) 
```


## Burnt severity

Finally, we need to add a new column to our greater glider observations data `gliders_sf` containing the fire severity category at each glider's recorded location.

To achieve this, let's extract the fire severity values from the processed fire extent raster at the coordinates where Greater Gliders were observed.

```{r}
gliders_sf$burnt <- terra::extract(fire_extent, vect(gliders_sf), ID = FALSE)
```

<details>

<summary>Fire severity values</summary>

The `fire_extent` dataset categorises fire severity using the following values:

-   0 - Unburnt (0% canopy and understory burnt)
-   1 - Reserved (Experimental category, is not used in raster right now)
-   2 - Low (\> 10% burnt upderstory, \>90% green canopy)
-   3 - Moderate (20-90% canopy scorch)
-   4 - High (\> 90% canopy scorched, \<50% canopy consumed)
-   5 - Extreme (\>50% canopy biomass consumed)

</details>



### Combine rasters

To begin we need to combine all the raster datasets we've prepared so far. This will allow our model to extract environmental values at each Glider occurrence (or absence).

```{r}
#| cache: true
#| warning: false
combined_rasters <- c(elevation_aligned, temp, precip, fire_extent_cropped, tree_cover)
```

Now we have a single raster with multiple layers detailing:

-   Elevation
-   Mean annual temperature (BIO1)
-   Annual precipitation (BIO12)
-   Extent of the 2019 bushfires
-   Tree cover

Now we have all our rasters ready to go, we can begin the modelling process!

# Building our model

If you're new to species distribution modeling (SDM) or want a deeper dive into the details, check out this ALA Labs post: [An introduction to species distribution modelling using {tidysdm} & {tidymodels}](https://labs.ala.org.au/posts/2024-04-30_sdm-tidymodels/). 

This post will use the same workflow but spend less time explaining how species distribution modelling works and apply these concepts to investigate a research question statistically.

### Thinning

First, we will thin our data so that there is only one glider observation in any individual grid cell, so that each grid cell will contain a binary "present" vs "absent", using `thin_by_cell()`.

```{r}
#| cache: true
#| warning: false
#| output: false
gliders_thin <- tidysdm::thin_by_cell(gliders_sf, 
                                      raster = combined_rasters)

```

<!-- PLOT here as an aside to show the result?-->

### Pseudo-absences

Our glider observations from the ALA are presence-only (they only provide information about the conditions of when a glider was observed but no information about when gliders *aren't* observed). So, we need to generate pseudo-absences (aka background points) for our model to use to calculate the *probability* that a greater glider is in a given cell, and what variables predict presence/absence.

In order to answer our question of whether greater glider observations were affected before or after the 2019/2020 bush fires, we have categorised our glider observations into either `pre_fire` or `post_fire`. In order to incorporate this into our statistical models, we will also need pseudo-absences for categorised as `pre_fire` and `post_fire`. This again will allow our model to generate a `probability` of presence.

As a simple way to do this, let's randomly assign 50% of the pseudo-absence records to the `pre_fire` period and the other 50% to the `post-fire` period. This split ensures that our model has the same number of pseudo-absence data for both timeframes, but taken as a random sample.

Once the pseudo-absence records are generated, we will reassign the correct pre- and post-fire values to our actual presence observations in the dataset.

```{r}
# Generate pseudo-absences
gliders_pseudoabs <- tidysdm::sample_pseudoabs(
  gliders_thin,
  n = 3 * nrow(combined_rasters), 
  raster = combined_rasters,
  method = c("dist_min", tidysdm::km2m(5))
  )

# Generate random categories for each pseudo-absence
gliders_pseudoabs <- gliders_pseudoabs |>
  mutate(
    fire_period = sample(c("pre_fire", "post_fire"), 
                         size = nrow(gliders_pseudoabs),
                         replace = TRUE)
    ) |>
  # Extract tree cover, elevation and climate values for pseudoabs points
  bind_cols(
    terra::extract(combined_rasters,
                   gliders_pseudoabs,
                   ID = FALSE)
    )

# Get the real categories from our original data
real_categories <- gliders_thin |>
  select(fire_period) |>
  mutate(class = "presence")

# Join the real fire_period category from the original records to overwrite our fake ones
gliders_events <- gliders_events |>
  st_join(real_categories |> select(fire_period), left = TRUE) |>
  mutate(
    fire_period = coalesce(fire_period.y, fire_period.x) # Overwrite only if match found
    ) |>  
  select(-fire_period.x, -fire_period.y)  # Remove redundant columns


# Remove any NA records 
gliders_events <- na.omit(gliders_events)
```

Let's select our predictor variables to filter out all the unnecessary columns in our data frame. We will then turn the pre/post fire column into a numeric value for our modelling and statitical analysis later.

```{r}
#| cache: true
# Select our predictor variables
predictor_vars <- c("elevation", "bio1", "bio12", "fire_extent", "treecover")

# Select all the columns we're interested in
gliders_filtered <- 
  gliders_events |> 
  select(all_of(c(predictor_vars, "class", "fire_period")))

# Change fire period into a numeric value 
gliders_filtered <- gliders_filtered |>
  mutate(fire_period = if_else(fire_period == "post_fire", 1, -1))
gliders_filtered$fire_period <- as.numeric(gliders_filtered$fire_period)

```

# Tuning and Running the Model

Now that we've cleaned and prepared our data, we're ready to start modelling!

Rather than using a single mdoel, we'll be training multiple models, investigating their relative performance, and then combining them into an ensemble model that will help make our final prediction a bit more robust.

### Training and testing

Firstly let's split our glider presence/pseudoabsence data into training and testing datasets. This allows us to train the model on one subset of the data, while evaluating it's performance on the other subset of the data. In order to improve our model and try and prevent overfitting, we'll use spatial block cross-validation. Spatial block cross validation divides the study area into spatial blocks and ensures our model is tested on spatially independent data, making it's predictions more general.

```{r}
#| cache: true
#| warning: false
#| output: true
# set training and testing data
set.seed(100)

# Create training and testing datasets
gliders_split <- 
  gliders_filtered |>
  initial_split()
gliders_split

gliders_train <- training(gliders_split)
gliders_test <- testing(gliders_split)

# Perform Cross validation
gliders_cv <- spatial_block_cv(gliders_train, v = 5)
```

Now we're going to create a new recipe for our model, this will explain how our response variable `class` (presence or absence) is effected by each predictor variable (`elevation`, `bio1`, `bio12`, `treecover`, `fire_extent` and `fire_period`).

```{r}
#| cache: true
#| warning: false
#| output: false
gliders_recipe <- recipe(
  gliders_train, 
  formula = class ~ elevation + bio1 + bio12 + treecover + fire_extent + fire_period
)

```

Rather than relying on a single model, we'll train up four and compare their performance. These models are:

1.  Generalised Linear Model
2.  Random Forest
3.  Gradient Boosting Machine
4.  Maximum entropy

We will later build an ensemble of the best models.

```{r}
#| cache: true
#| warning: false
#| output: false

gliders_models <-
  workflow_set(
    preproc = list(default = gliders_recipe), # Use the same recipe for all
    models = list(
      glm = sdm_spec_glm(),        # Generalised Linear Model
      rf = sdm_spec_rf(),          # Random Forest
      gbm = sdm_spec_boost_tree(), # Gradient Boosting Machine
      maxent = sdm_spec_maxent()   # Maximum Entropy
    ),
    cross = TRUE 
  ) |>
  option_add(control = control_ensemble_grid())

```

Now we'll tune our models using the cross validation blocks we generated earlier. This step helps us find the best model parameters by testing different variations and selecting the ones that perform best. In this plot we will see the three performance metrics (boyce_cont, roc_auc and tss_max). To keep it high level, the x-axis represents the ranking of different workflows from best to worst, and the y axis represents the values for each metric, with higher values indicating better model performance.

```{r}
#| cache: true
#| warning: false
#| output: false
set.seed(9999)

# Tune the model using cross validation
gliders_models_tune <-
  gliders_models |>
  workflow_map("tune_grid",
               resamples = gliders_cv,     # Use our cross-validation blocks for tuning
               grid = 6,                   # number of tuning iterations
               metrics = sdm_metric_set(), # Evaluate model performance
               verbose = TRUE,
               control = stacks::control_stack_grid()
  )
```

```{r}
#| cache: true
#| warning: false
#| output: true
autoplot(gliders_models_tune)
```

Because we are using a collection of models, we can use stacks to combine the best models into an ensemble model that will help improve accuracy and generalisation. We will see a plot at the end detailing how much each model is contributing to the ensemble.

```{r}
#| cache: true
#| warning: false
#| output: true
set.seed(98765)

gliders_stacked <- 
  stacks() |>                                # initialize the model stack
  add_candidates(gliders_models_tune) |> #  Add the tuned models
  blend_predictions() |>                     # Blend their predictions
  fit_members()                              # Fit the final model

# Visualise each models contribution
autoplot(gliders_stacked, type = "weights")
```

Now that we have our stacked ensemble model, it’s time to see how well it performs on unseen test data. Our 3 metrics will print out a value

-   boyce_cont: A value closee to 1.0 tells us the model is making reliable predictions
-   roc_auc: A value at 0.5 tells us the model is no better than random chance, greater than 0.7 tells us it's performing well.
-   tss_max: Ranges from -1 (poor) to 1 (perfect) for predictive power.

```{r}
#| cache: true
#| warning: false
#| output: true

# Predict probability of presence 
gliders_test_predictions <-
  gliders_test %>%
  bind_cols(predict(gliders_stacked, ., 
                    type = "prob", 
                    save_pred = TRUE))

# Evaluate performance
gliders_test_predictions |> 
  sdm_metric_set()(truth = class, .pred_presence)

# Give a final classification
gliders_test_predictions_class <-
  gliders_test %>%
  bind_cols(predict(gliders_stacked, ., 
                    type = "class", 
                    save_pred = TRUE))

```

Our high boyce index (0.971) and roc_auc (0.966) tell us our model is well-calibrated, with a tss_max of 0.814 telling us we have good predictive power.

# Generating the Final Raster

Now we've got a trained and tested model, we can now *almost* finally make our predictions!

The last step we need to do is create a pseudo "fire-period" raster. We need this raster because our model only evaluates the impact of `fire_period` on the glider records, we didn't have the need for a raster of fire_period previously, however because we are producing a final raster, we *DO* need a raster that we can sample from in order to produce that prediction.

```{r}
#| cache: true
#| messages: false
#| warning: false

# Create an empty raster with the same dimensions as our combined raster
presence_raster <- rast(combined_rasters, nlyr = 1)
values(presence_raster) <- NA 

# Rename the layer for clarity
names(presence_raster) <- str_replace_all(names(presence_raster), 
                                              "lyr1", 
                                              "fire_period")


# Convert glider observations into a vector to be sampled
gliders_vect <- vect(gliders_filtered)

# Rasterize the fire period from the glider points
fire_period_raster <- rasterize(gliders_vect, presence_raster, field = "fire_period", fun = "first")
names(fire_period_raster) <- str_replace_all(names(fire_period_raster), 
                                          "first", 
                                          "fire_period")


# Assign pre/post values to the cells
# Pre-fire
fire_period_raster[is.na(fire_period_raster) & (fire_extent == 0 | fire_extent == 1)] <- -1 
# Post-fire
fire_period_raster[is.na(fire_period_raster) & !(fire_extent == 0 | fire_extent == 1)] <- 1 

# Add this fire period raster into our raster stack
combined_rasters <- c(combined_rasters, fire_period_raster)
```

Now we are finally ready to perform our final prediction!

```{r}
#| cache: true
#| warning: false
#| output: false

# Perform our final prediction!
prediction_present <- predict_raster(gliders_stacked, 
                                     combined_rasters, 
                                     type = "prob",
                                     wopt = list(steps=32))

```

### The Final Plot

Now let's plot it, and have a look at our map detailing habitat suitability for our gliders!

```{r}
#| cache: true
#| warning: false
#| output: true
ggplot() +
  geom_spatraster(data = prediction_present, 
                  aes(fill = .pred_presence)) +
  scale_fill_whitebox_c(palette = "viridi",
                        na.value = NA) +
  guides(fill = guide_colorbar(title="Relative\nHabitat\nSuitability")) +
  labs(title="Predicted Suitable Habitat for Greater Gliders", subtitle = "Elevation, tree cover, mean annual temp, annual precipitation and fire events.") +
  pilot::theme_pilot(grid="hv") +
  theme(
    legend.text = element_text(hjust = 0.5)) +
  theme_minimal()
```

As you can see we have a very nice map showing us areas of suitable habitat, and unsuitable habitat. Now we have this, let's dive in and see what impact the bushfires have had on suitable habitat for the gliders!

# Impact of the bushfires: A statistical analysis

To perform our analysis we will simple construct a GLM where the predicted presence (`.pred_presence`) is our response variable and all our other variables are the predictor variables.

```{r}
#| cache: true
#| warning: false
# Join the prediction raster and our other rasters
final_raster <- c(prediction_present, combined_rasters)

# Construct a GLM 
lm <- glm(.pred_presence ~ elevation + bio1 + bio12 + fire_extent + treecover + fire_period, data = final_raster)
summary(lm)

```

### Breaking down the stats

This output can be a bit overwhelming, so let's look at the key takeaways:

The estimate tells us how much each variable increases or decreases the likelihood of finding a glider:

-   Positive estimate: Higher values of this variable **increase** the likelihood of glider presence.
-   Negative estimate: Higher values of this variable **decrease** the likelihood of glider presence.
-   Larger absolute values mean a stronger influence.

The effect size (t-value) tells us how strong each variable is on the final prediction. The absolute value of the effect size tells us it’s strength, and whether it’s positive or negative tells us whether or not it’s associated with increased glider predicition chance, or decreased glider prediction chance.

The standard error tells us how much variance is in each value, our numbers are very small, so we don't have much variance at all!

The p-values are all significant, but that's to be expected (we specifically told the model to use these variables to predict presence, they by definition will be significant).

# Conclusion

So what does our model actually say about Greater Glider distribution in South-East NSW?

1.  Tree cover is critical - Tree cover is the strongest predictor of glider presence.

2.  Elevation and temperature are big predictors - Greater Gliders appear to prefer higher elevations and (relative to the surrounds) warmer annual temperatures.

3.  Rainfall plays a part - More precipitation increases the likelihood of glider presence, which is not a big surprise considering the relationship between precipitation and tree cover, and precipitation and elevation!

But from our research we already had some idea of these relationships, now let's do the interesting part and look at the impact of the fires.

Severe fires have a negative impact in glider distribution - The **more extreme** the fire events in the 2019 bushfire season, the **stronger the negative impact** on glider presence.

The pre vs post-fire effect is interesting. We saw a slight increase in post-fire glider presence in our model. This could be due to a number of factors, perhaps new tree hollows were formed in the fires, perhaps there increased survey efforts, or surviving gliders being more visible due to reduced canopy cover, gliders moving into less burnt areas, or even just more data entering into the ALA? There are so many questions here that are difficult to answer with the data we have on hand. It warrants further investigation.

This model gives us a solid look at how Southern Greater Gliders were affected by the Black Sumemr fires. Our model suggests that severe fires disrupted Glider habitat and had a strong negative impact. This is supported by research that has been done in the wake of the fires on greater gliders[^2].

[^2]: https://www.publish.csiro.au/wr/WR23129

### Change in habitat suitability for fire affected regions

As a final extra, let's create a map looking at the difference in habitat suitability for pre and post fire regions. To do this we will generate two separate models, those with data before and those with data after and subtract the two habitat suitability maps from each other to see what has changed due to fire!

<details>

<summary style="color: #E06E53;">

Expand for comparison map

</summary>

```{r}
#| cache: true
#| warning: false
#| message: false

# Collect all greater glider records in that period
gliders_2019 <- galah_call() |>
  identify("Petauroides volans") |>
  filter(year >= 2014 & year < 2020) |>
  galah_apply_profile(ALA) |>
  galah_geolocate(se_nsw_bbox, type = "bbox") |>
  atlas_occurrences()

gliders_2019 <- gliders_2019 |>
  mutate(year = year(eventDate),             # Extract the year
         month = month(eventDate))

gliders_sf_2019 <- gliders_2019 |>
  st_as_sf(coords = c("decimalLongitude", "decimalLatitude")) |>
  st_set_crs(4326)

gliders_sf_2019 <- gliders_2019 |>
  st_as_sf(coords = c("decimalLongitude", "decimalLatitude")) |>
  st_set_crs(4326)


gliders_thin <- tidysdm::thin_by_cell(gliders_sf_2019, 
                                      raster = combined_rasters)

gliders_pseudoabs <- tidysdm::sample_pseudoabs(
  gliders_thin,
  n = 3 * nrow(combined_rasters),
  raster = combined_rasters,
  method = c("dist_min", km2m(5)))


gliders_events_2019 <- gliders_pseudoabs |> 
  bind_cols(
    terra::extract(combined_rasters,
                   gliders_pseudoabs,
                   ID = FALSE))



gliders_events_2019 <- na.omit(gliders_events_2019)

predictor_vars <- c("elevation", "bio1", "bio12", "treecover")

gliders_filtered_2019 <- 
  gliders_events_2019 |> 
  select(all_of(c(predictor_vars, "class")))


# set training and testing data
set.seed(100)

gliders_split_2019 <- 
  gliders_filtered_2019 |>
  initial_split()

gliders_train <- training(gliders_split_2019)
gliders_test <- testing(gliders_split_2019)
gliders_cv <- spatial_block_cv(gliders_train, v = 5)


gliders_recipe <- recipe(
  gliders_train, 
  formula = class ~ elevation + bio1 + bio12 + treecover 
)

gliders_models <-
  # create the workflow_set
  workflow_set(
    preproc = list(default = gliders_recipe),
    models = list(
      glm = sdm_spec_glm(),        # the standard glm specs
      rf = sdm_spec_rf(),          # rf specs with tuning
      gbm = sdm_spec_boost_tree(), # boosted tree model (gbm) specs with tuning
      maxent = sdm_spec_maxent()   # maxent specs with tuning
    ),
    cross = TRUE # make all combinations of preproc and models
  ) |>
  # tweak controls to store information needed later to create the ensemble
  option_add(control = control_ensemble_grid())


set.seed(2345678) # for reproducability

gliders_models_tune <-
  gliders_models |>
  workflow_map("tune_grid",
               resamples = gliders_cv, 
               grid = 6,                   # increase for more iterations
               metrics = sdm_metric_set(),
               verbose = TRUE,
               control = stacks::control_stack_grid()
  )



set.seed(123456)

gliders_stacked <- 
  stacks() |>                                # initialize the stack
  add_candidates(gliders_models_tune) |> # add candidate members
  blend_predictions() |>                     # determine how to combine their predictions
  fit_members()                              # fit the candidates with nonzero stacking coefficients

gliders_test_predictions_2019 <-
  gliders_test %>%
  bind_cols(predict(gliders_stacked, ., 
                    type = "prob", 
                    save_pred = TRUE))


# predict class
gliders_test_predictions_class_2019 <-
  gliders_test %>%
  bind_cols(predict(gliders_stacked, ., 
                    type = "class", 
                    save_pred = TRUE))


prediction_present_2019 <- predict_raster(gliders_stacked, 
                                     combined_rasters, 
                                     type = "prob",
                                     wopt = list(steps=32))



#####Post fire
# Collect all greater glider records in that period
gliders_2024 <- galah_call() |>
  identify("Petauroides volans") |>
  filter(year > 2019 & year <= 2024) |>
  galah_apply_profile(ALA) |>
  galah_geolocate(se_nsw_bbox, type = "bbox") |>
  atlas_occurrences()

gliders_2024 <- gliders_2024|>
  mutate(year = year(eventDate),             # Extract the year
         month = month(eventDate))

gliders_sf_2024 <- gliders_2024|>
  st_as_sf(coords = c("decimalLongitude", "decimalLatitude")) |>
  st_set_crs(4326)



gliders_2024$burnt <- terra::extract(fire_extent, vect(gliders_sf_2024), ID = FALSE)



gliders_thin <- tidysdm::thin_by_cell(gliders_sf_2024, 
                                      raster = combined_rasters)

gliders_pseudoabs <- tidysdm::sample_pseudoabs(
  gliders_thin,
  n = 3 * nrow(combined_rasters),
  raster = combined_rasters,
  method = c("dist_min", km2m(5)))


gliders_events_2024 <- gliders_pseudoabs |> 
  bind_cols(
    terra::extract(combined_rasters,
                   gliders_pseudoabs,
                   ID = FALSE))

gliders_events_2024 <- na.omit(gliders_events_2024)

predictor_vars <- c("elevation", "bio1", "bio12", "treecover", "fire_extent")

gliders_filtered_2024 <- 
  gliders_events_2024 |> 
  select(all_of(c(predictor_vars, "class")))



combined_rasters <- combined_rasters[[predictor_vars]]
# set training and testing data
set.seed(100)

gliders_split_2024 <- 
  gliders_filtered_2024 |>
  initial_split()

gliders_train <- training(gliders_split_2024)
gliders_test <- testing(gliders_split_2024)

gliders_cv <- spatial_block_cv(gliders_train, v = 5)

gliders_recipe <- recipe(
  gliders_train, 
  formula = class ~ elevation + bio1 + bio12 + treecover + fire_extent
)

gliders_models <-
  # create the workflow_set
  workflow_set(
    preproc = list(default = gliders_recipe),
    models = list(
      glm = sdm_spec_glm(),        # the standard glm specs
      rf = sdm_spec_rf(),          # rf specs with tuning
      gbm = sdm_spec_boost_tree(), # boosted tree model (gbm) specs with tuning
      maxent = sdm_spec_maxent()   # maxent specs with tuning
    ),
    cross = TRUE # make all combinations of preproc and models
  ) |>
  # tweak controls to store information needed later to create the ensemble
  option_add(control = control_ensemble_grid())

set.seed(2345678) # for reproducability



gliders_models_tune <-
  gliders_models |>
  workflow_map("tune_grid",
               resamples = gliders_cv, 
               grid = 6,                   # increase for more iterations
               metrics = sdm_metric_set(),
               verbose = TRUE,
               control = stacks::control_stack_grid()
  )

set.seed(123456)

gliders_stacked <- 
  stacks() |>                                # initialize the stack
  add_candidates(gliders_models_tune) |> # add candidate members
  blend_predictions() |>                     # determine how to combine their predictions
  fit_members()                              # fit the candidates with nonzero stacking coefficients


gliders_test_predictions_2024 <-
  gliders_test %>%
  bind_cols(predict(gliders_stacked, ., 
                    type = "prob", 
                    save_pred = TRUE))


# predict class
gliders_test_predictions_class_2024<-
  gliders_test %>%
  bind_cols(predict(gliders_stacked, ., 
                    type = "class", 
                    save_pred = TRUE))



prediction_present_2024 <- predict_raster(gliders_stacked, 
                                         combined_rasters, 
                                         type = "prob",
                                         wopt = list(steps=32))

habitat_diff <- prediction_present_2024 - prediction_present_2019

# Only select regions where fire has impacted to get the difference in habitat suitability
fire_mask <- (fire_extent >= 2) & (fire_extent <= 5)
intersect_raster <- mask(habitat_diff, fire_mask, maskvalue=0)


ggplot() +
  geom_spatraster(data = intersect_raster, 
                  aes(fill = .pred_presence)) +
  scale_fill_whitebox_c(palette = "muted", direction = -1,
                        na.value = NA) +
  guides(fill = guide_colorbar(title="\nHabitat\nSuitability\nDifference")) +
  labs(title="Difference in predicted habitat suitability for fire impacted areas") +
  pilot::theme_pilot(grid="hv") +
  theme(
    legend.text = element_text(hjust = 0.5)) +
  theme_minimal()


```

</details>

<details>

<summary style="color: #E06E53;">

Expand for session info

</summary>

```{r, echo = FALSE}
#| cache: true
#| warning: false
library(sessioninfo)
# save the session info as an object
pkg_sesh <- session_info(pkgs = "attached")
# print it out
pkg_sesh
```

</details>

::::::::::::: :::::::::::::::
