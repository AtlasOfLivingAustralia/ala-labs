---
title: "Modelling the Impact of the 2019 Bush Fires on Greater Glider (Petauroides volans) Distribution in Southern NSW"
description: |
  Bushfires etc.
author:
  - name: "Jarod Wright"
  - name: "Dax Kellie"
date: "2025-02-10"
title-block-banner: "#B8573E"
toc: true
toc-location: left
toc-depth: 2
categories:
  - Eukaryota
  - Animalia
  - Gliders
  - Bush Fires
  - Maps
  - R
image: sdm-map.png
freeze: true
draft: true
editor_options: 
  chunk_output_type: console
---

```{r}
#| include: false
library(htmltools)
```

<!-- remove metadata section -->

<style>
  #title-block-header.quarto-title-block.default .quarto-title-meta {
      display: none;
  }
</style>

<!-- Author card -->

::: author-card
::: author-card-text
#### Author

Jarod Wright  
[Dax Kellie](https://labs.ala.org.au/about/Kellie_Dax/index.html)  


#### Date

11 February 2025
:::

:::{.row-b layout-ncol="3" style="margin-left: auto; margin-right: auto; margin-top: auto; margin-bottom: auto;"}

:::{.author-card-image style="width: auto; height: 120px; margin-right: auto !important;"}
<img src="https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/jarod.jpg" style="object-fit: cover; border-radius: 50% !important; width: 140px;"></img>

:::

:::{.author-card-image style="width: auto; height: 120px; margin-right: auto;"}
<img src="https://raw.githubusercontent.com/AtlasOfLivingAustralia/ala-labs/main/images/people/dax.jpg" style="object-fit: cover; border-radius: 50% !important; width: 140px;"></img>

:::

:::
:::



:::


<!------------------------ Post starts here ------------------------>

Bushfires are a frequent and natural aspect of Australia’s ecosystems. Our flora and fauna have evolved along side fire , some plants even require fire to germinate and regenerate [source](https://www.dbca.wa.gov.au/wildlife-and-ecosystems/fire-and-environment/fire-plants-and-vegetation). Aboriginal and Torres Strait Islander people have expertly used fire for tens of thousands of years to care for Country, managing vegetation, reducing wildfire risk, and fostering biodiversity [source](https://www.sciencedirect.com/science/article/pii/S0016718521000233)[source](https://www.bushheritage.org.au/what-we-do/our-challenge/fire-management) This deep connection between fire and the environment continues to influence modern land management practices today. The disruption of these practices since colonisation have increased the risk of out of control bushfires due to the build up of fuel loads, and introduction of invasive plants. [source](https://wwf.org.au/blogs/new-study-confirms-indigenous-fire-management-equals-success/)

In 2019-2020 we experienced one of the most catastrophic bushfire seasons on record in Australia, with approximately 19 million hectares burnt and approximatelly 3 billion animals killed or displaced by the fires. [source](https://wwf.org.au/what-we-do/australian-bushfires/). Over 900 species of plant and animals were severely impacted by the fires [source](https://www.nature.com/articles/s41586-024-08174-6).
Of the 19 million hectares burnt in those fires, 12.6 million were primarily forest and bushland.

In this post we will explore the impact of the 2019-2020 bushfires on a population of Greater gliders (*Petauroides volans*), an arboreal, marsupial species found all along the east coast from Australia, from Southern Queensland all the way down into Victoria. They inhabit tall, hollow bearing trees in eucalypt forests. Unfortunately they are increasingly under threat due to habitat destruction, climate change and intense bushfires. To investigate the impact the 2019/20 Bushfires had on Glider distribution in south-est NSW, we will use a species distribution model (SDM) to investigate what impact, if any, they had on the Gliders. We will then use a general linear model to statistically test whether there is a difference in greater glider observations before vs after the 2019-2020 bushfires.


# Background
*Add brief intro of your species and maybe a fun fact. Add some photos of gliders*
<!-- you can find the code to set this up in other articles -->
The Greater Glider (*Petauroides volans*) is Australia’s largest gliding marsupial, found in tall eucalypt forests along the east coast, from Queensland to Victoria. They are an endagered nocturnal, tree-dwelling herbivore that primarily feed on eucalyptus leaves, much like the Koala! They grow up to 1m long from head to tail and glide up to 100 metres through the canopy. Gliders den in hollow bearing trees and can have multiple dens in their home range.


::: figure-caption
Left: [*Petauroides volans* ( Jasmine Zeleny  \| questagame.com CC-BY-NC 3.0 (Au))](https://ala-images.s3.ap-southeast-2.amazonaws.com/store/8/1/c/e/f1141229-d3bd-49e9-8098-a251befbec18/original), Middle: [*Petauroides volans* (timbawden CC-BY-NC 4.0 (Int))](https://ala-images.s3.ap-southeast-2.amazonaws.com/store/d/e/6/b/1c199f82-4320-459f-b2cc-34be6297b6ed/original), Right: [*Petauroides volans* (c_a_critter CC-BY-NC 4.0 (Au))](https://ala-images.s3.ap-southeast-2.amazonaws.com/store/0/2/1/0/8a68399e-d8b9-4154-81c9-9fec68e20120/original)
:::



To begin, we can load some packages.

```{r}
#| warning: false
#| output: false
library(galah)
library(tidyverse)
library(tidymodels) 
library(tidysdm) # devtools::install_github("EvolEcolGroup/tidysdm")
library(terra)
library(tidyterra)
library(here)
library(sf)
library(ozmaps)
library(elevatr)
library(geodata)
library(stacks)
```



### Downloading Greater Glider Data

We're going to be focusing on a region of South-East NSW. Let's establish a bounding box around our area and pull in a map of Australia for later rendering and working with our rasters.
```{r}
#| warning: false
#| output: false
#| echo: false
# define geographic region
se_nsw_bbox <- tibble(
  ymin = -37.5,
  ymax = -35,
  xmin = 148.5,
  xmax = 151
)
# Create a terra extent for modifying the rasters later on
bbox_ext <- terra::ext(
  c(se_nsw_bbox[["xmin"]], 
    se_nsw_bbox[["xmax"]], 
    se_nsw_bbox[["ymin"]], 
    se_nsw_bbox[["ymax"]]
  ))

# Get the outline of Australia
aus <- ozmaps::ozmap_country


# Create an sf object of our bounding box
bbox_sf <- st_as_sf(as.polygons(bbox_ext, crs = "EPSG:4326"))

```

```{r}
#| echo: false
#| warning: false
ggplot() +
  geom_sf(data = ozmaps::ozmap_states, fill = "lightgray", color = "black") +
  geom_sf(data = bbox_sf, fill = NA, color = "red", size = 1) +
  labs(title = "Study Area") +
  coord_sf(xlim = c(147.5, 152.5), 
         ylim = c(-38, -33)) +
  theme_minimal()
```

Now lets download Greater Glider records in a 10-year time period (2014-2024) which captures observations of greater gliders before and after the 2019-2020 bushfires.  
```{r}
#| warning: false
#| output: false
#| echo: false
galah_config(email = "jarod.wright@csiro.au")

gliders <- galah_call() |>
  identify("Petauroides volans") |>
  filter(year >= 2014 & year <= 2024) |>
  galah_apply_profile(ALA) |>
  galah_geolocate(se_nsw_bbox, type = "bbox") |>
  atlas_occurrences()
```


```{r}
#| eval: false

galah_config(email = "your-email-here") # Registered ALA email

# Collect all greater glider records between 2014 and 2024 for the region we defined
gliders <- galah_call() |>
  identify("Petauroides volans") |>
  filter(year >= 2014 & year <= 2024) |>
  galah_apply_profile(ALA) |>
  galah_geolocate(se_nsw_bbox, type = "bbox") |>
  atlas_occurrences()

```
We will also add a new column in that will allow us to to see if a Glider record was seen before or after the fires.

The 26th of October 2019 has been selected as the cut-off as it marks the date when the 2019 bushfires intensified significantly. On this date a lightning strike ignited the Gospers Mountain fire in New South Wales, which became one of the largest forest fires from a single ignition point in Australia's history, ultimately burning approximately 444,000 hectares. This period also saw the emergence of other significant fires, such as those near Port Macquarie, underscoring the escalation of bushfire activity during this time. By selecting October 2019, we aim to capture the onset of these major fire events to assess their impact on the Greater Glider populations effectively

```{r}
#| warning: false
#| output: false
# Classify each glider record as pre or post fire
# Up to and including October 2019 is pre-burnt, all after that are post fire
gliders <- gliders |>
  mutate(fire_period = if_else(eventDate <= as.Date("2019-10-26"), "pre_fire", "post_fire"))

# Create an sf object so we can draw it later
gliders_sf <- gliders |>
  st_as_sf(coords = c("decimalLongitude", "decimalLatitude")) |>
  st_set_crs(4326)

```

Let's have a quick look at our records to see what we're working with so far.
```{r}
#| warning: false
ggplot() +
  geom_sf(data = aus, fill = "lightgray", color = "black") +
  geom_sf(data = gliders_sf, aes(color = fire_period), size = 2, alpha = 0.7) +
  scale_color_manual(values = c("pre_fire" = "blue", "post_fire" = "red")) +
  labs(title = "Greater Glider Observations (2014-2024)",
       color = "Fire Period") +
  coord_sf(xlim = c(se_nsw_bbox$xmin, se_nsw_bbox$xmax), 
           ylim = c(se_nsw_bbox$ymin, se_nsw_bbox$ymax)) +
  theme_minimal()
```

Now we’ve got a nice dataset of Greater Glider observations over a period of time in the area we're interested with, classified by pre or post fire. Now, we’ll start pulling in our raster data to help build up our model.

# Preparing our rasters
TThis post will make heavy use of raster files[^rasters]. 


We'll be downloading several raster layers in order to create a robust model for Greater Gliders. Greater glider distribution is largely determined by availability of suitable habitat (tree cover and hollow bearing trees), elevation and climate data (precipitation and temperature). We will be downloading layers to supply each of these to the model to develop a reasonable prediction surface of Glider habitat. From this we will be able to reasonably investigate the impact that the bushfires had on predicted glider presence. 

We will be downloading [tree cover layers](https://glad.umd.edu/dataset/global-2010-tree-cover-30-m), [elevation layers](https://github.com/USEPA/elevatr), [climate layers](https://chelsa-climate.org/) and [fire extent layers](https://datasets.seed.nsw.gov.au/dataset/fire-extent-and-severity-mapping-fesm-2019-20). 
<!-- You need to briefly introduce the raster layers you are going to download and why they matter. It would be great if you linked to some research that backs up your choices (eg this is usually used in models of gliders [link to article(s)]) -->


### Raster Preparation steps

[^rasters]: Rasters are grids of spatial data, where each pixel contains a value representing the information we're interested in. [Check out this baisc example](https://labs.ala.org.au/posts/2024-04-30_sdm-tidymodels/#download-environmental-data).

For each raster, we will perform a common series of modifications; cropping them to our region of interest, making sure they are all in the same projection and then resampling to make them have the same resolution. 

This process is slightly repetitive, but when working with spatial data for modelling, it is critical that rasters are in the same dimensions, resolution and projection. Otherwise, the raster pixels won't align with each other!

Because of the repetitive nature I won't be detailing the exact steps for each raster (except where they deviate) and will instead lay out the common steps here:

  * Rename the layers to something more sensible
  * Crop them to match our region
  * Mask out the ocean (since Greater Gliders are not great swimmers)
  * Resample them to match our elevation raster resolution

### Download Elevation Raster
The first raster we'll be grabbing is an elevation raster for our defined region, fortunately for us the `{elevatr}` package provides us with the handy `get_elev_raster()` function. When we call it we pass in our bounding box from earlier and get elevation data (in metres) back for our region!

Since we’ll be using multiple rasters in this post, we need to establish a "main" raster: one that defines our coordinate reference system (CRS) and resolution. The elevation raster has the coarsest resolution, so we'll use it as our reference for aligning all other rasters.

```{r}
#| warning: false
#| output: false
# Download the elevation raster
elevation_data <- get_elev_raster(locations = bbox_sf, z = 9, prj = "EPSG:4326")

# Masking allows us to remove raster information outside of the range we pass into
# the mask function. For our model we will use the land boundaries of Australia
elevation_aligned <- elevation_data |>
  terra::mask(aus)

# elevation_aligned is now a RasterLayer, so lets turn it back into a SpatRaster
elevation_aligned <- terra::rast(elevation_aligned)

# Ensure that it's in our desired projection
elevation_aligned <- terra::project(elevation_aligned, "EPSG:4326")

# Crop it down to our bounding box
elevation_aligned <- terra::crop(elevation_aligned, bbox_ext)

# This column is different everytime, but it's always of the format file<UID>
# So we'll just rename it to elevation for simplicities sake
colname <- names(elevation_aligned)
names(elevation_aligned) <- str_replace_all(names(elevation_aligned), 
                                            colname, 
                                            "elevation")

```


### Download Tree Cover Data

Next we'll be downloading our tree cover data. This dataset is in the form of a percentage (0 = no cover, 100 = complete tree cover). Because our data set crosses over two regions, we will be stitching together two rasters that cover central NSW to the east coast, and we will then crop them down to our area of focus.

This tree cover data is satellite data from 2010 by Hansen et al, full details can be found [here](https://glad.umd.edu/dataset/global-2010-tree-cover-30-m).

```{r}
#| eval: false

download.file("https://glad.umd.edu/Potapov/TCC_2010/treecover2010_30S_140E.tif", destfile="treecover2010_30S_140E.tif")

download.file("https://glad.umd.edu/Potapov/TCC_2010/treecover2010_30S_150E.tif", destfile="treecover2010_30S_150E.tif")

```

Now that we have the files, let's perform our common steps for tidying up the rasters.

<!-- You are smartly cropping these layers and then deleting the larger files. I think you need a little description in the text to explain this because it is good practice -->

```{r}
#| warning: false
#| output: false
# Load the raster
tree_cover_rast_150e_2010 <- rast("treecover2010_30S_150E.tif")

# Check the names of the layers in the raster
names(tree_cover_rast_150e_2010)

# In this case we have one layer, and it's titled "Layer_1", which is not very helpful. So we'll change that to a more suitable name
names(tree_cover_rast_150e_2010) <- str_replace_all(names(tree_cover_rast_150e_2010), 
                                                    "Layer_1", 
                                                    "treecover")

# See the change has worked
names(tree_cover_rast_150e_2010)

# Let's repeat the process for the 140E raster
tree_cover_rast_140e_2010 <- rast("treecover2010_30S_140E.tif")

names(tree_cover_rast_140e_2010)
names(tree_cover_rast_140e_2010) <- str_replace_all(names(tree_cover_rast_140e_2010), 
                                                    "Layer_1", 
                                                    "treecover")
names(tree_cover_rast_140e_2010)


# Crop our raster files to our bounding box extent
tree_cover_rast_150e_2010 <- tree_cover_rast_150e_2010 |>
  terra::crop(bbox_ext)
tree_cover_rast_140e_2010 <- tree_cover_rast_140e_2010 |>
  terra::crop(bbox_ext)


# Merge the two rasters into a single raster
tree_cover_2010 <- merge(tree_cover_rast_140e_2010, tree_cover_rast_150e_2010)


# Resample our tree cover to the resolution of the elevation data
tree_cover_2010 <- terra::resample(tree_cover_2010, elevation_aligned)
```
Best practice: When working with spatial data we tend to use up a lot of memory! That's a big reason why we are performing these cropping steps, so that we can use up the least amount of memory necessary to get our model to function. Because of this, after we have stitched our two rasters into our composite `tree_cover_2010` raster, we can safely delete the other two as we will no longer require them.

```{r}
# We can now safely delete the first two raster files to save memory
rm(tree_cover_rast_140e_2010)
rm(tree_cover_rast_150e_2010)
```

Let's take a quick look at our tree cover map!
```{r}
#| warning: false
ggplot() +
  geom_spatraster(data = tree_cover_2010, aes(fill = treecover)) +
  scale_fill_viridis_c() +
  labs(title = "Tree Cover in South-East NSW",
       fill = "Tree Cover (%)") +
  theme_minimal()
```

### Download Climate Rasters

We’ll be using climate projections from CHELSA, specifically the UKESM1-0-LL SSP3-7.9 model for 2011-2040. This dataset provides bioclimatic variables at a reasonable resolution, making it a great choice for our analysis.

We’ll be focusing on two key variables:

  * Bio1: Mean Annual Temperature
  * Bio12: Annual Precipitation
    
Greater gliders are sensitive to temperature and precipitation changes, and so these two variables are a sensible set to incorporate into our model to help understand their range.

First things first, let's download and load the two raster files.

```{r}
#| eval: false

# Download our two raster files
download.file("https://os.zhdk.cloud.switch.ch/chelsav2/GLOBAL/climatologies/2011-2040/UKESM1-0-LL/ssp370/bio/CHELSA_bio1_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif",              destfile="CHELSA_bio1_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif", mode="wb")  

download.file("https://os.zhdk.cloud.switch.ch/chelsav2/GLOBAL/climatologies/2011-2040/UKESM1-0-LL/ssp370/bio/CHELSA_bio12_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif",               destfile="CHELSA_bio12_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif", mode="wb") 
```

```{r}

# Load our bio1 raster
bio1 <- rast("CHELSA_bio1_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif")
bio12 <- rast("CHELSA_bio12_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif")

```

We will now do the same steps as before to clean up our rasters

```{r}
#| warning: false
#| eval: false


# Crop to our bounding box extent
bio1 <- terra::crop(bio1, bbox_ext)
# Mask out the oceans
bio1 <- mask(bio1, aus)

# Check the name, and replace the horrible large name with something short and sweet
names(bio1)
names(bio1) <- str_replace_all(names(bio1),
                               "CHELSA_bio1_2011-2040_ukesm1-0-ll_ssp370_V.2.1", 
                               "bio1")


# Resample our bioclim variable to the resolution of the elevation raster
bio1 <- terra::resample(bio1, elevation_aligned)

# And it's always a good idea to plot a raster to check it's all loaded correctly

# Repeat for our BIO12 raster
bio12 <- terra::crop(bio12, bbox_ext)
bio12 <- mask(bio12, aus)

names(bio12)
names(bio12) <- str_replace_all(names(bio12),  
                                "CHELSA_bio12_2011-2040_ukesm1-0-ll_ssp370_V.2.1", 
                                "bio12")

bio12 <- terra::resample(bio12, elevation_aligned)
```

Let's have a quick look at our climate rasters.
```{r}
#| echo: false
#| warning: false
ggplot() +
  geom_spatraster(data = bio1, aes(fill = bio1)) +
  scale_fill_viridis_c() +
  labs(title = "Mean Annual Temperature (BIO1)",
       fill = "°C") +
  theme_minimal()

ggplot() +
  geom_spatraster(data = bio12, aes(fill = bio12)) +
  scale_fill_viridis_c() +
  labs(title = "Annual Precipitation (BIO12)",
       fill = "mm") +
  theme_minimal()
```

Now our climate rasters are ready to use, and we only need to incorporate the fire extent raster.


### Download our Fire Extent Raster

#### Prepare Fire Extent Raster

<!-- Ok, this is a big but important section here. I think it might be best to provide an initial description of what you will need to do. Eg "We need to download a fire extent and severity map, it contains information about burnt area. It's huge, so we'll need to do a few things: Convert it to a class R can work with, crop and convert it to the same projection as our other layers, then align it with the other layers and remove the ocean because gliders don't live in the ocean -->

<!-- Again, you need to provide a link and description of how someone might get this dataset themselves and, to be nice to people, how big it is and how long it will take to download and then load into R -->

To assess the impact of the 2019-2020 Black Summer Bushfires, we need a raster that maps burnt areas across NSW for that period. The NSW Government’s Fire Extent and Severity Mapping (FESM) dataset provides this information, detailing the extent and severity of burnt areas across the state.

The dataset is available here: [Fire Extent and Severity Mapping (FESM) 2019/20](https://datasets.seed.nsw.gov.au/dataset/fire-extent-and-severity-mapping-fesm-2019-20). 

We will download the FESM v3-data in IMG and TIFF format, then extract the .tif file to our working directory. 

**Note**: While the download itself is only several hundred megabytes, uncompressed the .tif file is very large (10.3 GB) so please keep this in mind before downloading!


#### Processing the fire raster
This raster is *HUGE*, way bigger than we need. To save processing time and memory, we will be cropping and reducing it down just to our desired range. Unlike our previous rasters, this dataset is NOT in WGS84 and so we will need to transform it a little differently to our previous rasters:

  1. Create a SpatExtent that matches our study area
  2. Reproject that extent to the projection of our fire map.
  3. Create a bounding box of that extent in that projection.
  4. Crop our fire extent raster in that projection.
  5. Reproject the now cropped fire extent raster to the WGS84.

These steps allow us to skip a lot of the processing time needed to reproject the *entire* raster into WGS84 and then cropping down, instead cropping and then reprojecting.


<!-- Maybe you can pop this information in a dropdown table? It's great detail, but the level of detail isn't essential for the final interpretation -->

The dataset categorises fire severity using the following range of values:

  * 0 - unburnt (0% canopy and understory burnt)
  * 1 - Reserved (Experimental category, is not used in raster right now)
  * 2 - Low (> 10% burnt upderstory, >90% green canopy)
  * 3 - Moderate (20-90% canopy scorch)
  * 4 - High (> 90% canopy scorched, <50% canopy consumed)
  * 5 - Extreme (>50% canopy biomass consumed)
  
```{r}
#| warning: false
#| message: false
#Load the raster
fire_extent <- rast("cvmsre_NSW_20192020_ag1l0.tif")

# We are going to make our extent a polygon polygon first
bbox_ext_vect <- terra::as.polygons(bbox_ext, crs = "EPSG:4326")

# Reproject the bounding box to the same projection of fire_extent
bbox_ext_vect_proj <- terra::project(bbox_ext_vect, crs(fire_extent))

# Create an extent of that bbox projection
bbox_ext_proj <- terra::ext(bbox_ext_vect_proj)

#  Crop fire_extent using the reprojected bbox
fire_extent <- terra::crop(fire_extent, bbox_ext_proj)

# Reproject our fire extent to WGS84
fire_extent <- terra::project(fire_extent, "EPSG:4326")

# Then crop again to align it with our other raster files
fire_extent <- terra::crop(fire_extent, bbox_ext)

```

Now that we've reduced this very large raster down, all we need to do is rename the layer, resample to our desired resolution and then mask out the oceans.
  
```{r}
#| warning: false
#| output: false
names(fire_extent) <- str_replace_all(names(fire_extent), 
                                      "Layer_1", 
                                      "fire_extent")

# Resample and round
fire_extent <- terra::resample(fire_extent, elevation_aligned)
fire_extent <- round(fire_extent)

# Mask out the ocean
fire_extent <- fire_extent |>
    terra::mask(aus)
```
With all that done, lets have a look:
```{r}
#| warning: false
#| message: false
#| echo: false

ggplot() +
  geom_spatraster(data = fire_extent, aes(fill = fire_extent)) +
  scale_fill_whitebox_c(palette = "muted",
                        na.value = NA)  +
  labs(title = "Fire Severity in South-East NSW (2019-2020)",
       fill = "Severity") +
  theme_minimal()
```

Finally, we will add a new column to our Greater Glider observation dataset, in which we will record the fire severity category at each glider's recorded location.

To achieve this, we will extract the fire severity values from the processed fire extent raster at the coordinates where Greater Gliders were observed. 

```{r}

gliders_sf$burnt <- terra::extract(fire_extent, vect(gliders_sf), ID = FALSE)
```


Now we have all our rasters ready to go, we can begin the modelling process!

# Building our model

If you're new to species distribution modeling (SDM) or want a deeper dive into the details, I highly recommend checking out this other fantastic ALA labs post that dives into the nitty gritty for each step: [An introduction to species distribution modelling using {tidysdm} & {tidymodels}](https://labs.ala.org.au/posts/2024-04-30_sdm-tidymodels/). This post is focused more with working with rasters, applying them to use in an SDM and exploring the output of the model statistically.


### Combining our rasters

To begin we need to combine all the raster datasets we've prepared so far. This will allow our model to extract environmental values at each Greater Glider occurrence (or absence).
```{r}
#| warning: false
combined_rasters <- c(elevation_aligned, bio1, bio12, fire_extent, tree_cover_2010)

# Make sure we have valid values in our columns
summary(combined_rasters)
```

Now we have a single raster with multiple layers detailing:

  * Elevation
  * Mean annual temperature (BIO1)
  * Annual precipitation (BIO12)
  * Extent of the 2019 bushfires
  * Tree cover

### Thinning our data

Since raster cells have a fixed resolution, we want to avoid multiple glider observations within a single cell (because multiple observations below this level won't matter anyway). We’ll use `{tidysdm}`'s `thin_by_cell()` function to make sure only one glider record exists per raster grid cell.

```{r}
#| warning: false
#| output: false
# see results of thinning
gliders_thin <- tidysdm::thin_by_cell(gliders_sf, 
                                      raster = combined_rasters)

```

### Pseudo-absences and Accurate Pre/Post-Fire Columns

What we currently have is a list of actual observations. Unfortunately in SDM we don't often have true absence data to work with, just records of actual observations.
To work around this, we will generate a bunch of pseudo-absences based off our combined raster. 

<!-- The below bit is important - it defines the major variable you are concerned with in your GLM. I think you need to explain *why* you are doing this split. From memory, it's because you need to have absence information for both before and after, so you randomly sample 50% of your pseudo-absences categorise them into before/after so your model can make a spatial prediction in both scenarios. Try to make this explanation clear. -->

To ensure we can effectively assess the impact of the 2019–2020 Black Summer Bushfires on Greater Glider presence using a GLM later, we need to include both presence and absence data. However, a key challenge is that we do not have a separate raster defining pre- and post-fire habitat suitability, which is typically what the sample_pseudoabs() function would use to generate pseudo-absence locations.

To address this, we will randomly allocate 50% of the pseudo-absence records as pre-fire and 50% as post-fire. This artificial split ensures that our model has pseudo-absence data in both time periods, allowing us to analyze the spatial distribution of gliders before and after the fires

After we've generated the records, we will then restore the pre and post-fire values for our actual observations in the dataset.

```{r}
#| warning: false
#| output: false
# Generate the pseudoabsence records
gliders_pseudoabs <- tidysdm::sample_pseudoabs(
  gliders_thin,
  n = 3 * nrow(combined_rasters), 
  raster = combined_rasters,
  method = c("dist_min", km2m(5)))

# Calculate the number of rows so we can generate random categories
n_pseudo <- nrow(gliders_pseudoabs)

# Generate random categories for our pseudoabsences
pseudo_categories <- sample(c("pre_fire", "post_fire"), size = n_pseudo, replace = TRUE)

# Get the real categories from our original data
real_categories <- gliders_thin |>
  select(fire_period) |>
  mutate(class = "presence")

# Put the pseudo categories into our pseudoabsences
gliders_pseudoabs <- gliders_pseudoabs |>
  mutate(fire_period = pseudo_categories)

# Extract the tree cover, elevation values and climate values at the pseudoabs points
gliders_events <- gliders_pseudoabs |> 
  bind_cols(
    terra::extract(combined_rasters,
                   gliders_pseudoabs,
                   ID = FALSE))

# Join the real fire_period category from the original records to overwrite our fake ones
gliders_events <- gliders_events |>
  st_join(real_categories |> select(fire_period), left = TRUE) |>
  mutate(fire_period = coalesce(fire_period.y, fire_period.x)) |>  # Overwrite only if match found
  select(-fire_period.x, -fire_period.y)  # Remove redundant columns


# Remove any NA records 
gliders_events <- na.omit(gliders_events)
```

Let's now have a look at our predictor variables and see how they correlate to one another. Then we will select our predictor variables to filter out all the other records in our data frame. We will then turn our pre/post fire column into a numeric value for our modelling and statitical analysis later.

```{r}

# Select our predictor variables
predictor_vars <- c("elevation", "bio1", "bio12", "fire_extent", "treecover")

# Select all the columns we're interested in
gliders_filtered <- 
  gliders_events |> 
  select(all_of(c(predictor_vars, "class", "fire_period")))

# Change fire period into a numeric value 
gliders_filtered <- gliders_filtered |>
  mutate(fire_period = if_else(fire_period == "post_fire", 1, -1))
gliders_filtered$fire_period <- as.numeric(gliders_filtered$fire_period)

```

# Tuning and Running the Model
Now that we've cleaned and prepared our data and generated our pseudoabsence data, we're ready to start modelling!

Rather than using a single mdoel, we'll be training multiple models, investigating their relative performance, and then combining them into an ensemble model that will help make our final prediction a bit more robust.

### Training and testing


Firstly let's split our glider presence/pseudoabsence data into training and testing datasets. This allows us to train the model on one subset of the data, while evaluating it's performance on the other subset of the data. In order to improve our model and try and prevent overfitting, we'll use spatial block cross-validation. Spatial block cross validation divides the sudy area into spatial blocks and ensures our model is tested on spatially independent data, making it's predictions more general.

```{r}
#| warning: false
#| output: true
# set training and testing data
set.seed(100)

# Create training and testing datasets
gliders_split <- 
  gliders_filtered |>
  initial_split()
gliders_split

gliders_train <- training(gliders_split)
gliders_train
gliders_test <- testing(gliders_split)
gliders_test

# Perform Cross validation
gliders_cv <- spatial_block_cv(gliders_train, v = 5)
```

Now we're going to create a new recipe for our model, this will explain how our response variable `class` (presence or absence) is effected by each predictor variable (`elevation`, `bio1`, `bio12`, `treecover`, `fire_extent` and `fire_period`).

```{r}
#| warning: false
#| output: false
gliders_recipe <- recipe(
  gliders_train, 
  formula = class ~ elevation + bio1 + bio12 + treecover + fire_extent + fire_period
)

```

Rather than relying on a single model, we'll train up four and compare their performance. These models are:

  1. Generalised Linear Model
  2. Random Forest
  3. Gradient Boosting Machine
  4. Maximum entropy

We will later build an ensemble of the best models
```{r}
#| warning: false
#| output: false

gliders_models <-
  # create the workflow_set
  workflow_set(
    preproc = list(default = gliders_recipe), # Use the same recipe for all
    models = list(
      glm = sdm_spec_glm(),        # Generalised Linear Model
      rf = sdm_spec_rf(),          # Radom Forest
      gbm = sdm_spec_boost_tree(), # Gradient Boosting Machine
      maxent = sdm_spec_maxent()   # Maximum Entropy
    ),
    cross = TRUE # make all possible combinations
  ) |>
  option_add(control = control_ensemble_grid())

```

Now we'll tune our models using the cross validation blocks we generated earlier. This step helps us find the best model parameters by testing different variations and selecting the ones that perform best. We expect to see:
```{r}
#| warning: false
#| output: true
set.seed(9999)

# Tune the model using cross validation
gliders_models_tune <-
  gliders_models |>
  workflow_map("tune_grid",
               resamples = gliders_cv,     # Use our cross-validation blocks for tuning
               grid = 6,                   # number of tuning iterations
               metrics = sdm_metric_set(), # Evaluate model performance
               verbose = TRUE,
               control = stacks::control_stack_grid()
  )

autoplot(gliders_models_tune)

# See Metrics
collect_metrics(gliders_models_tune)

set.seed(98765)

```

Because we are using a collection of models, we can use stacks to combine the best models into an ensemble model that will help improve accuracy and generalisation. We will see a plot at the end detailing how much each model is contributing to the ensemble.

```{r}
#| warning: false
#| output: true

gliders_stacked <- 
  stacks() |>                                # initialize the model stack
  add_candidates(gliders_models_tune) |> #  Add the tuned models
  blend_predictions() |>                     # Blend their predictions
  fit_members()                              # Fit the final model

# Visualise each models contribution
autoplot(gliders_stacked, type = "weights")
```

Now that we have our stacked ensemble model, it’s time to see how well it performs on unseen test data. This step helps us validate the model’s accuracy and assess how well it generalizes to new observations.

```{r}
#| warning: false
#| output: true

# Predict probability of presence 
gliders_test_predictions <-
  gliders_test %>%
  bind_cols(predict(gliders_stacked, ., 
                    type = "prob", 
                    save_pred = TRUE))

# Evaluate performance
gliders_test_predictions |> 
  sdm_metric_set()(truth = class, .pred_presence)

# Give a final classification
gliders_test_predictions_class <-
  gliders_test %>%
  bind_cols(predict(gliders_stacked, ., 
                    type = "class", 
                    save_pred = TRUE))

```


# Generating the Final Raster

Now we've got a trained and tested model, we can now *almost* finally make our predictions!

THe last step we need to do is create a pseudo "fire-period" raster. We need this raster because our model only evaluates the impact of `fire_period` on the glider records, we didn't have the need a raster of fire_period previously, however because we are producing a final raster, we *DO* need a raster that we can sample from in order to produce that prediction.

```{r}
#| messages: false
#| warning: false

# Create an empty raster with the same dimensions as our combined raster
presence_raster <- rast(combined_rasters, nlyr = 1)
values(presence_raster) <- NA 

# Rename the layer for clarity
names(presence_raster) <- str_replace_all(names(presence_raster), 
                                              "lyr1", 
                                              "fire_period")


# Convert glider observations into a vector to be sampled
gliders_vect <- vect(gliders_filtered)

# Rasterize the fire period from the glider points
fire_period_raster <- rasterize(gliders_vect, presence_raster, field = "fire_period", fun = "first")
names(fire_period_raster) <- str_replace_all(names(fire_period_raster), 
                                          "first", 
                                          "fire_period")


# Assign pre/post values to the cells
fire_period_raster[is.na(fire_period_raster) & (fire_extent == 0 | fire_extent == 1)] <- -1 # Pre-fire
fire_period_raster[is.na(fire_period_raster) & !(fire_extent == 0 | fire_extent == 1)] <- 1  # Post-fire


# Add this fire period raster into our raster stack
combined_rasters <- c(combined_rasters, fire_period_raster)
```

Now we are finally ready to perform our final prediction!
```{r}
#| warning: false
#| output: false

# Perform our final prediction!
prediction_present <- predict_raster(gliders_stacked, 
                                     combined_rasters, 
                                     type = "prob",
                                     wopt = list(steps=32))

```

### The final plot
Now let's plot it, and have a look at our map detailing habitat suitability for our gliders!
```{r}
#| warning: false
#| output: true
ggplot() +
  geom_spatraster(data = prediction_present, 
                  aes(fill = .pred_presence)) +
  scale_fill_whitebox_c(palette = "viridi",
                        na.value = NA) +
  guides(fill = guide_colorbar(title="Relative\nHabitat\nSuitability")) +
  labs(title="Predicted Suitable Habitat for Greater Gliders", subtitle = "Elevation, tree cover, mean annual temp, fire events, annual precipitation and fire period.") +
  pilot::theme_pilot(grid="hv") +
  theme(
    legend.text = element_text(hjust = 0.5)) +
  theme_minimal()
```


# Finishing up: Statistical Analysis
Now let's investigate the relative effect that each variable had on the final prediction raster:

```{r}
#| warning: false
# Join the prediction raster and our other rasters
final_raster <- c(prediction_present, combined_rasters)

# Construct a GLM 
lm <- glm(.pred_presence ~ elevation + bio1 + bio12 + fire_extent + treecover + fire_period, data = final_raster)
summary(lm)

```


### Breaking down the stats

<!-- These are great notes, excellent. But I think it's a little too much for a casual reader. What are the main takeaways you learn from you model? Which variables are you looking at primarily, and what does the output tell you? Are the effects big or small? Is that what you expected? How might you interpret this? Try to choose a takeaway message for the reader, rather than presenting them with all the information. You can include some of it, but you probably don't need all of it -->
This output can be a bit confusing, so let's look at the key takeaways:

The estimate tells us how much each variable increases or decreases the likelihood of finding a glider:

  * Positive estimate: Higher values of this variable **increase** the likelihood of glider presence.
  * Negative estimate: Higher values of this variable **decrease** the likelihood of glider presence.
  * Larger absolute values mean a stronger influence.

The effect size (t-value)  tells us how strong each variable is on the final prediction. The absolute value of the effect size tells us it’s strength, and whether it’s positive or negative tells us whether or not it’s associated with increased glider predicition chance, or decreased glider prediction chance.


# Conclusion

So what does our model actually say about Greater Glider distribution in South-East NSW?

1. Tree cover is critical - Tree cover is the strongest predictor of glider presence.

2. Elevation and temperature are big predictors - Greater Gliders appear to prefer higher elevations and (relative to the surrounds) warmer annual temperatures. 

3. Rainfall plays a part - More precipitation increases the likelihood of glider presence, which is not a big surprise considering the relationship between precipitation and tree cover, and precipitation and elevation!

But from our research we alraedy had some idea of these, so let's look at the variables we're actually interested in, fire!

Severe fires have a negative impact in glider distribution - The more extreme the fire events in the 2019 bushfire season, the less likely we were to see gliders present. Fires that are too intense can scorch and destroy the critical habitat needed by Greater Gliders

The pre vs post-fire effect is interesting. We saw a slight increase in post-fire glider presence in our model. This could be due to a number of factors, perhaps new tree hollows were formed in the fires, perhaps there increased survey efforts, or surviving gliders being more visible due to reduced canopy cover, or even just more data entering into the ALA 

This model gives us a solid look at how Greater Gliders were affected by the 2019 fires. While fires can sometimes create tree hollows, our model suggests that severe fires disrupted habitat more than they helped. This kind of modeling is super useful for conservation planning, helping us predict which areas need protection or restoration.


<details><summary style = "color: #E06E53;">Expand for session info</summary>

```{r, echo = FALSE}
#| warning: false
library(sessioninfo)
# save the session info as an object
pkg_sesh <- session_info(pkgs = "attached")
# print it out
pkg_sesh
```

</details>
