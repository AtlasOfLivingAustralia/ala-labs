[
  {
    "objectID": "software/index.html",
    "href": "software/index.html",
    "title": "Software",
    "section": "",
    "text": "galah\n{galah} is an R and Python interface to biodiversity data hosted by the Atlas of Living Australia (ALA). It enables users to locate and download species occurrence records (observations, specimens, eDNA records, etc.), taxonomic information, or associated media such as images or sounds, and to restrict their queries to particular taxa or locations.  Visit the {galah} website to learn more. If you have any questions, comments, or spot any bugs, email us or report an issue on the R package GitHub page or the Python package Github page\n\n\n\n\n\n\n\n\n\n\n  \n\n\ngalaxias\n{galaxias} is an R and Python interface designed to simplify the process of converting biodiversity data into Darwin Core Archives (DwCA), facilitating data submission to infrastructures such as the Atlas of Living Australia (ALA) or the Global Biodiversity Information Facility (GBIF).  Visit the {galaxias} website to learn more. If you have any questions, comments, or spot any bugs, email us or report an issue on the R package GitHub page or the Python package Github page\n\n\n\n\n\n\n\n\n\n\n  \n\n\ncorella\n{corella} is an R and Python package that helps users standardize their data using the Darwin Core data standard, used for biodiversity data like species occurrences. corella provides tools to prepare, manipulate and validate data against the standard’s criteria. Once standardized, data can be subsequently shared as a Darwin Core Archive and published to open data infrastructures like the Atlas of Living Australia and GBIF.  Visit the {corella} website to learn more. If you have any questions, comments, or spot any bugs, email us or report an issue on the R package GitHub page or the Python package Github page\n\n\n\n\n\n\n\n\n\n\n  \n\n\ndelma\n{delma} is an R and Python package for converting metadata statements written in R Markdown or Quarto markdown to Ecological Metadata Language (EML). EML is a common framework for describing ecological datasets so they can be shared and reused. delma supports users to write metadata statements in markdown, R Markdown or Quarto markdown for greater transparency and ease-of-use, then convert them to EML for efficient transfer.  Visit the {delma} website to learn more. If you have any questions, comments, or spot any bugs, email us or report an issue on the R package GitHub page or the Python package Github page\n\n\n\n\n\n\n\n\n\n\n  \n\n\npotions\n{potions} makes options management in R—usually edited using base::options() and related functions—simpler. It uses a minimalist workflow to store and retrieve information with three core functions: brew(), pour() and drain().  Visit the {potions} website to learn more about how to use {potions} If you have any questions, comments, or spot any bugs, email us or report an issue on our GitHub page"
  },
  {
    "objectID": "research/highlights/2024_weevil/index.html",
    "href": "research/highlights/2024_weevil/index.html",
    "title": "Weevil in, weevil out: Predicting the global habitat range of an invasive weevil species",
    "section": "",
    "text": "Siraton internatus (John Bromilow CC BY 4.0)\n\n\nCitation\n\n\nHsaio, Y., Liao J.R. (2024) Predicting habitat suitability for the Australian cycad‑attacking weevil (Siraton internatus) under climate change. Biological invasions https://doi.org/10.1007/s10530-024-03330-5\n\n\n\nPage info\nPrepared by Olivia Torresan\n\n\n\n\n\nThe Australian native weevil Siraton internatus has a big (!) appetite for ferns. These insects tunnel deep into a ferns’ roots, stem and leaves, causing affected ferns to slowly deteriorate and eventually die. Under the right conditions weevils can proliferate and infest ecosystems, causing considerable damage. These conditions are expected to become more frequent with climate change.\nHsaio & Liao used ALA occurrence data to test where S. internatus may move under different global climate change scenarios.\nThey find that weevil habitat ranges are likely to contract in Australia, but their preferred habitat will likely expand in Chile and within the southern Himalayas. With this knowledge, managers and biosecurity teams can work to better monitor for invasive weevils in these areas and reinforce management measures if weevils are cited in these international locations in the future."
  },
  {
    "objectID": "research/highlights/2024_metabarcoding/index.html",
    "href": "research/highlights/2024_metabarcoding/index.html",
    "title": "eDNA metabarcoding can take snapshots of coastal biodiversity",
    "section": "",
    "text": "Carijoa (Joanne CC-BY-NC 4.0 (Int))\n\n\nCitation\n\n\nDiBattista, J. D., Fowler, A. M., Shalders, T. C., Williams, R. J., Wilkinson, S. (2024) Tree of life metabarcoding can serve as a biotic benchmark for shifting baselines in urbanized estuaries. Environmental Research https://doi.org/10.1016/j.envres.2024.119454\n\n\n\nPage info\nPrepared by Dax Kellie\n\n\n\n\n\nSheltered coastal and estuarine ecosystems are under considerable threat from human activity and urbanization. To help understand ongoing impacts, it is useful to catalogue the aquatic diversity in an area to compare against over time.\nDiBattista and colleagues used Environmental DNA (eDNA) metabarcoding—also known as Tree-of-Life metabarcoding—to take a snapshot of species diversity and species richness in 4 distinct geomorphic habitat regions in Sydney Harbour using seawater samples.\nThe authors catalogued 1,427 unique taxa and 1,118 aquatic taxa overall from 16 eDNA metabarcoding assays, showing how this method can be used to “benchmark” an area’s biodiversity. They found each habitat zone in Sydney Harbour had distinct community compositions of flora and fauna, with bacteria (one of the most represented groups in the study but one of the least documented groups in data repositories) a useful environmental indicator captured via this method."
  },
  {
    "objectID": "research/highlights/2024_habitat-suitability/index.html",
    "href": "research/highlights/2024_habitat-suitability/index.html",
    "title": "Habitat suitability of 10,633 Australian flora & fauna species in future climates",
    "section": "",
    "text": "Eucalyptus pauciflora (Irene Proebsting CC BY 4.0)\n\n\nCitation\n\n\nArchibald, C.L., Summers, D.M., Graham, E.M., Bryan, B.A. (2024) Habitat suitability maps for Australian flora and fauna under CMIP6 climate scenarios. GigaScience https://doi.org/10.1093/gigascience/giae002\n\n\n\nPage info\nPrepared by Olivia Torresan\n\n\n\n\n\nAustralia’s environment is vast and diverse, but many large areas are difficult to monitor ecologically using on-ground surveys. As the global climate shifts, figuring out where species can find suitable habitat is a pressing issue for scientists and resource managers. Modelled data is of particular importance for decision-makers to understand how future conditions will affect available habitat of Australia’s species. These data improve decision-makers’ ability to plan and prioritise national- and state-level restoration and conservation initiatives.\nIn this paper, Archibald & colleagues use species occurrence data from the Atlas of Living Australia, Queensland Museum & CSIRO along with environmental and climatic data to predict potential habitat suitability maps under different climate scenarios for 1,382 terrestrial vertebrates and 9,251 vascular plants at 5 km2. These climate scenarios are based on varying levels of potential emission intensities and their projected impact to temperature.\nThe resulting species maps and tables are openly available for researchers and managers to improve conservation planning and species management."
  },
  {
    "objectID": "research/highlights/2024_gecko-tails/index.html",
    "href": "research/highlights/2024_gecko-tails/index.html",
    "title": "The tale of changing gecko tails in extreme climates",
    "section": "",
    "text": "Oedura marmorata (rubynats CC BY 4.0)\n\n\nCitation\n\n\nGreen, A.L, Oliver, P.M,Gray, J.A., Sherratt, E. (2024) Adaptive tails? Parallel evolution of expanded tails in monsoonal tropics lineages of an Australian gecko radiation (Oedura). Zoological Journal of the Linnean Society https://doi.org/10.1093/zoolinnean/zlad186\n\n\n\nPage info\nPrepared by Olivia Torresan\n\n\n\n\n\nWith enough time, species can evolve to adapt to a different environment or climate. Sometimes (though, not always) this can be expressed in a detectable physical change: the shape and size of a leaf, a limb, or even the colour of scales, feathers, or fur. These changes add up, and over time these adaptations in a population can even demarcate into a new species.\nTo make sense of the potential drivers of physical changes and species splits, researchers use knowledge of the historic environment to compare with changes in physical traits. In this paper, Green et al. use climate data from the Atlas of Living Australia’s Spatial Portal alongside delineated environmental regions to explain the changes in gecko tail shape across Australia.\nThey find that wider, flatter tails predominantly occur in the Australian Monsoonal Tropics (regions with extreme wet and dry seasons), whereas narrower, tapered tails occur in more arid regions. They suggest the ‘bulbous’ morphology of the wider-tailed geckos could reflect an adaptation to harness energy stores during periods of high resource availability (wet seasons) in order to prepare for potential scarcity in dry seasons (analogous to how succulents’ function in the plant world)!"
  },
  {
    "objectID": "research/highlights/2024_cuckoos/index.html",
    "href": "research/highlights/2024_cuckoos/index.html",
    "title": "Selection for better imposters drives speciation in parasitic cuckoos",
    "section": "",
    "text": "Chalcites minutillus minutillus (kingbrown87 CC-BY-NC 4.0 (Int))\n\n\nCitation\n\n\nLangmore, N. E., Grealy, A., Noh, H.-J., Medina, I., Skeels, A., Grant, J., Murray, K. D., Kilner, R. M., Holleley, C. E. (2024) Coevolution with hosts underpins speciation in brood-parasitic cuckoos. Science https://doi.org/10.1126/science.adj3210\n\n\n\nPage info\nPrepared by Dax Kellie\n\n\n\n\n\nCoevolutionary interactions are believed to be a major reason for diversification of living organisms, and why there are millions—not thousands—of species. Parasitic cuckoos, which lay eggs in other species’ nests, exploit host species as parents to raise their young. Some hosts expel imposters if they can recognise them, so cuckoos are under selection pressure to be better mimics of the broods they are in to fool their new parents.\nLangmore and colleagues used a range of evidence—phylogenetic analyses of cuckoo species, genetic evidence using current and historic DNA samples, morphological evidence of divergent plumage and song, and (with the help of ALA data) spatial evidence of overlapping but distinct populations—to understand the mechanisms behind cuckoo species divergence.\nThe authors found multiple sources of evidence to show that host defenses result in selection for better imposters, driving speciation in parasitic cuckoos. This is especially clear in species that lay eggs in a broad range of host species’ nests.\nThis study provides rare empirical evidence that links macroevolutionary patterns (e.g. new species across geographic regions) to microevolutionary processes (e.g. drivers of genetic diversity), supporting a fundamental tenet of speciation and evolutionary theory."
  },
  {
    "objectID": "research/highlights/2023_snapper-whiting/index.html",
    "href": "research/highlights/2023_snapper-whiting/index.html",
    "title": "Citizen science data improves key recreational fish population models",
    "section": "",
    "text": "Chrysophrys auratus (Erik Schlogl CC BY NC 4.0)\n\n\nCitation\n\n\nGraba-Landry, A., Champion, C., Twiname, S., Wolfe, B., Haddy, J., Mossop, D., Pecl, G., & Tracey, S. R. (2023) Citizen science aids the quantification of the distribution and prediction of present and future temporal variation in habitat suitability at species’ range edges. Frontiers of Biogeography https://doi.org/10.21425/F5FBG58207\n\n\n\nPage info\nPrepared by Olivia Torresan\n\n\n\n\n\nSpecies distribution models are widely used in ecology to predict where a species might live. These models can be particularly useful to understand species that are difficult to observe or survey. However, when there is limited data on a species, models are prone to making poor predictions as well.\nCitizen science data can help increase not only the number of observations, but also the breadth of surveillance of many different species. When the range of a species is known to be shifting or expanding, data collected by citizen scientists may be especially useful for gathering up-to-date information because the chance of incidentally observing a species increases.\nLandry et al. (2023) compared species distribution models of Tasmanian species of Snapper and Whiting—two recreationally important fish with expanding habitat ranges—that included or excluded citizen science observations data with traditional data repository observations. They found models that include citizen science data predict a substantially larger habitat range for both species: an increase of 277km for Snapper, and 437km for Whiting. Adding citizen science data also increased the volume of data by 2.3% for Snapper and 52.7% for Whiting. For species with expanding habitat ranges, citizen science data can be useful for capturing occurrences of species at their range edge.\nLandry et al.’s (2023) work demonstrates how citizen science data can be an asset for predicting species distributions of marine species as habitat ranges shift as a result of warming temperatures. Although an expanding habitat range might appear positive for recreational fishing, shifts in habitat range can have negative down-stream effects on ecological dynamics. For example, as waters become warmer, Snapper and Whiting are expected to spawn and settle more successfully in new areas, consuming resources in areas they previously couldn’t survive."
  },
  {
    "objectID": "research/highlights/2023_peanuts/index.html",
    "href": "research/highlights/2023_peanuts/index.html",
    "title": "Changing farming climates: the future of growing peanuts",
    "section": "",
    "text": "Arachis hypogaea L. (Fagg, M. CC BY 3.0)\n\n\nCitation\n\n\nH Haerani, A Apan, T Nguyen-Huy & B Basnet (2023) Modelling future spatial distribution of peanut crops in Australia under climate change scenarios. Geospatial Information Science https:://doi.org/10.1080/10095020.2022.2155255\n\n\n\nPage info\nPrepared by Olivia Torresan, Margot Schneider\n\n\n\n\n\nPeanuts are one of the richest sources of dietary protein - topping meat, dairy, eggs, and fish. They are also non-perishable, able to be used by global aid industries in the fight against famine and crisis food shortages. Ensuring we have a ready supply of plant-based protein like peanuts is important. Both agriculturalists and top export regions are likely to bear the brunt of holding a steady supply.\nUsing nearly 2,000 geographical occurrence data points from the Atlas of Living Australia (ALA) and the Global Biodiversity Information Facility (GBIF) alongside modelled climate change scenarios, Haerani et al. (2023) infer a global distribution of peanut crops under a changing climate.\nThey find that in the next century, suitable peanut growing regions are set to shrink substantially along the east and west coast, with northern New South Wales and south-east Queensland at the greatest loss by the year 2100."
  },
  {
    "objectID": "research/highlights/2023_koalas/index.html",
    "href": "research/highlights/2023_koalas/index.html",
    "title": "Rapid loss of genetic diversity in Koalas from urbanisation",
    "section": "",
    "text": "Phascolarctos cinereus (Nathaniel Xggum CC BY NC 3.0)\n\n\nCitation\n\n\nHohwieler Katrin R., de Villiers Deidre L., Cristescu Romane, Celine H. Frere (2023) Genetic erosion detected in a specialist mammal living in a fast-developing environment. Conservation Science and Practice https://doi.org/10.1111/csp2.12738\n\n\n\nPage info\nPrepared by Olivia Torresan, Margot Schneider\n\n\n\n\n\nHabitat fragmentation—when a large habitat is divided into smaller isolated patches of habitat—is a major threat to species survival. Usually caused by habitat destruction, habitat fragmentation can separate populations from the larger group of individuals.\nCompared to larger populations, fragmented populations are more likely to inbreed, reducing their genetic diversity. Genetic diversity is important for species. It improves their resilience to disease and their ability to adapt to changing environmental conditions. Without detection or management, fragmentation heightens species extinction risk.\nWith the help of ALA data, Hohwieler and others (2022) assessed the genetic diversity of a Queensland koala population by comparing physical samples (ear biopsy specimens and scats) between two generations (2006 vs. 2018).\nThe authors found a decline in diversity that correlated with accelerating urbanisation, traffic increases and habitat loss. Supported by this evidence, the authors call for stronger requirements of genetic diversity guidelines when determining species’ and ecosystems’ critical status by the International Union for Conservation (IUCN)."
  },
  {
    "objectID": "research/highlights/2023_jacarandas/index.html",
    "href": "research/highlights/2023_jacarandas/index.html",
    "title": "When do Jacaranda trees bloom?",
    "section": "",
    "text": "Jacaranda mimosifolia (2fgaj | questagame.com CC BY NC 3.0)\n\n\nCitation\n\n\nGarcia-Rojas, M. I., Keatley, M. R., & Roslan, N. (2022) Citizen science and expert opinion working together to understand the impacts of climate change. PLOS ONE https://doi.org/10.1371/journal.pone.0273822\n\n\n\nPage info\nPrepared by Olivia Torresan\n\n\n\n\n\nPictures of species are a valuable way of documenting how traits and characteristics vary in different locations and over time.\nTo understand how shifts in climate influence seasonal behaviour of Australia’s plants, Garcia-Rojas, Keatley & Roslan (2023) used images of Jacaranda trees (Jacaranda mimosifolia) to investigate how their flowering patterns might have changed across time. These images were obtained from a decade-long citizen science program published to the Atlas of Living Australia. A total of 11,578 Jacaranda sightings were used to calculate the time period and intensity of flowering from 2009 – 2019.\nJacaranda’s were found to flower more intensely and for a longer amount of time in warm and dry conditions, but when too hot and dry this trend reversed. With the climate predicted to grow warmer and drier in the future, Jacarandas may find temporary success along Australia’s east coast, but find conditions increasingly difficult in regions like Perth that are already warm and dry."
  },
  {
    "objectID": "research/highlights/2023_JEV/index.html",
    "href": "research/highlights/2023_JEV/index.html",
    "title": "Mapping transmission risk: Japanese Encephalitis Virus",
    "section": "",
    "text": "Culex (Culex) sitiens (Nick Lambert CC BY NC SA 3.0)\n\n\nCitation\n\n\nFurlong, M., Adamu, A. M., Hoskins, A., Russell, T. L., Gummow, B., Golchin, M., Hickson, R. I., & Horwood, P. F. (2023) Japanese Encephalitis Enzootic and Epidemic Risks across Australia. Viruses https://doi.org/10.3390/v15020450\n\n\n\nPage info\nPrepared by Olivia Torresan, Margot Schneider\n\n\n\n\n\nJapanese encephalitis virus is a blood-borne virus spread via mosquitos. It is often considered a rural disease, present in animal populations (often pigs and waterbirds) and able to infect humans that interact closely with animal hosts. Urbanisation and agricultural production can increase the risk that humans contract the virus.\nUntil recently Japanese encephalitis was thought to be geographically restricted to Northern Australia, but in 2022, it was found across all the eastern states of Australia and declared nationally significant.\nFurlong and others (2023) used ALA data to obtain occurrence records of both mosquitos and waterbirds. Using ecological niche models, they found the highest risk of human exposure to the virus in coastal Australia—sprawling across the Great Dividing Range and the Murray-Darling Basin. The authors predict that Japanese encephalitis will establish an endemic circulation in Australia, increasing risks to human health."
  },
  {
    "objectID": "posts/index.html",
    "href": "posts/index.html",
    "title": "Posts",
    "section": "",
    "text": "Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Author\n      \n    \n  \n\n\n\n\n\n\n\n\n\n\nAdd a buffer to a shapefile and account for obfuscated species locations\n\n\nKnowing what species have been observed in a local area is a regular task for ecosystem management. Here we show how to add a buffer to a shapefile using {shapely} and {geopandas}. We then demonstrate how data that have been obfuscated (i.e. their location has been made less precise) may affect the buffer size required to more confidently capture threatened species in the area using {galah-python} and {matplotlib}.\n\n\n\n\n\nAug 26, 2025\n\n24 min\n\n\n\n\n\n\n\n\n\n\n\nDownload a species list and cross-reference with conservation status lists in R\n\n\nKnowing what species have been observed in a local area is a regular task for ecosystem management. Here we show how to make a species list and how to cross-reference this list with threatened and sensitive species lists. We show how to do this task using 2 methods, with {galah} and using an external shapefile and species list. We then show how to visualise this information as a bar chart and a waffle chart using {ggplot2}.\n\n\n\n\n\nJul 13, 2025\n\n\nDax Kellie, Amanda Buyan\n\n20 min\n\n\n\n\n\n\n\n\n\n\n\nModelling the impact of fire on the Southern Greater Glider\n\n\nMajor fire events impact flora and fauna, particularly in areas where fire can dramatically reshape the livable habitat area. Here we investigate how greater gliders, a tree-dwelling marsupial species, were impacted by the 2019-2020 bushfires using {tidymodels} and {tidysdm}.\n\n\n\n\n\nApr 2, 2025\n\n\nJarod Wright, Dax Kellie\n\n55 min\n\n\n\n\n\n\n\n\n\n\n\nShow seasonal species trends using a ridgeline plot\n\n\nDisplaying ecological trends of many species or groups at once can sometimes appear messy or crowded. In this post we show how ridgeline plots are a useful way to show trends in seasonality by displaying observations of migratory bird species over the year using {ggridges}.\n\n\n\n\n\nMay 10, 2024\n\n\nOlivia Torresan, Dax Kellie\n\n11 min\n\n\n\n\n\n\n\n\n\n\n\nAn introduction to species distribution modelling using {tidysdm} & {tidymodels}\n\n\nSpecies distribution modelling is a common task for ecologists in R. Here we show the fundamental steps to build, assess and use models to predict species distributions using {tidymodels} & {tidysdm}, modern packages that use tidy syntax to run and plot geospatial models.\n\n\n\n\n\nApr 30, 2024\n\n\nDax Kellie, Shandiya Balasubramaniam\n\n32 min\n\n\n\n\n\n\n\n\n\n\n\nDownload a species list and cross-reference with conservation status lists\n\n\nKnowing what species have been observed in a local area is a regular task for ecosystem management. Here we show how to make a species list with {galah-python} and how to cross-reference this list with threatened and sensitive species lists. We then show how to visualise this information as a waffle chart using {pywaffle} & {matplotlib}.\n\n\n\n\n\nFeb 12, 2024\n\n\nAmanda Buyan, Dax Kellie\n\n11 min\n\n\n\n\n\n\n\n\n\n\n\nCombining multiple species distributions on one map with hexagons and points\n\n\nVisualising multiple species distributions in a single figure can be difficult if there are areas where ranges overlap. In this post we introduce a way to show several species distributions in an area at once using a novel twist on the commonly used hexbin map.\n\n\n\n\n\nJan 25, 2024\n\n\nCallum Waite, Shandiya Balasubramaniam\n\n20 min\n\n\n\n\n\n\n\n\n\n\n\nBeginner’s guide: Make a quick map of species observations in Python and R\n\n\nThe ability to make a map quickly is an essential skill in ecology and conservation. This post shows how to make a quick, simple map of Peron’s tree frog occurrences & set a custom font using either Python or R.\n\n\n\n\n\nDec 18, 2023\n\n\nAmanda Buyan, Dax Kellie\n\n19 min\n\n\n\n\n\n\n\n\n\n\n\nAlternatives to box plots: Using beeswarm and raincloud plots to summarise ecological data\n\n\nBox plots are a common way to summarise data in ecology and biology research, but box plots have their weaknesses. Here we’ll show how easy it can be to make beeswarm and raincloud plots—two alternatives with greater data transparency—using plant trait data from {austraits}.\n\n\n\n\n\nAug 28, 2023\n\n\nDax Kellie, Shandiya Balasubramaniam\n\n26 min\n\n\n\n\n\n\n\n\n\n\n\nAn exploration of dingo observations in the ALA\n\n\nDingoes are the subject of ongoing debate about whether they should be considered a protected species or a pest species. Here we explore dingo observations in the ALA to understand how differing attitudes affect dingo data, plotting spatial and temporal trends using {ggplot2}.\n\n\n\n\n\nMay 16, 2023\n\n\nAmos Smith, Dax Kellie\n\n23 min\n\n\n\n\n\n\n\n\n\n\n\nPlotting invasive species distributions with alpha shapes and choropleth maps in Python\n\n\nInvasive and introduced species can expand quickly into new habitats, altering ecosystems. In this post we use Python’s {galah}, {alphashape} and {GeoPandas} packages to visualise the growing distribution of Rhinella marina (cane toads) and the expanding range of Pittisporum undulatum in Australia.\n\n\n\n\n\nApr 28, 2023\n\n\nCaitlin Ramsay, Amanda Buyan, Dax Kellie\n\n13 min\n\n\n\n\n\n\n\n\n\n\n\nQuantifying species range and overlap with fire-burned areas using concave hulls\n\n\nCalculating range overlap is an efficient way to estimate the impact of natural disasters on biodiversity. Here we’ll use curated datasets to compute concave hulls to visualise the spatial distribution of Apidae (Bees) and Daviesia (Bitterpeas) and their overlap with burned areas of the Black Summer fires of 2019-2020.\n\n\n\n\n\nApr 11, 2023\n\n\nFonti Kar, Margot Schneider\n\n25 min\n\n\n\n\n\n\n\n\n\n\n\nMake a highlighted time-series plot\n\n\nTime-series analyses can be handy for seeing trends over time, and exploring how trends relate to major events. Here, we show how to create an exploratory time-series plot comparing observations of waterbirds prior to and during the COVID-19 pandemic.\n\n\n\n\n\nApr 3, 2023\n\n\nThai Rushbrook, Olivia Torresan, Dax Kellie\n\n14 min\n\n\n\n\n\n\n\n\n\n\n\nAnimated species distribution maps with {gifski}\n\n\nOne useful way to see changes in a species’ habitat range over time is by using animation to view multiple distributions in succession. Here we will model the distribution of Nudibranchia across Australia each month to create an animated GIF of its distribution over a year.\n\n\n\n\n\nMar 14, 2023\n\n\nStephanie Woolley, Olivia Torresan, Dax Kellie\n\n20 min\n\n\n\n\n\n\n\n\n\n\n\nCounting points in multipolygon shapefiles for choropleth mapping\n\n\nChoropleth maps are an excellent way to visualise numbers of observations, but when using point data, calculating the number of points in each polygon can be difficult when using shapefiles. Here we demonstrate how to extract and summarise the number of points in each polygon to create a choropleth map.\n\n\n\n\n\nFeb 6, 2023\n\n\nOlivia Torresan, Dax Kellie\n\n10 min\n\n\n\n\n\n\n\n\n\n\n\nConvex and alpha hulls for conservation mapping\n\n\nConvex hulls and alpha hulls are wonderful alternatives for visualising species distributions when a species has very few existing observations. Here, we will show you how to create these spatial polygons using data from the ALA.\n\n\n\n\n\nOct 20, 2022\n\n\nMargot Schneider, Fonti Kar\n\n15 min\n\n\n\n\n\n\n\n\n\n\n\nQuantify geographic sampling bias with {sampbias}\n\n\nHuman biases play a large role in the data we collect about species. Here we show a simple method to quantify the bias of roads, cities, rivers and airports on species observations of legless lizards in the Northern Territory\n\n\n\n\n\nAug 8, 2022\n\n\nDax Kellie\n\n11 min\n\n\n\n\n\n\n\n\n\n\n\nMultiple colour scales in choropleth maps with {ggnewscale}\n\n\nUsing multiple colour scales can be a great way to visually differentiate between geographic categories on a map. Here, we demonstrate this by creating a choropleth map to represent the density of plant records from the ALA across bioregions in Australia, and add multiple colour scales to differentiate marine and terrestrial records\n\n\n\n\n\nMay 31, 2022\n\n\nShandiya Balasubramaniam\n\n10 min\n\n\n\n\n\n\n\n\n\n\n\nDownload plant species data by hexagon to make a 3D hex map\n\n\nMaking plots eye-catching can be useful for science communication. Here, we show how to make 3D plots in R with the rayshader package by visualising the number of species identified from ALA observations since 2020\n\n\n\n\n\nMay 23, 2022\n\n\nDax Kellie\n\n12 min\n\n\n\n\n\n\n\n\n\n\n\nSunburst plots for taxonomic data\n\n\nSince version 1.3.1 of {galah}, it has been possible to download taxonomic data using a ‘tree’ format from the {data.tree} package. Here I’ll demonstrate some ideas for plotting these trees using circular diagrams.\n\n\n\n\n\nFeb 17, 2022\n\n\nMartin Westgate\n\n8 min\n\n\n\n\n\n\n\n\n\n\n\nHex maps for species occurrence data\n\n\nHexagonal grid maps (i.e. hex maps) are one way to display information about the distribution of a species and the relative frequency that a species occurs in a given area. Here we will show how to make a hex map of magpie observations in Australia using sf and ggplot2.\n\n\n\n\n\nMar 1, 2021\n\n\nMatilda Stevenson, Dax Kellie, Martin Westgate\n\n8 min\n\n\n\n\n\n\n\n\n\n\n\nCreating a color palette from an image\n\n\nThere are hundreds of color palettes in the R ecosystem, but sometimes we might want to use colors from a specific image. Here I show how to use the paletter package to create a color palette for the 2020 Eucalypt of the Year: the Western Australian Gimlet.\n\n\n\n\n\nJan 3, 2021\n\n\nMartin Westgate\n\n5 min\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2024-05-10_ridgeline-plots/index.html",
    "href": "posts/2024-05-10_ridgeline-plots/index.html",
    "title": "Show seasonal species trends using a ridgeline plot",
    "section": "",
    "text": "Olivia Torresan\nDax Kellie\n\n\n\n10 May 2024\nIn ecology, it’s common to investigate trends across individuals, populations, species or taxonomic groups. Although it’s possible to use box plots and bar plots for this task, viewing many boxes or bars at once can become messy or crowded. These plots also display summary statistics which can sometimes mask important elements of variation in the data and potentially over-exaggerate existing trends.\nRidgeline plots are one useful, fast type of visualisation for showing trends in ecological data like seasonality, diurnality and population growth or decline. They are especially useful for comparing a large number of individuals, species or groups because they display density curves rather than summary statistics. This means that variation in the data is visibly preserved.\nHere, we use a ridgeline plot to quickly display the yearly seasonality of shorebirds (birds fond of tidal and estuary environments), in Pindanland, Western Australia using the galah, ggplot2 and ggridges packages.\nLet’s start by loading the R packages that we will need.\nlibrary(galah)\nlibrary(tidyverse)\nlibrary(ggridges)\nlibrary(pilot) #remotes::install_github(\"olihawkins/pilot\")\nWe will use the galah package to download occurrence records from the Atlas of Living Australia (ALA). To do this, you’ll need to provide a registered email address and pass it to galah using galah_config().\ngalah_config(email = \"your-email@email.com\")"
  },
  {
    "objectID": "posts/2024-05-10_ridgeline-plots/index.html#download-data",
    "href": "posts/2024-05-10_ridgeline-plots/index.html#download-data",
    "title": "Show seasonal species trends using a ridgeline plot",
    "section": "Download data",
    "text": "Download data\nShorebirds are a group with many highly migratory birds that travel large distances between breeding seasons. One species found in Pindanland, the Bar-tailed Godwit (below left), migrates once a year across the Pacific to Australia for food; that’s 11,000 kilometers non-stop!1 As a result shorebird abundance can fluctuate a lot in a given area depending on the time of year. Our goal is to display these changes in abundance by looking at how many total shorebird observations there have been on each day of the year, grouped by species.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLeft: Limosa lapponica (lozwoz88 CC-BY-NC 4.0 (Int), Middle: Stiltia isabella (Steve Murray CC-BY-NC 4.0 (Int)), Right: Cladorhynchus leucocephalus (Blythe Nilson, iNaturalist CC-BY-NC 4.0 (Int))\n\nLet’s download data of shorebirds in the order Charadriiformes.\nWe are interested in downloading data from Pindanland, a subregion of the IBRA bioregion Dampierland in Western Australia. To filter our data to only Pindanland, we’ll do a text search for any fields in galah that contain IBRA information.\n\nsearch_all(fields, \"ibra\")\n\n# A tibble: 3 × 3\n  id     description       type  \n  &lt;chr&gt;  &lt;chr&gt;             &lt;chr&gt; \n1 cl20   IBRA 6 Regions    fields\n2 cl1048 IBRA 7 Regions    fields\n3 cl1049 IBRA 7 Subregions fields\n\n\n\nFor those unfamiliar with Australian geography, Pindanland is located here.\n\n\n\n\n\n\n\n\n\n\nThe field ID cl1049 appears to contain IBRA subregions. Let’s show what values are recorded in the IBRA 7 Subregions field to check.\n\nsearch_all(fields, \"cl1049\") |&gt; show_values()\n\n• Showing values for 'cl1049'.\n\n\n# A tibble: 419 × 1\n   cl1049                            \n   &lt;chr&gt;                             \n 1 Gippsland Plain                   \n 2 Murrumbateman                     \n 3 Victorian Volcanic Plain          \n 4 Burringbar-Conondale Ranges       \n 5 Sunshine Coast-Gold Coast Lowlands\n 6 Highlands-Southern Fall           \n 7 Pittwater                         \n 8 Otway Plain                       \n 9 Cumberland                        \n10 Moreton Basin                     \n# ℹ 409 more rows\n\n\nWe can also search for “Pindanland” to double check for our subregion.\n\nsearch_all(fields, \"cl1049\") |&gt; \n  search_values(\"Pindanland\")\n\n• Showing values for 'cl1049'.\n\n\n# A tibble: 1 × 1\n  cl1049    \n  &lt;chr&gt;     \n1 Pindanland\n\n\nNow we are able to download occurrence data of shorebirds in Pindanland by using field cl1049 in our query. We’ll further filter our query to return occurrences recorded after the year 2000, human observations (rather than museum specimens), and records identified to the species level. We’ll also use a set of ALA data cleaning filters (i.e. a data profile) by adding galah_apply_profile(ALA) to return fewer erroneous records. To shrink the amount of data we return, we’ll select only columns eventDate, scientificName to return.\n\n# download shorebird records\nshorebirds &lt;- galah_call() |&gt;\n  galah_identify(\"Charadriiformes\") |&gt; \n  galah_filter(cl1049 == \"Pindanland\",\n               year &gt; 2000,\n               basisOfRecord == \"HUMAN_OBSERVATION\",\n               taxonRank == \"species\") |&gt;\n  galah_apply_profile(ALA) |&gt;\n  galah_select(eventDate, scientificName) |&gt;\n  atlas_occurrences()\nshorebirds\n\n# A tibble: 67,280 × 2\n   eventDate scientificName                      \n   &lt;dttm&gt;    &lt;chr&gt;                               \n 1 NA        Haematopus longirostris             \n 2 NA        Calidris (Crocethia) alba           \n 3 NA        Tringa (Glottis) nebularia          \n 4 NA        Pluvialis squatarola                \n 5 NA        Xenus cinereus                      \n 6 NA        Charadrius (Eupoda) veredus         \n 7 NA        Numenius (Numenius) madagascariensis\n 8 NA        Arenaria interpres                  \n 9 NA        Calidris (Calidris) falcinellus     \n10 NA        Arenaria interpres                  \n# ℹ 67,270 more rows"
  },
  {
    "objectID": "posts/2024-05-10_ridgeline-plots/index.html#prepare-data",
    "href": "posts/2024-05-10_ridgeline-plots/index.html#prepare-data",
    "title": "Show seasonal species trends using a ridgeline plot",
    "section": "Prepare data",
    "text": "Prepare data\nNow that we have our data, we need to prepare it for our plot. Remember that we are trying to visualise total number of observations of each species each day of the year.\nTo clean our data, we’ll remove records missing an eventDate. Then we can convert eventDate to a standard date class (yyyy/mm/dd), and extract the day of the year (Julian date)2.\n\n# format date\nshorebirds_dates &lt;- shorebirds |&gt;\n  drop_na(eventDate) |&gt;\n  mutate(\n    eventDate = as_date(eventDate),\n    date_julian = yday(eventDate)\n  )\n\nshorebirds_dates\n\n# A tibble: 66,693 × 3\n   eventDate  scientificName                      date_julian\n   &lt;date&gt;     &lt;chr&gt;                                     &lt;dbl&gt;\n 1 2001-01-01 Calidris (Calidris) canutus                   1\n 2 2001-01-01 Calidris (Calidris) tenuirostris              1\n 3 2001-01-03 Limosa lapponica                              3\n 4 2001-01-03 Actitis hypoleucos                            3\n 5 2001-01-06 Elseyornis melanops                           6\n 6 2001-01-06 Chlidonias (Pelodes) hybrida                  6\n 7 2001-01-06 Limosa limosa                                 6\n 8 2001-01-06 Himantopus himantopus                         6\n 9 2001-01-06 Chlidonias (Chlidonias) leucopterus           6\n10 2001-01-06 Chlidonias (Chlidonias) leucopterus           6\n# ℹ 66,683 more rows\n\n\nWe then filter our data to only include species with more than 10 occurrence records, which leaves us our final data frame ready for plotting.\n\nshorebirds_filtered &lt;- shorebirds_dates |&gt;\n  group_by(scientificName) |&gt;\n  filter(n_distinct(date_julian) &gt;= 10)\n\nshorebirds_filtered |&gt; rmarkdown::paged_table()"
  },
  {
    "objectID": "posts/2024-05-10_ridgeline-plots/index.html#make-ridgeline-plot",
    "href": "posts/2024-05-10_ridgeline-plots/index.html#make-ridgeline-plot",
    "title": "Show seasonal species trends using a ridgeline plot",
    "section": "Make ridgeline plot",
    "text": "Make ridgeline plot\nWe can now create a simple ridgeline plot for our data using geom_density_ridges().\n\nridge_plot &lt;- ggplot(\n  data = shorebirds_filtered,\n  aes(x = date_julian,\n      y = scientificName,\n      fill = scientificName)) +  \n  ggridges::geom_density_ridges(color = NA) +  \n  theme_minimal() +\n  theme(legend.position = \"none\")\n\nridge_plot\n\n\n\n\n\n\n\n\nIf we want to refine our plot, there are some extra things we can do to increase its readability.\nFor example, we can make the trends easier to interpret by ordering species by a summary statistic (e.g., mean). We ordered by month with the highest proportion of observations3, which helps place birds with greater abundance at the end of the year towards the top, and birds with greater abundance at the beginning of the year at the bottom. We also adjusted the the smoothness of our ridges to see more fine-scale variation in our data.\nWe can also adjust the colours and axis labels. We chose theme_pilot from the pilot package as it uses a colour-blind friendly palette.\n\n\nCode\n# add month\nshorebirds_filtered &lt;- shorebirds_filtered |&gt;\n  mutate(\n    month = month(eventDate, \n                  abbr = TRUE, \n                  label = TRUE),\n    month_number = month(eventDate,\n                         abbr = FALSE,\n                         label = FALSE)\n    )\n\n# add month proportion column\nshorebirds_filtered_prop &lt;- shorebirds_filtered |&gt;\n  group_by(scientificName, month) |&gt;\n  summarise(n = n(), \n            .groups = \"drop\") |&gt;\n  group_by(scientificName) |&gt;\n  mutate(\n    total = sum(n),\n    prop = n/total * 100,\n  ) |&gt;\n  left_join(shorebirds_filtered,\n            join_by(scientificName == scientificName, \n                    month == month))\n\nshorebirds_filtered_prop |&gt;\n  ggplot(\n  aes(\n    x = date_julian,\n    y = fct_reorder(scientificName, prop*month_number),\n    fill = fct_reorder(scientificName, prop*month_number), \n    colour = fct_reorder(scientificName, prop*month_number),\n  )) +\n  scale_x_continuous(\n    breaks = c(1, 30, 60, 90, 120, 150, \n               180, 210, 240, 270, 300, 330),  # set numbers for labels\n    labels = c(\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"June\", \n               \"July\", \"Aug\", \"Sept\", \"Oct\", \"Nov\", \"Dec\"), # set labels\n    expand = c(0,0)) + \n  labs(x = \"Month\") +\n  ggridges::geom_density_ridges(color = NA,\n    bandwidth = 9,       # smoothness of the curve\n    scale = 6,            # ridge width\n    height = 0.05,        # ridge height\n    alpha = .8,           # transparency\n    rel_min_height = 0.02) +\n  pilot::theme_pilot(grid = \"v\",  # grid lines \n                     axes = \"\") + # axis lines\n  pilot::scale_fill_pilot() +\n  theme(legend.position = \"none\",\n        axis.title.y = element_blank(),\n        axis.title.x = element_text(size = 16),\n        axis.text.x = element_text(size = 14))\n\n\n\n\n\nTotal daily observations of shorebirds from 2000–2024 in Pindanland, WA\n\n\n\n\nOur plot shows that many birds arrive around September each year, and many species are observed most around November. We can also see that many species have a drop in observations from May to August (i.e., winter months)."
  },
  {
    "objectID": "posts/2024-05-10_ridgeline-plots/index.html#final-thoughts",
    "href": "posts/2024-05-10_ridgeline-plots/index.html#final-thoughts",
    "title": "Show seasonal species trends using a ridgeline plot",
    "section": "Final thoughts",
    "text": "Final thoughts\nAnd that’s it! Ridgeline plots are a simple and fast visualisation to use, and are a beautiful way to display ecological data.\nRidgeline plots do, however, have their limits. They don’t give an indication of how many observations there are of each bird species, or how they compare to each other, so they are mainly useful for displaying broader trends.\nKeep in mind that ridgeline plots might need adjusting to visualise your data clearly. Compare our first quick plot and our second refined plot above, for example. The smoother ridges in the first plot mask variation in our data, only made clearer with less smooth ridges in the second plot. Balancing the shape of your ridges will help improve the transparency of your data visualisation.\nIf you want to make other transparent summary visualisations, check out this post on how to make beeswarm and raincloud plots.\n\n\nExpand for session info\n\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Australia.utf8\n ctype    English_Australia.utf8\n tz       Australia/Sydney\n date     2024-05-09\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n dplyr       * 1.1.4   2023-11-17 [1] CRAN (R 4.3.2)\n forcats     * 1.0.0   2023-01-29 [1] CRAN (R 4.3.2)\n galah       * 2.0.2   2024-04-12 [1] CRAN (R 4.3.3)\n ggplot2     * 3.4.4   2023-10-12 [1] CRAN (R 4.3.1)\n ggridges    * 0.5.4   2022-09-26 [1] CRAN (R 4.3.2)\n htmltools   * 0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n lubridate   * 1.9.3   2023-09-27 [1] CRAN (R 4.3.2)\n ozmaps      * 0.4.5   2021-08-03 [1] CRAN (R 4.3.2)\n pilot       * 4.0.0   2022-07-13 [1] Github (olihawkins/pilot@f08cc16)\n purrr       * 1.0.2   2023-08-10 [1] CRAN (R 4.3.2)\n readr       * 2.1.5   2024-01-10 [1] CRAN (R 4.3.3)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n stringr     * 1.5.1   2023-11-14 [1] CRAN (R 4.3.2)\n tibble      * 3.2.1   2023-03-20 [1] CRAN (R 4.3.2)\n tidyr       * 1.3.1   2024-01-24 [1] CRAN (R 4.3.3)\n tidyverse   * 2.0.0   2023-02-22 [1] CRAN (R 4.3.2)\n\n [1] C:/Users/KEL329/R-packages\n [2] C:/Users/KEL329/AppData/Local/Programs/R/R-4.3.2/library\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "posts/2024-05-10_ridgeline-plots/index.html#footnotes",
    "href": "posts/2024-05-10_ridgeline-plots/index.html#footnotes",
    "title": "Show seasonal species trends using a ridgeline plot",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThis is considered one of the longest continuous journeys by any bird in the world.↩︎\nThanks to leap years, our Julian dates wont be perfectly to the day, but good enough for a quick summary.↩︎\nSpecifically, we multiplied the proportion of records by month number (e.g., January = 1, December = 12) so that birds with lots of records at the end of the year return a high number, whereas birds with lots of records at the beginning of the year return a low number.↩︎"
  },
  {
    "objectID": "posts/2024-02-12_species-lists/index.html",
    "href": "posts/2024-02-12_species-lists/index.html",
    "title": "Download a species list and cross-reference with conservation status lists",
    "section": "",
    "text": "Amanda Buyan\nDax Kellie\n\n\n\n12 February 2024\nKnowing what species inhabit an area is important for conservation and ecosystem management. In particular, it can help us find out how many known species are in a given area, whether each species is common or rare, and whether any species are threatened or endangered.\nIn this post, we will use the galah-python, geopandas, matplotlib and pywaffle packages to show you how to download a list of species within the Yass Valley in 2023, cross-reference this list with state-wide conservation status lists, and visualise the number of threatened and sensitive species in the region."
  },
  {
    "objectID": "posts/2024-02-12_species-lists/index.html#search-for-fields-in-galah",
    "href": "posts/2024-02-12_species-lists/index.html#search-for-fields-in-galah",
    "title": "Download a species list and cross-reference with conservation status lists",
    "section": "Search for fields in galah",
    "text": "Search for fields in galah\nTo find which fields and layers exist within galah-python to help us narrow our query, we can use the search_all() function. Let’s do a text search to find what fields contain information on “Local Government Areas”.\n\nimport galah\nimport geopandas as gpd\ngalah.search_all(fields=\"Local Government Areas\")\n\n        id                                        description    type link\n0     cl23  Local Government Areas 2012 deprecated LGA Bou...  layers     \n1    cl959  Local Government Areas 2011 Local Government A...  layers     \n2   cl2012  NSW Local Land Services Regions NSW Local Land...  layers     \n3  cl10923  Local Government Areas PSMA 2018 Local Governm...  layers     \n\n\nThe field cl109231 appears to contain the most recent data (from 2018). We can preview what values are within the field cl10923 using show_values().\n\ngalah.show_values(field=\"cl10923\")\n\n       field                      category\n0    cl10923                 BRISBANE CITY\n1    cl10923          EAST GIPPSLAND SHIRE\n2    cl10923          GREATER GEELONG CITY\n3    cl10923  PASTORAL UNINCORPORATED AREA\n4    cl10923          MORETON BAY REGIONAL\n..       ...                           ...\n555  cl10923                  WAGAIT SHIRE\n556  cl10923   WOORABINDA ABORIGINAL SHIRE\n557  cl10923  WUJAL WUJAL ABORIGINAL SHIRE\n558  cl10923    CHERBOURG ABORIGINAL SHIRE\n559  cl10923                 BELYUEN SHIRE\n\n[560 rows x 2 columns]\n\n\nThere are lots Local Government Areas! To check that Yass Valley is included, we can do another text search for values that match “YASS VALLEY”.\n\ngalah.search_values(field=\"cl10923\", value = \"YASS VALLEY\")\n\n     field             category\n0  cl10923  YASS VALLEY COUNCIL"
  },
  {
    "objectID": "posts/2024-02-12_species-lists/index.html#download-data",
    "href": "posts/2024-02-12_species-lists/index.html#download-data",
    "title": "Download a species list and cross-reference with conservation status lists",
    "section": "Download data",
    "text": "Download data\nUsing the field and category above, we can now build our query. We can use atlas_species() to return a species list, and use the filters argument to narrow our query. To add the observation count for each species, add counts=True.\n\nspecies_yass = galah.atlas_species(\n  filters=[\"cl10923=YASS VALLEY COUNCIL\", \"year=2023\"],\n  counts=True\n)\nspecies_yass\n\n                                                Species                       Species Name Scientific Name Authorship Taxon Rank   Kingdom      Phylum          Class           Order        Family        Genus               Vernacular Name  Number of records\n0     https://biodiversity.org.au/afd/taxa/5291343e-...                 Gymnorhina tibicen             (Latham, 1801)    species  Animalia    Chordata           Aves   Passeriformes     Artamidae   Gymnorhina             Australian Magpie                334\n1     https://biodiversity.org.au/afd/taxa/97a59c84-...    Rhipidura (Rhipidura) albiscapa                Gould, 1840    species  Animalia    Chordata           Aves   Passeriformes  Rhipiduridae    Rhipidura                  Grey Fantail                253\n2     https://biodiversity.org.au/afd/taxa/760401df-...          Malurus (Malurus) cyaneus              (Ellis, 1782)    species  Animalia    Chordata           Aves   Passeriformes     Maluridae      Malurus             Superb Fairy-wren                251\n3     https://biodiversity.org.au/afd/taxa/2c33a1fd-...         Cacatua (Cacatua) galerita             (Latham, 1790)    species  Animalia    Chordata           Aves  Psittaciformes    Cacatuidae      Cacatua      Sulphur-crested Cockatoo                239\n4     https://biodiversity.org.au/afd/taxa/5e0f496f-...  Platycercus (Platycercus) elegans             (Gmelin, 1788)    species  Animalia    Chordata           Aves  Psittaciformes   Psittacidae  Platycercus               Crimson Rosella                204\n...                                                 ...                                ...                        ...        ...       ...         ...            ...             ...           ...          ...                           ...                ...\n1107  https://id.biodiversity.org.au/taxon/apni/5141...                Pterostylis jonesii                 G.N.Backh.    species   Plantae  Charophyta  Equisetopsida     Asparagales   Orchidaceae  Pterostylis                           NaN                  1\n1108  https://id.biodiversity.org.au/taxon/apni/5141...             Pterostylis multiflora     (D.L.Jones) G.N.Backh.    species   Plantae  Charophyta  Equisetopsida     Asparagales   Orchidaceae  Pterostylis  Mountain Brown-tip Greenhood                  1\n1109  https://id.biodiversity.org.au/taxon/apni/5141...            Pterostylis pedunculata                      R.Br.    species   Plantae  Charophyta  Equisetopsida     Asparagales   Orchidaceae  Pterostylis                    Maroonhood                  1\n1110  https://id.biodiversity.org.au/taxon/apni/5141...                Thelymitra ixioides                        Sw.    species   Plantae  Charophyta  Equisetopsida     Asparagales   Orchidaceae   Thelymitra             Dotted Sun Orchid                  1\n1111  https://id.biodiversity.org.au/taxon/ausmoss/1...                 Thuidiopsis sparsa  (Hook.f. & Wilson) Broth.    species   Plantae   Bryophyta      Bryopsida        Hypnales   Thuidiaceae  Thuidiopsis                           NaN                  1\n\n[1112 rows x 12 columns]"
  },
  {
    "objectID": "posts/2024-02-12_species-lists/index.html#download-shapefile",
    "href": "posts/2024-02-12_species-lists/index.html#download-shapefile",
    "title": "Download a species list and cross-reference with conservation status lists",
    "section": "Download shapefile",
    "text": "Download shapefile\nTo retrieve the spatial outline of Yass Valley, let’s download the latest Local Government Areas data from the Australian Bureau of Statistics Digital Boundary files page. Find “Local Government Areas - 2023 - Shapefile” and click “Download ZIP”. Save the zip folder in your current directory and unzip it.\nWe’ll use read_file() from geopandas to load our shapefile.\n\nLGAs_2023 = gpd.read_file(\"LGA_2023_AUST_GDA2020.shp\")\nLGAs_2023\n\n\n\n    LGA_CODE23                             LGA_NAME23 STE_CODE21                    STE_NAME21 AUS_CODE21         AUS_NAME21    AREASQKM                                         LOCI_URI21                                           geometry\n0        10050                                 Albury          1               New South Wales        AUS          Australia    305.6386  https://linked.data.gov.au/dataset/asgsed3/LGA...  POLYGON ((146.86566 -36.07292, 146.86512 -36.0...\n1        10180                               Armidale          1               New South Wales        AUS          Australia   7809.4406  https://linked.data.gov.au/dataset/asgsed3/LGA...  POLYGON ((152.38816 -30.52639, 152.38812 -30.5...\n2        10250                                Ballina          1               New South Wales        AUS          Australia    484.9692  https://linked.data.gov.au/dataset/asgsed3/LGA...  MULTIPOLYGON (((153.57106 -28.87381, 153.57106...\n3        10300                              Balranald          1               New South Wales        AUS          Australia  21690.7493  https://linked.data.gov.au/dataset/asgsed3/LGA...  POLYGON ((143.00433 -33.78164, 143.01538 -33.7...\n4        10470                               Bathurst          1               New South Wales        AUS          Australia   3817.8645  https://linked.data.gov.au/dataset/asgsed3/LGA...  POLYGON ((149.84877 -33.52784, 149.84864 -33.5...\n..         ...                                    ...        ...                           ...        ...                ...         ...                                                ...                                                ...\n561      89799  Migratory - Offshore - Shipping (ACT)          8  Australian Capital Territory        AUS          Australia         NaN  https://linked.data.gov.au/dataset/asgsed3/LGA...                                               None\n562      99399            Unincorp. Other Territories          9             Other Territories        AUS          Australia    105.8806  https://linked.data.gov.au/dataset/asgsed3/LGA...  MULTIPOLYGON (((167.94747 -29.12757, 167.94748...\n563      99499                  No usual address (OT)          9             Other Territories        AUS          Australia         NaN  https://linked.data.gov.au/dataset/asgsed3/LGA...                                               None\n564      99799   Migratory - Offshore - Shipping (OT)          9             Other Territories        AUS          Australia         NaN  https://linked.data.gov.au/dataset/asgsed3/LGA...                                               None\n565      ZZZZZ                      Outside Australia          Z             Outside Australia        ZZZ  Outside Australia         NaN  https://linked.data.gov.au/dataset/asgsed3/LGA...                                               None\n\n[566 rows x 9 columns]\n\n\nNow let’s use to_crs() to set the Coordinate Reference System (CRS) of our shapefile to EPSG:4326 (the standard used in cartography and GPS, also known as WGS84) so that it matches the projection of our data from the ALA 2.\n\nLGAs_2023 = LGAs_2023.to_crs(4326)\n\nNext we can filter our shapefile to only Yass Valley. The column LGA_NAME23 contains area names, and we can filter our Dataframe to only rows where LGA_NAME23 is equal to Yass Valley. We are left with a single polygon shape of Yass Valley.\n\nyass_valley = LGAs_2023[LGAs_2023['LGA_NAME23'] == \"Yass Valley\"]\nyass_valley[\"geometry\"]\n\n127    POLYGON ((148.58152 -34.80679, 148.58153 -34.8...\nName: geometry, dtype: geometry"
  },
  {
    "objectID": "posts/2024-02-12_species-lists/index.html#download-data-1",
    "href": "posts/2024-02-12_species-lists/index.html#download-data-1",
    "title": "Download a species list and cross-reference with conservation status lists",
    "section": "Download data",
    "text": "Download data\nNow that yass_valley contains our LGA shape, we can build our query. We can use atlas_species() to return a species list, passing our shape to the polygon argument of atlas_species() and specifying the year to filters. To add the observation count for each species, add counts=True.\n\nspecies_yass = galah.atlas_species(\n  polygon=yass_valley[\"geometry\"][127],\n  filters=\"year=2023\",\n  counts=True\n  )\nspecies_yass\n\n                                                Species                       Species Name Scientific Name Authorship Taxon Rank   Kingdom      Phylum          Class           Order        Family        Genus               Vernacular Name  Number of records\n0     https://biodiversity.org.au/afd/taxa/5291343e-...                 Gymnorhina tibicen             (Latham, 1801)    species  Animalia    Chordata           Aves   Passeriformes     Artamidae   Gymnorhina             Australian Magpie                440\n1     https://biodiversity.org.au/afd/taxa/760401df-...          Malurus (Malurus) cyaneus              (Ellis, 1782)    species  Animalia    Chordata           Aves   Passeriformes     Maluridae      Malurus             Superb Fairy-wren                361\n2     https://biodiversity.org.au/afd/taxa/2c33a1fd-...         Cacatua (Cacatua) galerita             (Latham, 1790)    species  Animalia    Chordata           Aves  Psittaciformes    Cacatuidae      Cacatua      Sulphur-crested Cockatoo                304\n3     https://biodiversity.org.au/afd/taxa/97a59c84-...    Rhipidura (Rhipidura) albiscapa                Gould, 1840    species  Animalia    Chordata           Aves   Passeriformes  Rhipiduridae    Rhipidura                  Grey Fantail                296\n4     https://biodiversity.org.au/afd/taxa/5e0f496f-...  Platycercus (Platycercus) elegans             (Gmelin, 1788)    species  Animalia    Chordata           Aves  Psittaciformes   Psittacidae  Platycercus               Crimson Rosella                258\n...                                                 ...                                ...                        ...        ...       ...         ...            ...             ...           ...          ...                           ...                ...\n1177  https://id.biodiversity.org.au/taxon/apni/5141...                Pterostylis jonesii                 G.N.Backh.    species   Plantae  Charophyta  Equisetopsida     Asparagales   Orchidaceae  Pterostylis                           NaN                  1\n1178  https://id.biodiversity.org.au/taxon/apni/5141...             Pterostylis multiflora     (D.L.Jones) G.N.Backh.    species   Plantae  Charophyta  Equisetopsida     Asparagales   Orchidaceae  Pterostylis  Mountain Brown-tip Greenhood                  1\n1179  https://id.biodiversity.org.au/taxon/apni/5141...            Pterostylis pedunculata                      R.Br.    species   Plantae  Charophyta  Equisetopsida     Asparagales   Orchidaceae  Pterostylis                    Maroonhood                  1\n1180  https://id.biodiversity.org.au/taxon/apni/5141...                Thelymitra ixioides                        Sw.    species   Plantae  Charophyta  Equisetopsida     Asparagales   Orchidaceae   Thelymitra             Dotted Sun Orchid                  1\n1181  https://id.biodiversity.org.au/taxon/ausmoss/1...                 Thuidiopsis sparsa  (Hook.f. & Wilson) Broth.    species   Plantae   Bryophyta      Bryopsida        Hypnales   Thuidiaceae  Thuidiopsis                           NaN                  1\n\n[1182 rows x 12 columns]"
  },
  {
    "objectID": "posts/2024-02-12_species-lists/index.html#footnotes",
    "href": "posts/2024-02-12_species-lists/index.html#footnotes",
    "title": "Download a species list and cross-reference with conservation status lists",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nEach spatial layer has a two letter code, along with a number to identify it. The abbreviations are as follows: * cl = contextual layer (i.e. boundaries of LGAs, Indigenous Protected Areas, States/Territories etc.)\n* 10923 = number associated with the spatial layer in the atlas↩︎\nCheck out this post for a better explanation of what CRS is and how it affects maps.↩︎\nThese are the same two lists that you can access in galah-python, available from the Atlas of Living Australia. Keep in mind that if you use an external list, data cleaning may be required before matching species names.↩︎\nTo create our colour palette, we used David Nichol’s website to help colours that are colour-blind friendly, the ColorHexa website create a gradient between 2 colours, and Coolors to adjust the colours & shades.↩︎"
  },
  {
    "objectID": "posts/2023-12-18_beginners-guide-make-a-map/index.html",
    "href": "posts/2023-12-18_beginners-guide-make-a-map/index.html",
    "title": "Beginner’s guide: Make a quick map of species observations in Python and R",
    "section": "",
    "text": "Amanda Buyan\nDax Kellie\n\n\n\n18 December 2023\nMaps are one of the most common and useful data visualisation tools in an ecologist’s tool belt. Making a quick and simple map of species observations is especially useful when first investigating where a species has occurred. Viewing locations of points can also help to understand the extent of your data (and spot possible errors or outliers).\nIn this post, we will use either Python or R to make a map of observations of Peron’s tree frog (Litoria peronii) in New South Wales since 2018 recorded by FrogID."
  },
  {
    "objectID": "posts/2023-12-18_beginners-guide-make-a-map/index.html#download-data",
    "href": "posts/2023-12-18_beginners-guide-make-a-map/index.html#download-data",
    "title": "Beginner’s guide: Make a quick map of species observations in Python and R",
    "section": "Download data",
    "text": "Download data\nPeron’s Tree frog is one of the most recorded frog species in the Atlas of Living Australia. Growing up to 7cm in length, it is well-known for its eyes which often look like they have a black cross on them!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLeft: Litoria peronii (Giverny CC-BY-NC 4.0 (Int), Middle: Litoria peronii (debtaylor142 CC-BY-NC 4.0 (Int)), Right: Litoria peronii (Ernst Weiher, iNaturalist CC-BY-NC 4.0 (Int))\n\nFirst, let’s import galah-python.\n\nimport galah\n\n\nSearch for taxa\nWhen trying to download data about any species or clade, we can search using search_taxa(). It’s recommended to use search_taxa() to check whether a taxonomic search returns what you were expecting (even if you know the scientific name)! We can check taxonomic information about Peron’s tree frog with search_taxa(), which returns extra details about the species when a match is found.\n\ngalah.search_taxa(\"Litoria peronii\")\n\n    scientificName scientificNameAuthorship  ...     vernacularName   issues\n0  Litoria peronii          (Tschudi, 1838)  ...  Peron's Tree Frog  noIssue\n\n[1 rows x 12 columns]\n\n\n\n\nSearch for fields\nNext, we can search for fields and field IDs for filtering our query. In this case, we are interested in filtering to a specific year, state/territory and data resource.\nWe can start by searching for any fields containing the word “year” using search_all().\n\ngalah.search_all(\n  fields=\"year\"\n  )\n\n\n\n                    id                                        description   type                                               link\n0                 year  The year in which an occurrence was observed. ...  field  https://github.com/AtlasOfLivingAustralia/ala-...\n1         endDayOfYear          http://rs.tdwg.org/dwc/terms/endDayOfYear  field                                                NaN\n2        datePrecision  The precision of the date information for the ...  field                                                NaN\n3       occurrenceYear  Year ranges for a search. Calculated based on ...  field                                                NaN\n4       startDayOfYear        http://rs.tdwg.org/dwc/terms/startDayOfYear  field                                                NaN\n5  namePublishedInYear   http://rs.tdwg.org/dwc/terms/namePublishedInYear  field                                                NaN\n\n\nWe can do the same kind of search to find fields with information of australian states/territories and data resource names.\n\ngalah.search_all(\n  fields=\"states\"\n  )\n\n\n\n        id                                        description    type link\n0     cl22  Australian States and Territories Australian S...  layers     \n1    cl927  States including coastal waters States (includ...  layers     \n2   cl2013  ASGS Australian States and Territories Austral...  layers     \n3  cl10902  Forests of Australia (2013) v2.0 Forests of Au...  layers     \n4  cl10903  Tenure of Australia's forests (2013) v2.0 Tenu...  layers     \n5  cl10925     PSMA States (2016) Australian State boundaries  layers     \n6  cl10930  NRM Regions 2017 The Natural Resource Manageme...  layers     \n\n\n\ngalah.search_all(\n  fields=\"dataresourcename\"\n  )\n\n\n\n                     id                                        description   type link\n0       dataResourceUid  A list (concatenated and separated) of prepara...  field  NaN\n1      dataResourceName  The data resource that supplies the record. Th...  field  NaN\n2   raw_dataResourceUid                                                NaN  field  NaN\n3  raw_dataResourceName                                                NaN  field  NaN\n\n\nIf you are ever uncertain which field ID to choose, you can use show_values() to see what possible values are within a field. For example, let’s see what values are in field ID cl22.\n\ngalah.show_values(field=\"cl22\")\n\n\n\n   field                      category\n0   cl22               New South Wales\n1   cl22                      Victoria\n2   cl22                    Queensland\n3   cl22               South Australia\n4   cl22             Western Australia\n5   cl22            Northern Territory\n6   cl22  Australian Capital Territory\n7   cl22                      Tasmania\n8   cl22                      Unknown1\n9   cl22             Coral Sea Islands\n10  cl22   Ashmore and Cartier Islands\n\n\nWe can also search for a value using search_values(), which might be handy to check that “FrogID” is a value in dataResourceName.\n\ngalah.search_values(field=\"dataResourceName\", value=\"frogid\")\n\n\n\n              field category\n0  dataResourceName   FrogID\n\n\n\n\nDownload observations\nNow we are ready to build our query to download observations of Peron’s tree frog in New South Wales since 2018 recorded by FrogID.\nFor those unfamiliar with Australian geography, New South Wales is this one:\n\n\n\n\n\n\n\n\n\nFirst, let’s find the number of records that match our query. This is good practice before downloading occurrence records because you can check exactly how many records you are intending to download (and avoid an accidental massive download)!\nWe’ll use atlas_counts() to download record counts, specifying the taxon using the taxa argument, and narrowing the year range, state/territory and data resource using the filters argument.\n\ngalah.atlas_counts(                      # *Download record counts*\n    taxa=\"litoria peronii\",              # *of Peron's tree frog*\n    filters=[\"year&gt;=2018\",               # *since 2018*\n             \"cl22=New South Wales\",     # *in New South Wales*\n             \"dataResourceName=FrogID\"]  # *by FrogID*\n)\n\n   totalRecords\n0         27647\n\n\nNow we can use atlas_occurrences() to download occurrence records, which returns each observation’s location coordinates and event date.\nYou will need to first provide a registered email with the ALA using galah_config() before retrieving records.\n\ngalah.galah_config(email = \"your-email-here\")\nfrogs = galah.atlas_occurrences(\n    taxa=\"litoria peronii\",\n    filters=[\"year&gt;=2018\",\n             \"cl22=New South Wales\",\n             \"dataResourceName=FrogID\"]\n)\nfrogs\n\n\n\n       decimalLatitude  decimalLongitude             eventDate   scientificName                                     taxonConceptID                              recordID dataResourceName occurrenceStatus\n0           -37.246800        149.375000  2020-12-27T00:00:00Z  Litoria peronii  https://biodiversity.org.au/afd/taxa/c584f24b-...  a5cd2fcd-5225-4d19-977c-b16ca5e8f1dd           FrogID          PRESENT\n1           -37.089036        149.699526  2020-12-14T00:00:00Z  Litoria peronii  https://biodiversity.org.au/afd/taxa/c584f24b-...  eebde5ef-cac4-4897-af00-cb2e39a0684f           FrogID          PRESENT\n2           -37.077693        149.874402  2018-01-06T00:00:00Z  Litoria peronii  https://biodiversity.org.au/afd/taxa/c584f24b-...  35340478-97c1-48a4-a463-991fe3a8daa0           FrogID          PRESENT\n3           -37.077241        149.874787  2018-01-06T00:00:00Z  Litoria peronii  https://biodiversity.org.au/afd/taxa/c584f24b-...  a7abc9f3-362f-469e-9076-5b55a2447b69           FrogID          PRESENT\n4           -37.070746        149.896011  2020-12-13T00:00:00Z  Litoria peronii  https://biodiversity.org.au/afd/taxa/c584f24b-...  1cc9dda8-f2d4-4f55-acf6-11c93b26da9e           FrogID          PRESENT\n...                ...               ...                   ...              ...                                                ...                                   ...              ...              ...\n27642       -28.207514        153.442592  2018-11-15T00:00:00Z  Litoria peronii  https://biodiversity.org.au/afd/taxa/c584f24b-...  b094fed1-5bff-4df8-b556-cabd693c533a           FrogID          PRESENT\n27643       -28.207472        153.442497  2018-11-15T00:00:00Z  Litoria peronii  https://biodiversity.org.au/afd/taxa/c584f24b-...  5cc24fbd-8c6b-4a76-9b28-fec76ee08f37           FrogID          PRESENT\n27644       -28.207442        153.442328  2020-02-07T00:00:00Z  Litoria peronii  https://biodiversity.org.au/afd/taxa/c584f24b-...  61aa50a1-4c79-4fc3-b3ab-93538faa37b1           FrogID          PRESENT\n27645       -28.207108        153.443021  2021-02-19T00:00:00Z  Litoria peronii  https://biodiversity.org.au/afd/taxa/c584f24b-...  0324b8d1-77b0-4bf3-9ec2-6ad9efff18f2           FrogID          PRESENT\n27646       -28.186157        153.445556  2018-11-16T00:00:00Z  Litoria peronii  https://biodiversity.org.au/afd/taxa/c584f24b-...  bcf83a54-a900-4265-960a-9436356a7107           FrogID          PRESENT\n\n[27647 rows x 8 columns]"
  },
  {
    "objectID": "posts/2023-12-18_beginners-guide-make-a-map/index.html#make-a-map",
    "href": "posts/2023-12-18_beginners-guide-make-a-map/index.html#make-a-map",
    "title": "Beginner’s guide: Make a quick map of species observations in Python and R",
    "section": "Make a map",
    "text": "Make a map\nIt’s time to make our map!\nIn order to draw our map of New South Wales, we’ll download a shapefile of the latest state and territory boundaries from the Australian Bureau of statistics. Download the “States and Territories - 2021 - Shapefile” zip file, and save the zip file in the same folder you are coding in.\nLet’s load our States and Territories shapefile with read_file() and save it as states. Then, we will filter the shapefile to New South Wales and quickly plot it (specifying that the edges are black, the inside is white, and the figure size is 12 x 6 inches).\n\nfrom matplotlib import pyplot as plt\nimport geopandas as gpd\n\n# Load Australian state and territory boundaries\nstates = gpd.read_file(\"STE_2021_AUST_GDA94.shp\")\n\n# Filter to New South Wales and plot\nstates[states[\"STE_NAME21\"] == \"New South Wales\"].plot(edgecolor = \"#5A5A5A\", linewidth = 0.5, facecolor = \"white\", figsize = (12,6))\n\n\n\n\n\n\n\n\n\n\nOur shapefile has plotted nicely, but there are many different ways to display our shape of NSW, which exists on a spherical globe (the Earth), onto a flat surface (our map). Our shapefile already has a projection, determined by its Coordinate Reference System (CRS) of GDA94.\n\n# see the details of our shape's CRS\nnsw.crs\n\n&lt;Geographic 2D CRS: EPSG:4283&gt;\nName: GDA94\nAxis Info [ellipsoidal]:\n- Lat[north]: Geodetic latitude (degree)\n- Lon[east]: Geodetic longitude (degree)\nArea of Use:\n- name: Australia including Lord Howe Island, Macquarie Island, Ashmore and Cartier Islands, Christmas Island, Cocos (Keeling) Islands, Norfolk Island. All onshore and offshore.\n- bounds: (93.41, -60.55, 173.34, -8.47)\nDatum: Geocentric Datum of Australia 1994\n- Ellipsoid: GRS 1980\n- Prime Meridian: Greenwich\n\n\nTo make it clearer how the CRS changes the projection of a map, here are 3 maps of NSW projected with 3 different CRS:\n\nGDA94 (the current projection of our NSW shapefile)\nEPSG:8058 (a state/territory-specific projection for NSW)\nEPSG:2955 (intended for Canadian territories)\n\n\nCode\nnsw.plot(edgecolor = \"#5A5A5A\", facecolor = \"white\")\nnsw_gda2020 = nsw.to_crs(8058)\nnsw_gda2020.plot(edgecolor = \"#5A5A5A\", facecolor = \"white\")\nnsw_nad83 = nsw.to_crs(2955)\nnsw_nad83.plot(edgecolor = \"#5A5A5A\", facecolor = \"white\")\n\n\n\n\n\n\n\n\nGDA94\n\n\n\n\n\n\n\n\n\nEPSG:8058\n\n\n\n\n\n\n\n\n\nEPSG:2955\n\n\n\n\n\n\nThe CRS projection of ALA data is EPSG:4326 (also known as “WGS84”). Reprojecting the CRS of our shapefile allows us to make sure the points of our data align correctly with our shapefile.\n\nnsw = nsw.to_crs(4326)\n\nNow, we will add species observations to our map. First, we will plot our reprojected shapefile. Then, we will overlay a scatter plot using decimalLongitude as your x axis and decimalLatitude as your y axis. We’ll set the colour (c) and adjust the alpha to make our points partially transparent.\n\nnsw.plot(edgecolor = \"#5A5A5A\", linewidth = 0.5, facecolor = \"white\", figsize = (12,6))\nplt.scatter(frogs['decimalLongitude'],frogs['decimalLatitude'], c = \"#6fab3f\", alpha = 0.5)\n\n\n\n\n\n\n\n\nFor some final touches (to make the map prettier), we can add a title and remove the border.\nWe’ll add a custom Google font, Roboto, by downloading it from Google Fonts, saving the folder in your current directory, unzipping the folder, and loading it with the matplotlib library.\n\nimport matplotlib as mpl\nfrom matplotlib import font_manager\nfont_files = font_manager.findSystemFonts(fontpaths=\"Roboto/\")\nfor ff in font_files:\n  font_manager.fontManager.addfont(ff)\n\nFor further information or troubleshooting tips for installing Roboto on your computer, this post is an excellent guide, as well as the matplotlib.font_manager documentation.\n\nnsw.plot(edgecolor = \"#5A5A5A\", linewidth = 0.5, facecolor = \"white\", figsize = (12,6))\nplt.scatter(frogs['decimalLongitude'],frogs['decimalLatitude'], c = \"#6fab3f\", alpha = 0.5, label = \"Litoria peronii\")\nplt.suptitle(\"Peron's tree frog\",fontsize=36,font='Roboto')\nplt.title(\"FrogID observations in New South Wales since 2018\",fontsize=28,font='Roboto')\nplt.axis('off')\n\n\n\n(140.0937672995, 160.0147167105, -37.972572696499995, -27.6894786335)\n\n\n\n\n\n\n\n\n\nTo save your plot in your current folder, you can use:\n\nplt.savefig(\"perons_tree_frog_nsw.png\")"
  },
  {
    "objectID": "posts/2023-12-18_beginners-guide-make-a-map/index.html#final-thoughts",
    "href": "posts/2023-12-18_beginners-guide-make-a-map/index.html#final-thoughts",
    "title": "Beginner’s guide: Make a quick map of species observations in Python and R",
    "section": "Final thoughts",
    "text": "Final thoughts\nWe hope this post has helped make the basic steps of making a map simple and easy to understand. For more advanced mapping in Python, check out our ALA Labs article on how to map invasive species.\n\n\nExpand for session info\n\n\n\n-----\ngalah               0.8.1\ngeopandas           0.14.1\nmatplotlib          3.8.2\nnatsort             8.4.0\npandas              2.1.3\nsession_info        1.0.0\n-----\nPython 3.12.0 (tags/v3.12.0:0fb18b0, Oct  2 2023, 13:03:39) [MSC v.1935 64 bit (AMD64)]\nWindows-10-10.0.19045-SP0\n-----\nSession information updated at 2024-02-13 11:02"
  },
  {
    "objectID": "posts/2023-12-18_beginners-guide-make-a-map/index.html#download-data-1",
    "href": "posts/2023-12-18_beginners-guide-make-a-map/index.html#download-data-1",
    "title": "Beginner’s guide: Make a quick map of species observations in Python and R",
    "section": "Download data",
    "text": "Download data\nPeron’s Tree frog is one of the most recorded frog species in the Atlas of Living Australia. Growing up to 7cm in length, it is well-known for its eyes which often look like they have a black cross on them!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLeft: Litoria peronii (Giverny CC-BY-NC 4.0 (Int), Middle: Litoria peronii (debtaylor142 CC-BY-NC 4.0 (Int)), Right: Litoria peronii (Ernst Weiher, iNaturalist CC-BY-NC 4.0 (Int))\n\nFirst, let’s load some packages.\n\nlibrary(galah)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(sf)\nlibrary(here)\nlibrary(showtext)\n\n\nSearch for taxa\nWhen trying to download data about any species or clade, we can search using search_taxa(). It’s recommended to use search_taxa() to check whether a taxonomic search returns what you were expecting (even if you know the scientific name)! We can check taxonomic information about Peron’s tree frog with search_taxa(), which returns extra details about the species when a match is found.\n\nsearch_taxa(\"Litoria peronii\")\n\n# A tibble: 1 × 15\n  search_term     scientific_name scientific_name_autho…¹ taxon_concept_id rank \n  &lt;chr&gt;           &lt;chr&gt;           &lt;chr&gt;                   &lt;chr&gt;            &lt;chr&gt;\n1 Litoria peronii Litoria peronii (Tschudi, 1838)         https://biodive… spec…\n# ℹ abbreviated name: ¹​scientific_name_authorship\n# ℹ 10 more variables: match_type &lt;chr&gt;, kingdom &lt;chr&gt;, phylum &lt;chr&gt;,\n#   class &lt;chr&gt;, order &lt;chr&gt;, family &lt;chr&gt;, genus &lt;chr&gt;, species &lt;chr&gt;,\n#   vernacular_name &lt;chr&gt;, issues &lt;chr&gt;\n\n\n\n\nSearch for fields\nNext, we can search for fields and field IDs for filtering our query. In this case, we are interested in filtering to a specific year, state/territory and data resource.\nWe can start by searching for any fields containing the word “year” using search_all().\n\nsearch_all(fields, \"year\")\n\n# A tibble: 8 × 3\n  id                  description            type  \n  &lt;chr&gt;               &lt;chr&gt;                  &lt;chr&gt; \n1 year                Year                   fields\n2 raw_year            Year (unprocessed)     fields\n3 endDayOfYear        End Day Of Year        fields\n4 startDayOfYear      Start Day Of Year      fields\n5 occurrenceYear      Date (by decade)       fields\n6 raw_endDayOfYear    &lt;NA&gt;                   fields\n7 raw_startDayOfYear  &lt;NA&gt;                   fields\n8 namePublishedInYear Name Published In Year fields\n\n\nWe can do the same kind of search to find fields with information of australian states/territories and data resource names.\n\nsearch_all(fields, \"states\")\n\n# A tibble: 5 × 3\n  id       description                            type  \n  &lt;chr&gt;    &lt;chr&gt;                                  &lt;chr&gt; \n1 cl2013   ASGS Australian States and Territories fields\n2 cl22     Australian States and Territories      fields\n3 cl927    States including coastal waters        fields\n4 cl10925  PSMA States (2016)                     fields\n5 cl110925 PSMA States - Abbreviated (2016)       fields\n\nsearch_all(fields, \"resource\")\n\n# A tibble: 8 × 3\n  id                     description              type  \n  &lt;chr&gt;                  &lt;chr&gt;                    &lt;chr&gt; \n1 resourceID             Resource ID              fields\n2 dataResourceUid        Dataset                  fields\n3 dataResourceName       Dataset                  fields\n4 relatedResourceID      Related Resource ID      fields\n5 raw_dataResourceUid    Dataset (unprocessed)    fields\n6 raw_dataResourceName   Dataset (unprocessed)    fields\n7 relationshipOfResource Relationship Of Resource fields\n8 resourceRelationshipID Resource Relationship ID fields\n\n\nIf you are ever uncertain which field ID to choose, you can use show_values() to see what possible values are within a field. For example, let’s see what values are in field ID cl22.\n\nsearch_all(fields, \"cl22\") |&gt;\n  show_values()\n\n• Showing values for 'cl22'.\n\n\n# A tibble: 11 × 1\n   cl22                        \n   &lt;chr&gt;                       \n 1 New South Wales             \n 2 Victoria                    \n 3 Queensland                  \n 4 South Australia             \n 5 Western Australia           \n 6 Northern Territory          \n 7 Australian Capital Territory\n 8 Tasmania                    \n 9 Unknown1                    \n10 Coral Sea Islands           \n11 Ashmore and Cartier Islands \n\n\nWe can also search for a value using search_values(), which might be handy to check that “FrogID” is a value in dataResourceName.\n\nsearch_all(fields, \"dataResourceName\") |&gt;\n  search_values(\"FrogID\")\n\n! Search returned 2 matched fields.\n• Showing values for 'dataResourceName'.\n\n\n# A tibble: 1 × 1\n  dataResourceName\n  &lt;chr&gt;           \n1 FrogID          \n\n\n\n\nDownload observations\nNow we are ready to build our query to download observations of Peron’s tree frog in New South Wales since 2018 recorded by FrogID.\nFor those unfamiliar with Australian geography, New South Wales is this one:\n\n\n\n\n\n\n\n\n\nFirst, let’s find the number of records that match our query. This is good practice before downloading occurrence records because you can check exactly how many records you are intending to download (and avoid an accidental massive download)!\nWe’ll use atlas_counts() to download record counts, specifying the taxon using galah_identify(), and narrowing the year range, state/territory and data resource using galah_filter().\n\ngalah_call() |&gt;                                 # Begin a query\n  galah_identify(\"Litoria peronii\") |&gt;          # Peron's tree frog\n  galah_filter(year &gt;= 2018,                    # since 2018\n               cl22 == \"New South Wales\",       # in New South Wales\n               dataResourceName == \"FrogID\") |&gt; # by FrogID\n  atlas_counts()                                # Download record counts\n\n# A tibble: 1 × 1\n  count\n  &lt;int&gt;\n1 27647\n\n\nNow we can use atlas_occurrences() to download occurrence records, which returns each observation’s location coordinates and event date.\nYou will need to first provide a registered email with the ALA using galah_config() before retrieving records.\n\ngalah_config(email = \"your-email-here\")\n\n\nfrogs &lt;- galah_call() |&gt;\n  galah_identify(\"Litoria peronii\") |&gt;\n  galah_filter(year &gt;= 2018,\n               cl22 == \"New South Wales\",\n               dataResourceName == \"FrogID\") |&gt;\n  atlas_occurrences()\nfrogs\n\n# A tibble: 27,647 × 8\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 0008c41d-fd35… Litoria peron… https://biodi…           -33.2             152.\n 2 000c1c20-bec3… Litoria peron… https://biodi…           -33.0             150.\n 3 000e46ad-9ace… Litoria peron… https://biodi…           -31.3             149.\n 4 001229c0-4c48… Litoria peron… https://biodi…           -33.7             150.\n 5 0014b8ff-ddd5… Litoria peron… https://biodi…           -33.4             151.\n 6 00183dd1-c9cd… Litoria peron… https://biodi…           -36.6             150.\n 7 002088e5-3a73… Litoria peron… https://biodi…           -32.1             150.\n 8 002108e1-9933… Litoria peron… https://biodi…           -33.7             151.\n 9 00251c30-9dfd… Litoria peron… https://biodi…           -34.3             151.\n10 00259fce-87db… Litoria peron… https://biodi…           -30.5             153.\n# ℹ 27,637 more rows\n# ℹ 3 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;"
  },
  {
    "objectID": "posts/2023-12-18_beginners-guide-make-a-map/index.html#make-a-map-1",
    "href": "posts/2023-12-18_beginners-guide-make-a-map/index.html#make-a-map-1",
    "title": "Beginner’s guide: Make a quick map of species observations in Python and R",
    "section": "Make a map",
    "text": "Make a map\nIt’s time to make our map!\nIn order to draw our map of New South Wales, we’ll download a shapefile of the latest state and territory boundaries from the Australian Bureau of Statistics. Download the “States and Territories - 2021 - Shapefile” zip file, and save the zip file in the same folder you are coding in.\nLet’s load our States and Territories shapefile with read_file() and save it as states. Then, we will filter the shapefile to New South Wales and quickly plot it to check it plots correctly (specifying that the border is grey, and the inside is white).\n\n# Load Australian state and territory boundaries\nstates &lt;- st_read(here(\"STE_2021_AUST_GDA94.shp\"),\n                  quiet = TRUE)\n\n# Filter to New South Wales\nnsw &lt;- states |&gt; \n  filter(STE_NAME21 == \"New South Wales\")\n\n# Plot\nggplot() +\n  geom_sf(data = nsw,\n          colour = \"grey60\",\n          fill = \"white\")\n\n\n\n\n\n\n\n\n\n\nOur shapefile has plotted nicely, but there are many different ways to display our shape of NSW, which exists on a spherical globe (the Earth), onto a flat surface (our map). Our shapefile already has a projection, determined by its Coordinate Reference System (CRS) of GDA94.\n\n# see the details of our shape's geometry\nnsw |&gt; st_geometry()\n\nGeometry set for 1 feature \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 140.9993 ymin: -37.50516 xmax: 159.1092 ymax: -28.15689\nGeodetic CRS:  GDA94\n\n\nMULTIPOLYGON (((159.0623 -31.50887, 159.0622 -3...\n\n\nTo make it clearer how the CRS changes the projection of a map, here are 3 maps of NSW projected with 3 different CRS:\n\nGDA94 (the current projection of our NSW shapefile)\nEPSG:8058 (a state/territory-specific projection for NSW)\nEPSG:2955 (intended for Canadian territories)\n\n\n\nCode\np1 &lt;- nsw |&gt; \n  ggplot() +\n  geom_sf(colour = \"grey60\",\n          fill = \"white\")\n\np2 &lt;- nsw |&gt; \n  st_transform(crs = st_crs(8058)) |&gt;\n  ggplot() +\n  geom_sf(colour = \"grey60\",\n          fill = \"white\")\n\np3 &lt;- nsw |&gt; \n  st_transform(crs = st_crs(2955)) |&gt;\n  ggplot() +\n  geom_sf(colour = \"grey60\",\n          fill = \"white\")\n\n\n\n\n\n\n\n\n\n\n\nGDA94\n\n\n\n\n\n\n\nEPSG:8058\n\n\n\n\n\n\n\nEPSG:2955\n\n\n\n\n\nData from the ALA use CRS EPSG:4326 (also known as “WGS84”). Reprojecting our shapefile to the same CRS allows us to make sure the points of our data align correctly with our shapefile.\n\nnsw &lt;- nsw |&gt;\n  st_transform(crs = st_crs(4326))\n\nNow, we will add species observations to our map. First, we will plot our reprojected shapefile. Then, we will overlay a scatter plot using decimalLongitude as your x axis and decimalLatitude as your y axis. We’ll set the colour and adjust the alpha to make our points partially transparent.\n\nggplot() +\n  geom_sf(data = nsw,\n          colour = \"grey60\",\n          fill = \"white\") +\n  geom_point(data = frogs,\n             aes(x = decimalLongitude,\n                 y = decimalLatitude),\n             colour = \"#6fab3f\",\n             alpha = 0.5,\n             size = 1.1)\n\n\n\n\n\n\n\n\nFor some final touches (to make the map prettier), we can add a centred title and add a minimal theme.\nWe’ll add a custom Google font, Roboto, using the showtext package, loading it into R with font_add_google().\n\n# Add font\nfont_add_google(\"Roboto\")\nshowtext_auto(enable = TRUE)\n\nggplot() +\n  geom_sf(data = nsw,\n          colour = \"grey60\",\n          fill = \"white\") +\n  geom_point(data = frogs,\n             mapping = aes(x = decimalLongitude,\n                           y = decimalLatitude),\n             colour = \"#6fab3f\",\n             alpha = 0.5,\n             size = 1.1) +\n  labs(title = \"Peron's tree frog\",\n       subtitle = \"FrogID observations in New South Wales since 2018\") +\n  theme_void() + \n  theme(\n    plot.title = element_text(hjust = 0.5,          # horizontally centre\n                              family = \"Roboto\",    # add font\n                              size = 31),           # change font size\n    plot.subtitle = element_text(hjust = 0.5,       # horizontally centre\n                                 family = \"Roboto\", # add font\n                                 size = 25)         # change font size\n  )\n\n\n\n\n\n\n\n\nTo save your plot in your current folder, you can use:\n\n# set dpi for text\nshowtext_opts(dpi = 320)\n\n# save\nggsave(here(\"map_perons-tree-frog.png\"),\n       height = 9, width = 10,\n       unit = \"in\",\n       dpi = 320)"
  },
  {
    "objectID": "posts/2023-12-18_beginners-guide-make-a-map/index.html#final-thoughts-1",
    "href": "posts/2023-12-18_beginners-guide-make-a-map/index.html#final-thoughts-1",
    "title": "Beginner’s guide: Make a quick map of species observations in Python and R",
    "section": "Final thoughts",
    "text": "Final thoughts\nWe hope this post has helped make the basic steps of making a map simple and easy to understand. For more advanced mapping in R, check out our ALA Labs articles on exploring dingo observations and how to make a choropleth map with multiple colour scales.\n\n\nExpand for session info\n\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Australia.utf8\n ctype    English_Australia.utf8\n tz       Australia/Sydney\n date     2024-02-13\n pandoc   2.12 @ C:/Users/KEL329/ANACON~1/Scripts/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n dplyr       * 1.1.4   2023-11-17 [1] CRAN (R 4.3.2)\n galah       * 2.0.1   2024-02-06 [1] CRAN (R 4.3.2)\n ggplot2     * 3.4.4   2023-10-12 [1] CRAN (R 4.3.1)\n here        * 1.0.1   2020-12-13 [1] CRAN (R 4.3.2)\n htmltools   * 0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n sf          * 1.0-14  2023-07-11 [1] CRAN (R 4.3.2)\n showtext    * 0.9-6   2023-05-03 [1] CRAN (R 4.3.2)\n showtextdb  * 3.0     2020-06-04 [1] CRAN (R 4.3.2)\n sysfonts    * 0.8.8   2022-03-13 [1] CRAN (R 4.3.2)\n\n [1] C:/Users/KEL329/R-packages\n [2] C:/Users/KEL329/AppData/Local/Programs/R/R-4.3.2/library\n\n─ Python configuration ───────────────────────────────────────────────────────\n python:         C:/Users/KEL329/OneDrive - CSIRO/Documents/ALA/Github/ala-labs/.venv/Scripts/python.exe\n libpython:      C:/Users/KEL329/AppData/Local/Programs/Python/Python312/python312.dll\n pythonhome:     C:/Users/KEL329/OneDrive - CSIRO/Documents/ALA/Github/ala-labs/.venv\n version:        3.12.0 (tags/v3.12.0:0fb18b0, Oct  2 2023, 13:03:39) [MSC v.1935 64 bit (AMD64)]\n Architecture:   64bit\n numpy:          C:/Users/KEL329/OneDrive - CSIRO/Documents/ALA/Github/ala-labs/.venv/Lib/site-packages/numpy\n numpy_version:  1.26.2\n \n NOTE: Python version was forced by VIRTUAL_ENV\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "posts/2023-05-16_dingoes/index.html",
    "href": "posts/2023-05-16_dingoes/index.html",
    "title": "An exploration of dingo observations in the ALA",
    "section": "",
    "text": "Amos Smith Olivia Torresan\nDax Kellie\n\n\n\n5 May 2023\nThe dingo (Canis familiaris) is among Australia’s most recognisable species internationally. However, debate continues about whether dingoes are considered invasive or native species.\nDingoes arrived in Australia around 3,000–5,000 years ago, and their rapid dispersal was likely facilitated by humans. Dingoes hold great significance to many Aboriginal and Torres Strait Islander communities. In some communities, women and children often took dingoes with them to hunt small game or collect food, regarded as protection from danger.\nIn the present day, dingoes negatively impact livestock producers, especially sheep farmers. To reduce these impacts, landowners and government agencies spend an estimated ~$30 million annually across Australia to control dingo populations. Control methods include using traps, baits and shooting, along with constructing a physical barrier to limit their movement: the Dog Fence (also known as the Dingo Fence).\nThe Dog Fence is a wire fence made to protect from the loss of sheep and livestock; currently, it is the longest fence in the world (5,614 km). Since its construction 80 years ago, the Dog Fence has shaped the landscape of Australia. However, perhaps unintentionally, the Dog Fence has acted as a natural experiment. On the side where dingoes remain present there is more vegetation and fewer invasive species like foxes than on the side where dingoes are absent. The difference between sides of the fence is so distinct that you can even see it from space! Nearly a century later, the Dog Fence has shown the importance of apex predators like dingoes in ecosystems and their benefit to native biodiversity1.\nTo understand the debate about the dingo’s role in Australia’s ecosystems, it’s useful to know the species’ current distribution. Here, we’ll explore where and how often dingo observations are recorded in the Atlas of Living Australia (ALA) to understand how historical and ongoing differences in attitudes toward dingo conservation affect data collection."
  },
  {
    "objectID": "posts/2023-05-16_dingoes/index.html#records-by-state",
    "href": "posts/2023-05-16_dingoes/index.html#records-by-state",
    "title": "An exploration of dingo observations in the ALA",
    "section": "Records by state",
    "text": "Records by state\n\nFind fields to filter data\nWe’ll use the {galah} package to download our data.\nThe taxonomic name for dingoes—Canis familiaris—is broadly the name for all wild dogs, though recent genomic research has found pure dingoes are genomically distinct from wild dogs2. This means that if we search using the scientific name Canis familiaris, we’ll likely return more than just dingo records. To fix this, let’s filter our records to those specified by the data provider with the common name “Dingo”.\nLet’s use search_fields() to help us find which fields we can use to filter the taxonomic name. There are a few options, but the raw_vernacularName field seems to hold original common names specified by data providers.\n\nsearch_fields(\"common name\")\n\n# A tibble: 1 × 3\n  id                 description               type  \n  &lt;chr&gt;              &lt;chr&gt;                     &lt;chr&gt; \n1 raw_vernacularName Common name (unprocessed) fields\n\nsearch_fields(\"raw_vernacularName\") |&gt; search_values(\"dingo\")\n\n# A tibble: 5 × 1\n  raw_vernacularName \n  &lt;chr&gt;              \n1 Dingo, domestic dog\n2 Dingo              \n3 Dingo / Wild Dog   \n4 Dingo & Dog (feral)\n5 dingo              \n\n\nWe can use the same method to find a field that contains states & territories.\n\nsearch_fields(\"australian states\")\n\n# A tibble: 2 × 3\n  id     description                            type  \n  &lt;chr&gt;  &lt;chr&gt;                                  &lt;chr&gt; \n1 cl2013 ASGS Australian States and Territories fields\n2 cl22   Australian States and Territories      fields\n\nsearch_fields(\"cl22\") |&gt; show_values()\n\n# A tibble: 11 × 1\n   cl22                        \n   &lt;chr&gt;                       \n 1 New South Wales             \n 2 Victoria                    \n 3 Queensland                  \n 4 South Australia             \n 5 Western Australia           \n 6 Northern Territory          \n 7 Australian Capital Territory\n 8 Tasmania                    \n 9 Unknown1                    \n10 Coral Sea Islands           \n11 Ashmore and Cartier Islands \n\n\n\n\nDownload counts\nWe’ll download the number of dingo observations in each state/territory with atlas_counts() and arrange the resulting counts in descending order.\nAround 75% of dingo observations are recorded in the Northern Territory and South Australia.\n\ndingo_counts &lt;- galah_call() |&gt;\n  galah_identify(\"canis familiaris\") |&gt;\n  galah_filter(raw_vernacularName == c(\"Dingo\", \"dingo\")) |&gt;\n  galah_group_by(cl22) |&gt;\n  atlas_counts() |&gt;\n  arrange(desc(count))\n\ndingo_counts |&gt; gt::gt()\n\n\n\n\n\n\n\ncl22\ncount\n\n\n\n\nSouth Australia\n2915\n\n\nNew South Wales\n1695\n\n\nNorthern Territory\n1397\n\n\nQueensland\n1276\n\n\nVictoria\n428\n\n\nWestern Australia\n109\n\n\nAustralian Capital Territory\n4"
  },
  {
    "objectID": "posts/2023-05-16_dingoes/index.html#data-providers",
    "href": "posts/2023-05-16_dingoes/index.html#data-providers",
    "title": "An exploration of dingo observations in the ALA",
    "section": "Data providers",
    "text": "Data providers\nNext let’s find out who the main data providers are of dingo observations to see whether observations come from citizen science programs or state monitoring programs. We’ll filter to only display providers that have provided more than 5 observations of dingoes.\n\ndata_providers &lt;- galah_call() |&gt;\n  galah_identify(\"canis familiaris\") |&gt;\n  galah_filter(raw_vernacularName == c(\"Dingo\", \"dingo\")) |&gt;\n  galah_group_by(dataResourceName)|&gt;\n  galah_apply_profile(ALA) |&gt;\n  atlas_counts()\n\ncounts_filtered &lt;- data_providers |&gt;\n  filter(count &gt; 5)\n\n\n\n# A tibble: 8 × 2\n  dataResourceName                                           count\n  &lt;chr&gt;                                                      &lt;int&gt;\n1 SA Fauna                                                    2841\n2 Australian National Wildlife Collection provider for OZCAM  2035\n3 NSW BioNet Atlas                                            1632\n4 WildNet - Queensland Wildlife Data                          1118\n5 Victorian Biodiversity Atlas                                 101\n6 Australian Museum provider for OZCAM                          76\n7 Museums Victoria provider for OZCAM                           51\n8 Northern Gulf Fauna Survey                                    18\n\n\n\nDownload observations\nWe can check to see where each data provider’s observations are recorded. We’ll download dingo observations using atlas_occurrences(). Then we’ll filter our observations to only those supplied by providers in counts_filtered.\nYou will need to first provide a registered email with the ALA using galah_config() before retrieving records.\n\n# Use a ALA-registered email (register at ala.org.au)\ngalah_config(email = \"your-email-here\")\n\n\ndingo_obs &lt;- galah_call()|&gt;\n  galah_identify(\"canis familiaris\") |&gt;\n  galah_filter(raw_vernacularName == c(\"Dingo\", \"dingo\")) |&gt;\n  galah_apply_profile(ALA) |&gt;\n  atlas_occurrences()\n\nRetrying in 1 seconds.\nRetrying in 2 seconds.\nRetrying in 4 seconds.\n\n\n\npoints_filtered &lt;- dingo_obs |&gt;\n  filter(dataResourceName %in% counts_filtered$dataResourceName)\n\n\n\n# A tibble: 7,872 × 8\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 0006dc99-2c9d… Canis familia… https://biodi…           -25.2             132.\n 2 001bded1-70cb… Canis familia… https://biodi…           -25.7             135.\n 3 001c548b-76ce… Canis familia… https://biodi…           -26.7             152.\n 4 001db624-6d0f… Canis familia… https://biodi…           -29.0             138.\n 5 002239bc-89b3… Canis familia… https://biodi…           -30.3             153.\n 6 0026084c-e259… Canis familia… https://biodi…           -28.6             131.\n 7 0031bfb0-0781… Canis familia… https://biodi…           -31.2             152.\n 8 0031f7bf-1a93… Canis familia… https://biodi…           -21.3             149.\n 9 003e4206-dcbc… Canis familia… https://biodi…           -36.9             147.\n10 0043756a-5dc6… Canis familia… https://biodi…           -36.1             148.\n# ℹ 7,862 more rows\n# ℹ 3 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;\n\n\n\n\nVisualise\nWe can create a bar plot and a map of observations to visualise our results.\nJust five data providers account for ~98% of dingo records, with Fauna Atlas N. T. contributing ~40% of records. All major data providers are government monitoring programs, rather than citizen science providers like iNaturalist.\n\n\nCode\ncustom_colours &lt;- c(\n  \"Museums Victoria provider for OZCAM\" = \"#604830\",\n  \"Victorian Biodiversity Atlas\" = \"#486030\",\n  \"Australian National Wildlife Collection provider for OZCAM\" = \"#6090d8\",\n  \"NSW BioNet Atlas\" = \"#604830\",\n  \"WildNet - Queensland Wildlife Data\" = \"#6fab3f\",\n  \"SA Fauna (BDBSA)\" = \"#d89060\",\n  \"Australian Museum provider for OZCAM\" = \"#FFC300\",\n  \"Fauna Atlas N.T.\" = \"#a84830\"\n)\n\n# Bar plot\nbar_plot &lt;- counts_filtered |&gt;\n  ggplot(aes(\n    x = reorder(str_wrap(dataResourceName, 28), count),\n    y = count, fill = dataResourceName)) +\n  geom_bar(stat = \"identity\", width = .8) +\n  scale_fill_manual(values = custom_colours) +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_continuous(labels = scales::label_comma()) +\n  coord_flip() +\n  xlab(\"\") +\n  pilot::theme_pilot(grid = \"v\",\n                     axes = \"b\") +\n  theme(legend.position = \"none\",\n        axis.text = element_text(size = 12))\n\n# Map\naus &lt;- ozmap_data(data = \"states\")\n\nmap &lt;- ggplot() +\n  geom_sf(data = aus, fill = \"#FBFBEF\") +\n  geom_point(\n    data = points_filtered,\n    mapping = aes(\n      x = decimalLongitude,\n      y = decimalLatitude,\n      colour = dataResourceName),\n    alpha = 0.5) +\n  scale_color_manual(values = custom_colours) +\n  theme_void() +\n  coord_sf(\n    ylim = c(-45, -10),\n    xlim = c(110, 155)) +\n  theme(legend.position = \"none\")"
  },
  {
    "objectID": "posts/2023-05-16_dingoes/index.html#time-of-year",
    "href": "posts/2023-05-16_dingoes/index.html#time-of-year",
    "title": "An exploration of dingo observations in the ALA",
    "section": "Time of year",
    "text": "Time of year\nNext, let’s investigate what months of the year have more dingo records. Viewing observations over time can show us patterns of when a species is most active. It can also reveal human biases in data collection. We’ll look specifically at observations in Northern Territory and South Australia because these states have the most data. Given the huge temperature gradient between the north and south of Australia, we might expect the timing of dingo observations to differ between NT and SA.\n\nDownload data\nFirst we’ll download observations by month in the Northern Territory by using the month field inside galah_group_by().\n\n# download data\ndingo_NT &lt;- galah_call() |&gt;\n  galah_identify(\"canis familiaris\") |&gt;\n  galah_filter(raw_vernacularName == c(\"Dingo\", \"dingo\"),\n               cl22 == \"Northern Territory\") |&gt;\n  galah_group_by(month) |&gt;\n  atlas_counts()\n\n\n\n# A tibble: 12 × 2\n   month count\n   &lt;chr&gt; &lt;int&gt;\n 1 4       190\n 2 6       180\n 3 1       151\n 4 3       136\n 5 7       127\n 6 9       122\n 7 5       115\n 8 2       103\n 9 12       91\n10 11       76\n11 8        53\n12 10       44\n\n\nWe’ll use the lubridate::month() function to convert the class of our month column from character to ordered factor.\n\n# format months for plotting\nmonth_NT &lt;- dingo_NT |&gt;\n  mutate(\n    month = lubridate::month(as.numeric(month), label = TRUE) # format month\n    )\n\n\n\n# A tibble: 12 × 2\n   month count\n   &lt;ord&gt; &lt;int&gt;\n 1 Apr     190\n 2 Jun     180\n 3 Jan     151\n 4 Mar     136\n 5 Jul     127\n 6 Sep     122\n 7 May     115\n 8 Feb     103\n 9 Dec      91\n10 Nov      76\n11 Aug      53\n12 Oct      44\n\n\n\n\nMake bar plot\nNow we can make a bar chart to see observations over the year. We’ll do the same for South Australia, too.\nNorthern Territory’s dingo observations are recorded mainly over winter months (June–August). Alternatively, South Australia’s dingo observations are mainly recorded during autumn months (April–June).\n\n# Northern Territory plot\nbarplot_nt &lt;- ggplot(data = month_NT, \n                     aes(x = month, y = count)) +\n  geom_bar(stat = \"identity\", fill = \"#a84830\") +\n  labs(title = \"Northern Territory\", \n       x = \"Month\", \n       y = \"No. of observations\") +\n  scale_x_discrete(expand = c(0,0)) +\n  scale_y_continuous(limits = c(0, 1000),\n                     expand = c(0,0)) +\n  pilot::theme_pilot(grid = \"h\")\n\n\n\nCode\n## South Australia\n\n# download data\ndingo_SA &lt;- galah_call() |&gt;\n  galah_identify(\"canis familiaris\") |&gt;\n  galah_filter(raw_vernacularName == c(\"Dingo\", \"dingo\"),\n               cl22 == \"South Australia\") |&gt;\n  galah_group_by(month) |&gt;\n  atlas_counts() |&gt;\n  mutate(\n    month = month(as.numeric(month), label = TRUE) # format month\n    )\n\n# plot\nbarplot_sa &lt;- ggplot(data = dingo_SA, \n       aes(x = month, y = count)) +\n  geom_bar(stat = \"identity\", fill = \"#d89060\") +\n  labs(title = \"South Australia\", \n       x = \"Month\", \n       y = \"No. of observations\") +\n  scale_x_discrete(expand = c(0,0)) +\n  scale_y_continuous(limits = c(0, 1000),\n                     expand = c(0,0)) +\n  pilot::theme_pilot(grid = \"h\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDoes this suggest dingoes are more active during winter, or are data collectors surveying during cooler times of the year? The answer might be “both”. One dingo tracking research study found that dingoes are far more active in winter, spending 46% of their day stationary in winter compared to 91% of their day in summer. Similarly, it’s easier for data collectors to survey during winter months when the heat is less extreme. Cooler winter temperatures might allow dingoes and surveyors to be more active, increasing the likelihood of incidental observations."
  },
  {
    "objectID": "posts/2023-05-16_dingoes/index.html#northern-territory",
    "href": "posts/2023-05-16_dingoes/index.html#northern-territory",
    "title": "An exploration of dingo observations in the ALA",
    "section": "Northern Territory",
    "text": "Northern Territory\n\nDownload CAPAD shapefile\nWe’ll first need the CAPAD shapefile. We can get it by downloading the CAPAD2020_terrestrial.zip folder from their website. Download and save this folder in your R Project or working directory and unzip it.\n\n# read in capad shapefile\ncapad &lt;- st_read(here(\"posts\",\n                      \"data\",\n                      \"CAPAD\",\n                      \"CAPAD2020_terrestrial.shp\"),\n                 quiet = TRUE) |&gt;\n  ms_simplify(keep = 0.1) |&gt;\n  st_transform(crs = st_crs(\"WGS84\")) |&gt;\n  st_make_valid()\n\nWe will filter our CAPAD layer to only the Northern Territory for our plot.\n\n# filter to NT\ncapad_nt &lt;- capad |&gt;\n  filter(STATE == \"NT\")\n\n\n\nDownload records\nNow we can download dingo observations in the Northern Territory (and remove any NAs with drop_na()).\n\n# download dingo observations in NT\ndingo_obs_nt &lt;- galah_call() |&gt;\n  galah_identify(\"canis familiaris\") |&gt;\n  galah_filter(raw_vernacularName == c(\"Dingo\", \"dingo\"),\n               cl22 == \"Northern Territory\") |&gt;\n  atlas_occurrences() |&gt;\n  drop_na() # filter any NA values out\n\n\n\n# A tibble: 1,388 × 8\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 0006dc99-2c9d… Canis familia… https://biodi…           -25.2             132.\n 2 001bded1-70cb… Canis familia… https://biodi…           -25.7             135.\n 3 008c10ea-6f29… Canis familia… https://biodi…           -17.3             133.\n 4 009e0dbf-403e… Canis familia… https://biodi…           -18.8             134.\n 5 00a4077b-b38e… Canis familia… https://biodi…           -23.3             134.\n 6 00c54f1e-de56… Canis familia… https://biodi…           -25.3             132.\n 7 012328bc-326c… Canis familia… https://biodi…           -25.2             132.\n 8 01488211-a59f… Canis familia… https://biodi…           -23.5             133.\n 9 01734d32-91d6… Canis familia… https://biodi…           -23.3             134.\n10 01ea8409-3605… Canis familia… https://biodi…           -19.0             137.\n# ℹ 1,378 more rows\n# ℹ 3 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;\n\n\n\n\nMake map\nWe’ll make our map of the Northern Territory by plotting each of our components and adding a colour scale to indicate places where there is more than one observation in a single point.\n\n# make map\nnt_plot &lt;- ggplot() +\n  geom_sf(data = ozmap_states |&gt; filter(NAME == \"Northern Territory\"), \n          fill = \"#F8FBEF\", \n          colour = \"grey60\", \n          linewidth = 0.3) +\n  geom_pointdensity(data = dingo_obs_nt,\n                    mapping = aes(x = decimalLongitude,\n                                  y = decimalLatitude),\n                    size = 2.4, \n                    alpha = 0.6) +\n  geom_sf(data = capad_nt, \n          fill = \"#1F901F\", \n          colour = \"#1F901F\", \n          linewidth = 0.5, \n          alpha = 0.2, \n          linetype = \"dashed\") +\n  scale_color_viridis(option = \"D\", \n                      direction = -1,\n                      begin = 0.0,\n                      end = 0.4,\n                      guide = guide_colorbar(title = (\"Number of overlapping observations\"),\n                                     title.position = \"top\",\n                                     title.hjust = 0.5)) +\n  theme_void() +\n  theme(legend.position = \"bottom\",\n        legend.title = element_text(face = \"bold\"),\n        legend.key.width = unit(15, 'mm'),\n        plot.margin = unit(c(1,0,1,0),\"cm\"))\n\n\n\nAdd coloured title\nFinally, we can avoid adding more than one legend by using colour in our title to specify the colour of protected areas and dingo observations on our map (using a clever method by Cara Thompson). We’ll need to use ggnewscale::new_scale_color() to add our custom colour palette for our text because we are already using another colour palette for our observation points (you can check out our previous post on using {ggnewscale} to learn more).\n\n# create palette for title\ndingo_palette &lt;- list(\"protected\" = \"#1F901F\",\n                      \"obs\" = \"#404788\")\n\nnt_plot +\n  ggnewscale::new_scale_color() +\n  scale_colour_manual(values = dingo_palette) +\n  labs(\n    title = glue(\n      \"&lt;span style='color:{dingo_palette$obs}'&gt;Dingo observations&lt;/span&gt; in \n      &lt;span style='color:{dingo_palette$protected}'&gt;**protected areas**&lt;/span&gt;\"),\n    subtitle = \"Northern Territory\") +\n  theme(plot.title = element_markdown(face = \"bold\", size = 16, hjust = 0.5),\n        plot.subtitle = element_markdown(hjust = 0.5, size = 15))\n\nWarning: `stat(n_neighbors)` was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(n_neighbors)` instead.\n\n\n\n\n\n\n\n\n\n\n\nCalculate proportion inside protected areas\nBy comparing the number of records in CAPAD areas to the total observations in Northern Territory, we find that more than half of all dingo observations are recorded inside of protected areas.\n\n\n\n\n\n\nTip\n\n\n\nSearching for CAPAD fields in {galah} shows us that {galah} has the CAPAD 2020 layer available for us to use in a query.\n\nsearch_all(fields, \"capad\") |&gt; print(n = 5)\n\n# A tibble: 9 × 3\n  id      description            type  \n  &lt;chr&gt;   &lt;chr&gt;                  &lt;chr&gt; \n1 cl10944 CAPAD 2016 Terrestrial fields\n2 cl10945 CAPAD 2016 Marine      fields\n3 cl10957 CAPAD 2018 Marine      fields\n4 cl11032 CAPAD 2020 Marine      fields\n5 cl11033 CAPAD 2020 Terrestrial fields\n# ℹ 4 more rows\n\n\nWe can return the number of dingo observations in each CAPAD area by using galah_group_by(cl11033) in our query. Adding the observation counts together will give us the total observations in CAPAD areas.\n\n\n\n# Download dingo record counts inside CAPAD areas\ndingo_capad_nt &lt;- galah_call() |&gt;\n  galah_identify(\"canis familiaris\") |&gt;\n  galah_filter(raw_vernacularName == c(\"Dingo\", \"dingo\"),\n               cl22 == \"Northern Territory\") |&gt;\n  galah_group_by(cl11033) |&gt; # capad\n  atlas_counts() |&gt;\n  drop_na() # filter any NA values out\n\n# Proportion inside vs outside of protected areas\nin_protected &lt;- dingo_capad_nt|&gt; summarise(total = sum(count))\nout_of_protected &lt;- nrow(dingo_obs_nt)\n\npaste(round(in_protected / out_of_protected * 100, 2), \"%\", sep = \"\")\n\n[1] \"5.62%\""
  },
  {
    "objectID": "posts/2023-05-16_dingoes/index.html#south-australia",
    "href": "posts/2023-05-16_dingoes/index.html#south-australia",
    "title": "An exploration of dingo observations in the ALA",
    "section": "South Australia",
    "text": "South Australia\nLet’s do the same as above to make a map of South Australia.\nWe’ll also include a map of where the Dog Fence is within South Australia to compare observations on either side of the fence. We obtained a shapefile of the Dog Fence by contacting the Department of Primary Industries and Regions.\n\ndog_fence &lt;- st_read(here(\"posts\",\n                          \"data\",                    \n                          \"Dog Fence\",\n                          \"Dog_Fence.shp\"),\n                     quiet = TRUE) |&gt;\n  ms_simplify(keep = 0.1) |&gt;\n  st_transform(crs = st_crs(\"WGS84\")) |&gt;\n  st_make_valid()\n\nThe Dog Fence is labelled in our map below. There are noticeably fewer observations recorded of dingoes on the southern side of the fence, and those that are recorded appear to be mostly inside protected areas.\n\n\nCode\n# filter to SA\ncapad_sa &lt;- capad |&gt;\n  filter(STATE == \"SA\")\n\n# download dingo observations in SA\ndingo_obs_sa &lt;- galah_call() |&gt;\n  galah_identify(\"canis familiaris\") |&gt;\n  galah_filter(raw_vernacularName == c(\"Dingo\", \"dingo\"),\n               cl22 == \"South Australia\") |&gt;\n  atlas_occurrences() |&gt;\n  drop_na() # filter any NA values out\n\n\nRetrying in 1 seconds.\n\n\nCode\n# Start and end points of arrow\narrow &lt;- \n  tibble(\n    x1 = c(132.4),\n    x2 = c(134),\n    y1 = c(-34),\n    y2 = c(-32.2))\n\n# make map\nsa_plot &lt;- ggplot() +\n  geom_sf(data = ozmap_states |&gt; filter(NAME == \"South Australia\"), \n          fill = \"#F8FBEF\", \n          colour = \"grey60\", \n          linewidth = 0.5) +\n  geom_pointdensity(data = dingo_obs_sa,\n                    mapping = aes(x = decimalLongitude,\n                                  y = decimalLatitude),\n                    size = 2.4, \n                    alpha = 0.6) +\n  geom_sf(data = capad_sa, \n          fill = \"#1F901F\", \n          colour = \"#1F901F\", \n          linewidth = 0.5, \n          alpha = 0.2, \n          linetype = \"dashed\") +\n  geom_sf(data = dog_fence, color = \"#F0A202\", linewidth = 1.8) +\n  geom_curve(\n    data = arrow, aes(x = x1, y = y1, xend = x2, yend = y2),\n    arrow = arrow(length = unit(0.08, \"inch\")),\n    colour = \"#392704\",\n    linewidth = 1.5,\n    curvature = 0.3) +\n  annotate(\"text\", x = 130.9, y = -34, label = \"Dog Fence\", size = 5.5, colour = \"#EFA81A\") +\n  scale_color_viridis(option = \"D\", \n                      direction = -1,\n                      begin = 0.0,\n                      end = 0.4,\n                      guide = guide_colorbar(title = (\"Number of overlapping observations\"),\n                                     title.position = \"top\",\n                                     title.hjust = 0.5)) +\n  theme_void() +\n  theme(legend.position = \"bottom\",\n        legend.title = element_text(face = \"bold\"),\n        legend.key.width = unit(15, 'mm'),\n        plot.margin = unit(c(1,0,1,0),\"cm\"))\n\n# add title\nsa_plot +\n  ggnewscale::new_scale_color() +\n  scale_colour_manual(values = dingo_palette) +\n  labs(\n    title = glue(\n      \"&lt;span style='color:{dingo_palette$obs}'&gt;Dingo observations&lt;/span&gt; in \n      &lt;span style='color:{dingo_palette$protected}'&gt;**protected areas**&lt;/span&gt;\"),\n    subtitle = \"South Australia\") +\n  theme(plot.title = element_markdown(face = \"bold\", size = 16, hjust = 0.5),\n        plot.subtitle = element_markdown(hjust = 0.5, size = 15))\n\n\n\n\n\n\n\n\n\nBy comparing the number of records in CAPAD areas to the total observations in South Australia, we find that around 4 in 10 dingo observations are recorded inside of protected areas.\n\n\nCode\n# Download dingo record counts inside CAPAD areas\ndingo_capad_sa &lt;- galah_call() |&gt;\n  galah_identify(\"canis familiaris\") |&gt;\n  galah_filter(raw_vernacularName == c(\"Dingo\", \"dingo\"),\n               cl22 == \"South Australia\") |&gt;\n  galah_group_by(cl11033) |&gt; # capad\n  atlas_counts() |&gt;\n  drop_na() # filter any NA values out\n\n# Proportion inside vs outside of protected areas\nin_protected &lt;- dingo_capad_sa |&gt; summarise(total = sum(count))\nout_of_protected &lt;- nrow(dingo_obs_sa)\n\npaste(round(in_protected / out_of_protected * 100, 2), \"%\", sep = \"\")\n\n\n[1] \"38.97%\"\n\n\nOverall, in the Northern Territory and South Australia, the number of dingo observations is fairly comparable between between those made inside and outside of nationally protected areas. We also saw how few observations are on the southern side of the Dog Fence in South Australia."
  },
  {
    "objectID": "posts/2023-05-16_dingoes/index.html#footnotes",
    "href": "posts/2023-05-16_dingoes/index.html#footnotes",
    "title": "An exploration of dingo observations in the ALA",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSome research suggests dingoes might not always benefit mammal species richness.↩︎\nHowever, all wild dogs in Australia possess some percentage of dingo genes.↩︎\nIn South Australia, inside the Dog Fence landholders have a legal responsibility to control wild dogs—including dingoes—on their properties, whereas outside of the Dog Fence dingoes are listed as unprotected native wildlife.↩︎"
  },
  {
    "objectID": "posts/2023-04-11_quantifying-species-range/index.html",
    "href": "posts/2023-04-11_quantifying-species-range/index.html",
    "title": "Quantifying species range and overlap with fire-burned areas using concave hulls",
    "section": "",
    "text": "Author\nFonti Kar\nMargot Schneider\n\n\nDate\n11 April 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe 2019/2020 Australian bushfires had a devastating impact on the natural landscape, threatening our native biodiversity. More than ever, decision makers need curated, open access biodiversity data to help respond effectively to future bushfires.\nOur team at the Atlas of Living Australia (ALA) has been working with Invertebrates Australia and CSIRO National Research Collections team to collate biodiversity datasets that can be used for off-the-shelf bushfire assessments. The two datasets contain data on Australian taxonomic groups that are often overlooked and severely affected during bushfires: invertebrates (insects, molluscs, spiders) and vascular plants.\n\nWe are thrilled to announce that these datasets are available from CSIRO’s data access portal!\n\nThis post expands on our last post about using convex and alpha hulls to visualise distributions of data-deficient species.\nHere, we show you how to compute a new form of spatial polygon — a concave hull — and use it to represent a species’ range and to calculate the overlap with fire-burned areas (range overlap). Unlike convex hulls, concave hulls have the added flexibility to adjust their tightness to the data (or concavity). This flexibility allows more accurate estimation of species ranges, making it a useful approach to rapidly assess how natural disasters like bush fires affected biodiversity.\n\nDownload data\nFirst we will load the R packages we need:\n\n# install.packages(\"pacman\")\npacman::p_load(tidyverse, here, rmapshaper, sf, ggpointdensity, viridis, ozmaps, concaveman, cowplot, patchwork)\n\nNext, we will go to the Data Access Portal to download the invertebrate and vascular plant datasets.\nClick on the Files tab (under the main title), then the Download button (in the top right corner), and select Download all files as Zip archive. Save this zip file in a local folder inside your current R project and be sure to unzip it.\nNow we can read the curated datasets into R:\n\n# Invertebrates data\ninverts &lt;- read_csv(here(\"your_directory_name\", \"invertebrate.data.03.2023.csv\"))\n\n# Vascular plants data\nvplants &lt;- read_csv(here(\"your_directory_name\", \"vascularplant.data.03.2023.csv\"))  |&gt; \n  rename(latitude = latitude_used, # Rename coordinate variables for consistency\n         longitude = longitude_used)\n\n\n\nOverview of data\nBoth datasets are based on studies that investigated the impact of the Black Summer bushfires and are designed to support future modelling and impact assessments. The invertebrate dataset spans across Australia, whereas the vascular plant dataset is restricted to South-Eastern Australia and contains only species where more than 50% of their range was affected by the 2019/2020 fires.\n Summary of Invertebrate and Vascular Plant Data\n\n\n\n\n\n\n\n\nTaxonomic Group\nClasses\nFamilies\nSpecies\nRecords\n\n\n\n\nInvertebrates\n46\n2,044\n44,146\n300,987\n\n\nVascular Plants\n7\n76\n896\n41,572\n\n\n\n\n\n\n\nA total of 44,146 invertebrate species and 896 species of vascular plants are represented in these datasets. Below, we’ve attempted to show the geographic range of these data. So much data makes it challenging to visualise all data points and concave hulls at once. As such, we created the concave hull maps (left) below by randomly selecting one invertebrate species from each class and one plant species from each family.\n\n\nCode\n# Identify species that have more than 4 observations \nmore_than_4_obs &lt;- inverts |&gt; \n  group_by(scientific_name) |&gt; \n  summarise(n_obs = n()) |&gt; \n  filter(n_obs &gt; 4) |&gt; \n  pull(scientific_name)\n\n# Subset species with more than 4 observations and appear on mainland Australia + Tasmania\ninverts_subset &lt;- inverts |&gt;\n  filter(scientific_name %in% more_than_4_obs) |&gt; \n  filter(latitude &lt; -10, latitude &gt;= -45,\n         longitude &gt;= 113, longitude &lt;= 155) |&gt; \n  select(scientific_name:family, longitude, latitude)\n\n# Nest occurrence data\ninverts_nest &lt;- inverts_subset |&gt; \n  nest(coords = c(longitude, latitude))\n\n# Subset a random species from each class \nset.seed(123)  # Set seed so we all get the same results\nsubset &lt;- inverts_nest |&gt; \n  group_by(class) |&gt; \n  slice_sample(n = 1) \n\n# Convert coordinates into sf object and compute concave hulls as list columns.\nsubset_concave &lt;- subset |&gt;\n    mutate(points_sf = map(.x = coords,\n                           ~ st_as_sf(.x, coords = c(\"longitude\", \"latitude\"),\n                                      crs = 4326)), \n           concave_sf = map(points_sf,\n                            ~ concaveman(.x)))\n\n# Unnest the concave hull list column\nsubset_concave &lt;- subset_concave |&gt; \n  select(scientific_name:family, concave_sf) |&gt; \n  unnest(cols = c(concave_sf)) |&gt; \n  ungroup() |&gt; \n  st_sf(crs = 4326) \n\n# Retrieve Australia polygon\naus &lt;- st_transform(ozmap_country, 4326)\n\n# Plotting spatial distributions\ninverts_concave &lt;- ggplot() + \n  geom_sf(data = aus, colour = \"black\", fill = NA) +\n  geom_sf(data = subset_concave, fill = \"#609966\", alpha = 0.2, lwd = 0) +\n  coord_sf(xlim = c(110, 155)) +\n  theme_void() \n\n# Create plot showing overlapping points\ninverts_points_map &lt;- ggplot() +\n  geom_pointdensity(data = inverts_subset,\n                    mapping = aes(x = longitude,\n                                  y = latitude)) +\n  geom_sf(data = aus, colour = \"white\", fill = NA) +  \n  scale_color_viridis(option = \"E\", begin = 0.1) +\n  coord_sf(xlim = c(110, 155)) +\n  guides(alpha = \"none\",\n         colour = guide_colorbar(title = \"Number of \\noverlapping points\")) +\n  theme_void() +\n  theme(legend.position = \"bottom\",\n        legend.margin = margin(0, 0, 0, 0),\n        legend.box.margin = margin(0, 0, 0, 0),\n        legend.justification = \"left\"\n        )\n\ninverts_concave + inverts_points_map + plot_annotation(title = \"Invertebrate Dataset\") \n\n\n\n\n\n\n\n\n\n\n\nCode\n# Identify species that have more than 4 observations \nmore_than_4_obs_plants &lt;- vplants |&gt; \n  group_by(scientific_name) |&gt; \n  summarise(n_obs = n()) |&gt; \n  filter(n_obs &gt; 4) |&gt; \n  pull(scientific_name)\n\n# Subset species with more than 4 observations and appear on mainland Australia + Tasmaina\nvplant_subset &lt;- vplants |&gt;\n  filter(scientific_name %in% more_than_4_obs_plants) |&gt; \n  filter(latitude &lt; -10, latitude &gt;= -45,\n         longitude &gt;= 113, longitude &lt;= 155) |&gt; \n  select(species, class:genus, longitude, latitude) \n\n# Nest occurrence data\nvplant_nest &lt;- vplant_subset |&gt; \n   nest(coords = c(longitude, latitude))\n\n# Subset a random species from each family \nset.seed(123)  # Set seed so we all get the same results\nplant_subset &lt;- vplant_nest |&gt; \n  group_by(family) |&gt; \n  slice_sample(n = 1) \n\n# Compute concave hulls\npl_subset_concave &lt;- plant_subset |&gt;\n    mutate(points_sf = map(.x = coords,\n                           ~ st_as_sf(.x, coords = c(\"longitude\", \"latitude\"),\n                                      crs = 4326)), \n           concave_sf = map(points_sf,\n                            ~ concaveman(.x)))\n\n# Unnest the data\npl_subset_concave &lt;- pl_subset_concave |&gt; \n  select(species:family, concave_sf) |&gt; \n  unnest(cols = c(concave_sf)) |&gt; \n  st_as_sf(crs = 4326) \n\n# Plotting spatial distributions\nplant_concave &lt;- ggplot() + \n  geom_sf(data = aus, colour = \"black\", fill = NA) +\n  geom_sf(data = pl_subset_concave, fill = \"#609966\", colour = NA, alpha = 0.15, lwd = 0) + \n  coord_sf(xlim = c(140, 158),\n           ylim = c(-23, -43)) +\n  theme_void()\n\n# Create plot showing overlapping points\nplants_points_map &lt;- ggplot() +\n  geom_pointdensity(data = vplant_subset,\n                    mapping = aes(x = longitude,\n                                  y = latitude)) +\n  geom_sf(data = aus, colour = \"black\", fill = NA) +  \n  scale_color_viridis(option = \"E\", begin = 0.1) +\n  coord_sf(xlim = c(140, 158),\n           ylim = c(-23, -43)) +\n  guides(alpha = \"none\",\n         colour = guide_colorbar(title = \"Number of \\noverlapping points\")) +\n  theme_void() +\n  theme(legend.position = \"bottom\",\n        legend.margin = margin(0, 0, 0, 0),\n        legend.box.margin = margin(0, 0, 0, 0),\n        legend.justification = \"left\"\n        )\n  \nplant_concave + plants_points_map + plot_annotation(title = \"Vascular Plant Dataset\")\n\n\n\n\n\n\n\n\n\n\n\nPre-cleaning\nLet’s use these datasets to calculate concave hulls and range overlaps with burned regions. One benefit of using these curated datasets is that they do not contain any duplicates or missing values. This makes data cleaning an easier job!\nHowever, there are still a few steps we need to do before computing concave hulls:\n\nRemove data-deficient species\nFirst, we need to filter out any data-deficient species with fewer than 4 data points because concave hulls are best estimated with at least 4 data points. To do this, we’ll calculate the number of observations for each species, then identify which ones have more than 4 records. Using this list of species, we can extract their data.\n\nmore_than_4_obs &lt;- inverts |&gt; \n  group_by(scientific_name) |&gt; \n  summarise(n_obs = n()) |&gt; \n  filter(n_obs &gt; 4) |&gt; \n  pull(scientific_name)\n\nmore_than_4_obs |&gt; head()\n\n[1] \"Aaaaba fossicollis\"    \"Aaaaba nodosus\"        \"Aades cultratus\"      \n[4] \"Aades griseatus\"       \"Aaroniella rawlingsi\"  \"Abantiades latipennis\"\n\ninverts_subset &lt;- inverts |&gt;\n  filter(scientific_name %in% more_than_4_obs)\n\n\n\nRestrict data to mainland Australia and Tasmania\nThe invertebrate dataset includes records on offshore islands which can drastically skew the shape of a species’ concave hull. For the purpose of this post, we will filter these out and only use records that occur on mainland Australia and Tasmania.\n\nsubset_mainland &lt;- inverts_subset |&gt; \n  filter(latitude &lt; -10, latitude &gt;= -45,\n         longitude &gt;= 113, longitude &lt;= 155) |&gt; \n  select(scientific_name:family, longitude, latitude)\n\n\n\nList columns and nesting occurrence data\nFor the majority of calculations in this post, we will be making use of list columns, a very useful data structure for iterative analyses. You can think of a list column as mini data frames nested within a column by a grouping variable.\nIn this case we are nesting the coordinate data by species, which will make operations at the species level more efficient.\n\ninverts_nest &lt;- subset_mainland |&gt; \n  nest(coords = c(longitude, latitude))\n\ninverts_nest |&gt; \n  print(n = 6)\n\n# A tibble: 16,347 × 4\n  scientific_name       class   family        coords           \n  &lt;chr&gt;                 &lt;chr&gt;   &lt;chr&gt;         &lt;list&gt;           \n1 Aaaaba fossicollis    Insecta Buprestidae   &lt;tibble [12 × 2]&gt;\n2 Aaaaba nodosus        Insecta Buprestidae   &lt;tibble [16 × 2]&gt;\n3 Aades cultratus       Insecta Curculionidae &lt;tibble [20 × 2]&gt;\n4 Aades griseatus       Insecta Curculionidae &lt;tibble [5 × 2]&gt; \n5 Aaroniella rawlingsi  Insecta Philotarsidae &lt;tibble [35 × 2]&gt;\n6 Abantiades latipennis Insecta Hepialidae    &lt;tibble [10 × 2]&gt;\n# ℹ 16,341 more rows\n\n\nYou can inspect elements in the list column like this:\n\ninverts_nest |&gt; \n  pluck(\"coords\", 1) |&gt;  # 1 refers to the first element of the list column\n  print(n = 6)\n\n# A tibble: 12 × 2\n  longitude latitude\n      &lt;dbl&gt;    &lt;dbl&gt;\n1      153.    -28.4\n2      151.    -33.8\n3      153.    -31.0\n4      146.    -37.8\n5      153.    -30.3\n6      151.    -33.8\n# ℹ 6 more rows\n\n\nThe biggest change with working with list columns is that you have to iterate across each element. To do this, we will use various functions from the {purrr} package for the next calculation steps.\n\n\n\nSpecies range overlap with fire-burned areas\n\nGet fire layer\nShapefiles for the 2019-2020 fire season are available through the National Indicative Aggregated Fire Extent Dataset from the Department of Climate Change, Energy, the Environment and Water.\nClick on Download Data (near the top of the page), then click on NIAFED_v20200623.zip to download the zip file. Save the zip file in your project folder and unzip to retrieve the shapefiles.\nNow we can read the shapefile into R and set the projection to EPSG:4326. To speed up the computation of concave hulls and overlaps, we will remove elevation values and simplify the edges of the fire POLYGON.\n\nfire &lt;- st_read(here(\"your_directory_name\", \"NIAFED_20190701_20200622_v20200623.shp\")) |&gt; \n  st_transform(crs = 4326) |&gt; \n  st_zm() |&gt;  # Remove Z or M values\n  ms_simplify() # Simplify edges of the fire layer\n\n\n\nChoose taxonomic group\nWhile it is possible to calculate range overlap with burned areas for all species in the dataset, it can take a lot of memory and processing time. Instead, we will demonstrate our workflow with — the bee family (Apidae) — as a working example.\n\n# Filter invertebrate data to Apidae\nbees &lt;- inverts_nest |&gt; \n  filter(family == \"Apidae\") \n\n\n\nCompute concave hull\nIn the next steps, we will work through the coordinate data for each species iteratively using map.\nWe will transform each species’ coordinates into an sf object using st_as_sf(), then compute the concave hulls with the concaveman() function. You can adjust the tightness of the hull boundary around a set of points using the concavity argument - the smaller the value, the tighter the hull. We’ve wrapped mutate() around these steps so the output will become variables in our tibble.\n\nbees_concave &lt;- bees |&gt;\n    mutate(points_sf = map(.x = coords,\n                           ~ st_as_sf(.x, coords = c(\"longitude\", \"latitude\"), # Set as sf object\n                                      crs = 4326) |&gt; \n                             rename(points = geometry)), # Rename geometry variable to something intuitive\n           concave_sf = map(points_sf,\n                            ~ concaveman(.x, concavity = 2) |&gt; # Compute concave hulls\n                              rename(concave = polygons)) # Rename geometry variable to something intuitive\n           ) \n\nbees_concave |&gt; print(n = 6)\n\n# A tibble: 54 × 6\n  scientific_name                   class   family coords   points_sf concave_sf\n  &lt;chr&gt;                             &lt;chr&gt;   &lt;chr&gt;  &lt;list&gt;   &lt;list&gt;    &lt;list&gt;    \n1 Amegilla (Asaropoda) bombiformis  Insecta Apidae &lt;tibble&gt; &lt;sf&gt;      &lt;sf&gt;      \n2 Amegilla (Asaropoda) calva        Insecta Apidae &lt;tibble&gt; &lt;sf&gt;      &lt;sf&gt;      \n3 Amegilla (Asaropoda) dawsoni      Insecta Apidae &lt;tibble&gt; &lt;sf&gt;      &lt;sf&gt;      \n4 Amegilla (Asaropoda) paracalva    Insecta Apidae &lt;tibble&gt; &lt;sf&gt;      &lt;sf&gt;      \n5 Amegilla (Asaropoda) rhodoscymna  Insecta Apidae &lt;tibble&gt; &lt;sf&gt;      &lt;sf&gt;      \n6 Amegilla (Notomegilla) aeruginosa Insecta Apidae &lt;tibble&gt; &lt;sf&gt;      &lt;sf&gt;      \n# ℹ 48 more rows\n\n\n\n\nCompute range overlap and descriptive statistics\nTo compute range overlaps, we need to set our geometry calculations to assume the Earth is flat and not spherical by setting sf_use_s2(FALSE). This may be a limitation of the method but it still gives us a good approximation.\n\n# Disable spherical geometry\nsf_use_s2(FALSE) \n\nUsing st_intersection(), we can identify the overlap between each species’ concave hull with fire-burned areas. We can then use st_area() to calculate the area (m2) of overlap and convert it into a percentage of each species’ original range so that all species are comparable.\nUsing possibly() with our map() functions allows the calculations to return NA for species that did not overlap with burned areas. Once calculations are complete, we will un-nest the variables: overlap_area and percent_overlap, so they appear as regular columns in our tibble.\n\n# Calculate range overlap\nbees_overlap &lt;- bees_concave |&gt;\n  mutate(\n    overlap_sf = map(concave_sf,\n                     possibly(~ st_intersection(fire, .x) |&gt; select(-Id) |&gt; rename(overlap = geometry))), # Identify overlap\n    overlap_area = map(overlap_sf,\n                       possibly( ~ st_area(.x))), # Calculate area\n    percent_overlap = map2(.x = overlap_area,\n                           .y = concave_sf,\n                           possibly( ~ (.x / st_area(.y)) * 100))) |&gt; # Calculate percentage\n  unnest(cols = c(overlap_area, percent_overlap)) # Unnest the area and percentage columns\n    \nbees_overlap |&gt; print(n = 6)\n\n# A tibble: 23 × 9\n  scientific_name          class family coords   points_sf concave_sf overlap_sf\n  &lt;chr&gt;                    &lt;chr&gt; &lt;chr&gt;  &lt;list&gt;   &lt;list&gt;    &lt;list&gt;     &lt;list&gt;    \n1 Amegilla (Asaropoda) bo… Inse… Apidae &lt;tibble&gt; &lt;sf&gt;      &lt;sf&gt;       &lt;sf&gt;      \n2 Amegilla (Asaropoda) da… Inse… Apidae &lt;tibble&gt; &lt;sf&gt;      &lt;sf&gt;       &lt;sf&gt;      \n3 Amegilla (Asaropoda) pa… Inse… Apidae &lt;tibble&gt; &lt;sf&gt;      &lt;sf&gt;       &lt;sf&gt;      \n4 Amegilla (Zonamegilla) … Inse… Apidae &lt;tibble&gt; &lt;sf&gt;      &lt;sf&gt;       &lt;sf&gt;      \n5 Austroplebeia cassiae    Inse… Apidae &lt;tibble&gt; &lt;sf&gt;      &lt;sf&gt;       &lt;sf&gt;      \n6 Braunsapis clarissima    Inse… Apidae &lt;tibble&gt; &lt;sf&gt;      &lt;sf&gt;       &lt;sf&gt;      \n# ℹ 17 more rows\n# ℹ 2 more variables: overlap_area [m^2], percent_overlap [1]\n\n\n\n\nRank species by fire impact\nNext, we will take the top 3 species with the highest percentage range overlap with fire-burned areas (percent_overlap) for our data visualisation. The top 3 species include a stingless bee, a reed bee, and a carpenter bee.\n\ntop3 &lt;- bees_overlap |&gt; \n  slice_max(order_by = percent_overlap,\n            n = 3) \n\ntop3\n\n# A tibble: 3 × 9\n  scientific_name          class family coords   points_sf concave_sf overlap_sf\n  &lt;chr&gt;                    &lt;chr&gt; &lt;chr&gt;  &lt;list&gt;   &lt;list&gt;    &lt;list&gt;     &lt;list&gt;    \n1 Austroplebeia cassiae    Inse… Apidae &lt;tibble&gt; &lt;sf&gt;      &lt;sf&gt;       &lt;sf&gt;      \n2 Exoneura (Exoneura) hac… Inse… Apidae &lt;tibble&gt; &lt;sf&gt;      &lt;sf&gt;       &lt;sf&gt;      \n3 Xylocopa (Koptortosoma)… Inse… Apidae &lt;tibble&gt; &lt;sf&gt;      &lt;sf&gt;       &lt;sf&gt;      \n# ℹ 2 more variables: overlap_area [m^2], percent_overlap [1]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLeft: Austroplebeia (Geoffbyrne CC-BY-NC 4.0), Middle: Exoneura (Campbell Matt CC BY-NC 4.0), Right: Xylocopa (koptortosoma) aruana (zig madycki CC BY 3.0)\n\n\n\n\nMake map\nWe will now select the variables we need and un-nest the relevant ones (points_sf, concave_sf, overlap_sf) for plotting - this gives us everything we need to create our maps!\n\nbee_map_data &lt;- top3 |&gt; \n  select(scientific_name, points_sf, concave_sf, overlap_sf) |&gt; \n  unnest(cols = c(points_sf, concave_sf, overlap_sf)) \n\nbee_map_data |&gt; print(n = 6)\n\n# A tibble: 31 × 4\n  scientific_name                points                                  concave\n  &lt;chr&gt;                     &lt;POINT [°]&gt;                            &lt;POLYGON [°]&gt;\n1 Austroplebeia cassiae (143.45 -14.08) ((143.27 -14.08, 143.28 -14.05, 142.92 …\n2 Austroplebeia cassiae (143.27 -14.08) ((143.27 -14.08, 143.28 -14.05, 142.92 …\n3 Austroplebeia cassiae  (143.32 -14.1) ((143.27 -14.08, 143.28 -14.05, 142.92 …\n4 Austroplebeia cassiae (145.13 -15.67) ((143.27 -14.08, 143.28 -14.05, 142.92 …\n5 Austroplebeia cassiae (143.28 -14.05) ((143.27 -14.08, 143.28 -14.05, 142.92 …\n6 Austroplebeia cassiae (142.92 -13.42) ((143.27 -14.08, 143.28 -14.05, 142.92 …\n# ℹ 25 more rows\n# ℹ 1 more variable: overlap &lt;MULTIPOLYGON [°]&gt;\n\n\n\nCreate the base map\nLet’s create our base map with the outline of Australia and the fire-burned area. You can see a majority of burnt areas are located in Northern Australia and the South-East coast.\n\n# Retrieve Australia polygon\naus &lt;- st_transform(ozmap_country, 4326)\n\nbase_map &lt;- ggplot() + \n  geom_sf(data = aus, colour = \"black\", fill = \"white\") +\n  geom_sf(data = fire, fill = \"#FEC3A6\", colour = \"#FEC3A6\") + \n  theme_void()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdd species range overlap\nNow we can add the range overlap of our three bee species. We use geometry within aes to specify which variable from bee_map_data we want to plot.\n\nmain_map &lt;- base_map + \n  geom_sf(data = bee_map_data, \n          aes(geometry = concave, \n              colour = scientific_name, \n              fill = scientific_name), \n          size = 1.5, alpha = 0.1) + \n  geom_sf(data = bee_map_data, \n          aes(geometry = overlap), \n          colour = \"#FF925C\", fill = \"#FF925C\") + # To highlight area of overlap \n  geom_sf(data = bee_map_data, \n          aes(geometry = points, \n              colour = scientific_name), \n          size = 1) + \n  scale_colour_manual(values = c(\"#023E50\", \"#7B8A6A\", \"#3C908E\")) + \n  scale_fill_manual(values = c(\"#023E50\", \"#7B8A6A\", \"#3C908E\")) + \n  guides(colour = guide_legend(override.aes = list(alpha = 1))) + \n  coord_sf(xlim = c(128, 158)) +\n  theme(legend.title= element_blank(),\n        legend.position = \"bottom\") \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate inset map\nThe navy blue hull in the top right corner of Australia is very small (Austroplebeia cassiae), so we will make an enlarged inset map so we can see it clearer.\n\ninset &lt;- main_map + \n   coord_sf(\n    xlim = c(142.8 , 145.3),\n    ylim = c(-15.9, -13.25),\n    expand = FALSE\n            ) + \n   theme_void() +\n   theme(legend.position = \"none\",\n         panel.border = element_rect(colour = \"black\", fill = NA, linewidth = 0.2))\n\n\n\n\n\n\n\n\n\n\n\n\nWe’ll also draw a box around the area of interest in the enlarged map.\n\nmain_bbox &lt;- main_map + \n   geom_rect(aes(xmin = 142.8, xmax = 145.3,\n             ymin = -15.9, ymax = -13.25),\n             colour = \"black\",\n             fill = NA, \n             lwd = 0.2) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArrange map components\nFinally, we can arrange our base map and inset together for our final map!\nThis map shows the three bee species with the highest percentage overlap with fire-burned areas. Two of these bee species are located in Northern Australia and one is located in South-Eastern Australia.\n\ncombined_map &lt;- ggdraw(main_bbox) +\n  draw_plot(inset, \n            x = 0.52, y = 0.63, \n            width =0.45, height = 0.3)\n\ncombined_map\n\n\n\n\n\n\n\n\n\n\n\nBonus: Vascular plants\nWe repeated the same workflow with the vascular plant dataset and created a map of range overlap with burned areas for the genus Daviesia.\nCommonly known as bitterpeas, Daviesia comprises plants pollinated by reed bees (Exoneura), which are featured in the bee map above.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLeft: Daviesa buxifolia (Betty and Don Wood CC BY 3.0), Middle: Daviesa nova-anglica (Janeteveh CC BY-NC 4.0)), Right: Daviesa suaveolens (Crisp, M.D. CC BY 3.0))\n\n\n\nCode\n# Extract candidate genus\ndaviesia &lt;- vplant_nest |&gt; \n  filter(genus == \"Daviesia\")\n\n# Compute concave hulls\ndaviesia_concave &lt;- daviesia |&gt;\n    mutate(points_sf = map(.x = coords,\n                           ~ st_as_sf(.x, coords = c(\"longitude\", \"latitude\"),\n                                      crs = 4326)), \n           concave_sf = map(points_sf,\n                            ~ concaveman(.x)))\n\n# Compute range overlap and descriptive statistics and select \ndaviesia_overlap &lt;- daviesia_concave |&gt; \n  mutate(overlap_sf = map(concave_sf, \n                          possibly(~ st_intersection(fire, .x) |&gt; select(-Id))),\n  overlap_area = map(overlap_sf,\n                     possibly(~ st_area(.x))),\n  percent_overlap = map2(.x = overlap_area,\n                         .y = concave_sf,\n                         possibly(~ (.x / st_area(.y))*100))) |&gt; \n  unnest(cols = c(overlap_area, percent_overlap)) \n\n## Prepare for plotting and rename variables\ndaviesia_map_data &lt;- daviesia_overlap |&gt; \n  select(species, overlap_area, percent_overlap, points_sf, concave_sf, overlap_sf) |&gt; \n  unnest() |&gt; \n  rename(points = geometry, \n         concave = polygons, \n         overlap = geometry1) \n\n## Create main map reusing base_map from above\ndaviesia_main_map &lt;- base_map + \n    geom_sf(data = daviesia_map_data, \n          aes(geometry = concave, \n              colour = species, \n              fill = species), \n          size = 1.5, alpha = 0.005) + \n  geom_sf(data = daviesia_map_data, \n          aes(geometry = overlap), \n          colour = \"#FF925C\", fill = \"#FF925C\") + \n  geom_sf(data = daviesia_map_data, \n          aes(geometry = points, \n              colour = species), \n          size = 0.9) + \n  scale_colour_manual(values = c(\"#023E50\", \"#7B8A6A\", \"#3C908E\" )) + \n  scale_fill_manual(values = c(\"#023E50\", \"#7B8A6A\", \"#3C908E\")) + \n  guides(colour = guide_legend(override.aes = list(alpha = 1))) + \n  coord_sf(xlim = c(140, 158),\n           ylim = c(-23, -43)) +\n  theme(legend.title= element_blank(),\n        legend.position = \"bottom\") \n\n# Inset 1\ndaviesia_inset_1 &lt;- daviesia_main_map +\ncoord_sf(\n    xlim = c(145.5 , 150.3),\n    ylim = c(-35, -37.95),\n    expand = FALSE\n  ) + \n  theme_void() +\n  theme(legend.position = \"none\",\n        panel.border = element_rect(colour = \"black\", fill = NA, linewidth = 0.3))\n\n# Inset 2\ndaviesia_inset_2 &lt;- daviesia_main_map +\n  coord_sf(\n    xlim = c(151.55 , 152.75),\n    ylim = c(-28.6, -31.25),\n    expand = FALSE\n  ) + \n  theme_void() +\n  theme(legend.position = \"none\",\n        panel.border = element_rect(colour = \"black\", fill = NA, linewidth = 0.3))\n\n# Drawing the inset boxes on main map\ndaviesia_bbox &lt;- daviesia_main_map + \n   geom_rect(aes(xmin = 145.5, xmax = 150.3, # Inset 1\n             ymin = -35, ymax = -37.95),\n             colour = \"black\",\n             fill = NA, linewidth = 0.2) + \n  geom_rect(aes(xmin = 151.55, xmax = 152.75, # Inset 2\n             ymin = -28.6, ymax = -31.25),\n             colour = \"black\",\n             fill = NA, linewidth = 0.2) \n\n# Daviesia plot with insets \ndaviesia_combined &lt;- ggdraw(daviesia_bbox) +\n  draw_plot(daviesia_inset_1, x = 0.59, y = 0.15, \n            width = 0.42, height = 0.30) +\n  draw_plot(daviesia_inset_2, x = 0.52, y = 0.52, \n            width = 0.5, height = 0.4)\n\ndaviesia_combined\n\n\n\n\n\n\n\n\n\n\n\nFinal thoughts\nIn natural catastrophes, decision makers have limited time to act. They need ready-to-go data and workflows to assess and manage possible consequences of the catastrophe and any proposed ways to mitigate it. Here, we used curated datasets of Australian invertebrates and vascular plants to illustrate how concave hulls can represent estimate species range and estimate range overlap with natural disasters. We hope our work can aid future assessments of vulnerable species and help prioritise conservation efforts.\n\n\n\n\n\n\nAcknowledgement:\n\n\n\nThe work in this post is part of a project titled: Curated biodiversity data for rapid assessment of bushfire impact. This project is funded by the Australian Research Data Commons (ARDC) bushfire data challenges program.\n\n\n\n\nExpand for session info\n\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Australia.utf8\n ctype    English_Australia.utf8\n tz       Australia/Sydney\n date     2024-02-12\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package        * version date (UTC) lib source\n concaveman     * 1.1.0   2020-05-11 [1] CRAN (R 4.3.2)\n cowplot        * 1.1.1   2020-12-30 [1] CRAN (R 4.3.2)\n dplyr          * 1.1.4   2023-11-17 [1] CRAN (R 4.3.2)\n forcats        * 1.0.0   2023-01-29 [1] CRAN (R 4.3.2)\n ggplot2        * 3.4.4   2023-10-12 [1] CRAN (R 4.3.1)\n ggpointdensity * 0.1.0   2019-08-28 [1] CRAN (R 4.3.2)\n gt             * 0.10.0  2023-10-07 [1] CRAN (R 4.3.2)\n here           * 1.0.1   2020-12-13 [1] CRAN (R 4.3.2)\n htmltools      * 0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n lubridate      * 1.9.3   2023-09-27 [1] CRAN (R 4.3.2)\n ozmaps         * 0.4.5   2021-08-03 [1] CRAN (R 4.3.2)\n patchwork      * 1.1.3   2023-08-14 [1] CRAN (R 4.3.1)\n purrr          * 1.0.2   2023-08-10 [1] CRAN (R 4.3.2)\n readr          * 2.1.4   2023-02-10 [1] CRAN (R 4.3.2)\n rmapshaper     * 0.5.0   2023-04-11 [1] CRAN (R 4.3.2)\n sessioninfo    * 1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n sf             * 1.0-14  2023-07-11 [1] CRAN (R 4.3.2)\n stringr        * 1.5.1   2023-11-14 [1] CRAN (R 4.3.2)\n tibble         * 3.2.1   2023-03-20 [1] CRAN (R 4.3.2)\n tidyr          * 1.3.0   2023-01-24 [1] CRAN (R 4.3.2)\n tidyverse      * 2.0.0   2023-02-22 [1] CRAN (R 4.3.2)\n viridis        * 0.6.4   2023-07-22 [1] CRAN (R 4.3.2)\n viridisLite    * 0.4.2   2023-05-02 [1] CRAN (R 4.3.1)\n\n [1] C:/Users/KEL329/R-packages\n [2] C:/Users/KEL329/AppData/Local/Programs/R/R-4.3.2/library\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "posts/2023-03-14_animated-map/index.html",
    "href": "posts/2023-03-14_animated-map/index.html",
    "title": "Animated species distribution maps with {gifski}",
    "section": "",
    "text": "Each species has a habitat range where it normally lives and can expect to be found over its lifetime. However, individuals of a species rarely stay in the same spot for long periods of time. Just like us, they react to changes in their environment, interactions with other species, and interactions with other individuals.\nAs a result, it can be useful to see how a distribution of a species changes in space and over time. In marine environments, for example, seemingly small changes in temperature, chemicals and light can result in large changes to a species’ distribution.\nHere we will map the distribution of Nudibranchia around Australia each month as an animated map to see how nudibranch distributions change over the year.\nThis post is inspired by Liam Bailey’s cool (and hilarious) Bigfoot distribution map. You can find his code here."
  },
  {
    "objectID": "posts/2023-03-14_animated-map/index.html#occurrence-data",
    "href": "posts/2023-03-14_animated-map/index.html#occurrence-data",
    "title": "Animated species distribution maps with {gifski}",
    "section": "Occurrence data",
    "text": "Occurrence data\nLet’s first download observations of Nudibranchia across Australia.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLeft: Doriprismatica atromarginata (diana88jingfung CC-BY-NC 4.0 (Int)) Middle: Ceratosoma amoenum (Erik Schlogl CC-BY-NC 4.0 (Int)) Right: Pteraeolidia ianthina (Jallitt CC-BY-NC 4.0 (Int))\n\nWe’ll load the necessary packages.\n\nlibrary(galah)\nlibrary(tidyverse)\nlibrary(glue)\nlibrary(lubridate)\nlibrary(stars)         # Raster management \nlibrary(ozmaps)        # Australian map\nlibrary(SSDM)          # Linear modelling\nlibrary(sdmpredictors) # Environmental variables \nlibrary(grDevices)     # Colours and fonts\nlibrary(maps)          # Cities for map\nlibrary(tmaptools)     # Create plot ratio\nlibrary(gifski)        # Create GIF\nlibrary(knitr)         # View GIF\n\nNow we will use the {galah} package to download observations of Nudibranchia.\nYou will need to provide a registered email with the ALA to galah_config() before retrieving records.\n\n# Add registered email (register at ala.org.au)\ngalah_config(email = \"your-email@email.com\")\n\n\n# Download observations\nnudibranch_occurrences &lt;- \n  galah_call() |&gt;                               \n  galah_identify(\"Nudibranchia\") |&gt;   \n  galah_filter(country == \"Australia\") |&gt;\n  galah_apply_profile(ALA) |&gt; # ALA's set of data cleaning filters\n  atlas_occurrences()"
  },
  {
    "objectID": "posts/2023-03-14_animated-map/index.html#environmental-variables",
    "href": "posts/2023-03-14_animated-map/index.html#environmental-variables",
    "title": "Animated species distribution maps with {gifski}",
    "section": "Environmental variables",
    "text": "Environmental variables\nNow we will download our environmental variables for our model.\nFor our Nudibranchia model, we will use 4 common marine environmental variables:\n\nSea surface temperature\nSea surface salinity\nDistance to shore\nBathymetry\n\nTo get them, we’ll use load_layers() from the {sdmpredictors} package to download our variables as raster layers (geographic layers that have a value per pixel of our variable). We’ll use the rasterstack argument to combine our layers into one object.\n\n\n\n\n\n\nNote\n\n\n\nThe {sdmpredictors} package has lots of data sets and layers available. Check out their website to learn more.\n\n\n\n# Download variables\nenv &lt;- load_layers(layercodes = c(\"MS_biogeo08_sss_mean_5m\", \n                                  \"MS_biogeo13_sst_mean_5m\", \n                                  \"MS_biogeo05_dist_shore_5m\", \n                                  \"MS_bathy_5m\"), \n                   equalarea = FALSE, \n                   rasterstack = TRUE)\n\nTo prepare variable data for our model, we need to crop the geographical boundaries of our data to include only the coast (and surrounding ocean) of Australia. With the help of the {raster} package, we’ll use extent() to set the outer boundaries and crop() to remove the land.\n\n# Create extent\naus_ext &lt;- raster::extent(100, 165, -45, -10)\n\n# Limit environmental variables\naus_env &lt;- raster::crop(env, aus_ext) \n\n# Check variables \nplot(aus_env)"
  },
  {
    "objectID": "posts/2022-10-12_alpha-hulls/index.html",
    "href": "posts/2022-10-12_alpha-hulls/index.html",
    "title": "Convex and alpha hulls for conservation mapping",
    "section": "",
    "text": "The ability to predict where a species resides is important in conservation ecology, but when a species has very few existing observations (i.e. a data-deficient species), predicting its distribution can be difficult (or impossible) using standard methods for species distributions.\nConvex hulls and alpha hulls are two ways to plot the spatial distribution of data-deficient species, making it possible to calculate metrics that help us predict whether a species is threatened to become extinct (i.e. IUCN metrics).\nRecently, Dr. Marsh and colleagues used alpha hulls to estimate the impact of the 2020 mega bushfires on invertebrates in southern Australia. Since invertebrate data is inherently sparse, alpha hulls are really useful when you only have a handful of records to work with.\nIn this post, we’ll explain the difference between convex hulls and alpha hulls and show you how to make them yourself!"
  },
  {
    "objectID": "posts/2022-10-12_alpha-hulls/index.html#download-data",
    "href": "posts/2022-10-12_alpha-hulls/index.html#download-data",
    "title": "Convex and alpha hulls for conservation mapping",
    "section": "Download data",
    "text": "Download data\nTo illustrate the various spatial polygons you can make, let’s look at an invertebrate species from Dr. Marsh’s study: an endemic damselfly, Austroargiolestes calcaris, commonly known as the Powdered Flatwing\n\n\n\n\n\n\n \n\n\n\n\n\n \n\n\n\n\nA Powdered Flatwing perched on a plant by Reiner Richter CC-BY 4.0\n\nFirst we will load the R packages we’ll need:\n\n# install.packages(\"pacman\")\npacman::p_load(remotes, galah, tidyverse, alphahull, \n               sp, sf, ozmaps, patchwork)\n\nNow let’s use galah to download occurrence records from the Atlas of Living Australia (ALA). Note that you will need to first enter a registered email with the ALA using galah_config before fetching records.\n\n# Add registered email (register at ala.org.au)\ngalah_config(email = \"your-email@email.com\")\n\n\n# Download Powdered flatwing records \ngalah_call() |&gt; \n  galah_identify(\"Austroargiolestes calcaris\") |&gt; \n  galah_filter(profile=\"ALA\") |&gt; \n  galah_select(group = \"basic\") |&gt; \n  atlas_occurrences() -&gt; dfly\n\nRetrying in 1 seconds.\n\n# See first 10 rows\ndfly |&gt; head(10L)\n\n# A tibble: 10 × 8\n   recordID       scientificName taxonConceptID decimalLatitude decimalLongitude\n   &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n 1 005e7dd7-884a… Austroargiole… https://biodi…           -36.7             147.\n 2 00c274f7-9fbc… Austroargiole… https://biodi…           -37.9             145.\n 3 00eb34ec-c46c… Austroargiole… https://biodi…           -37.9             145.\n 4 00fabc50-3016… Austroargiole… https://biodi…           -34.0             150.\n 5 012c74aa-0fd8… Austroargiole… https://biodi…           -37.5             147.\n 6 013c14be-3d69… Austroargiole… https://biodi…           -37.9             145.\n 7 0170fe4b-a054… Austroargiole… https://biodi…           -36.9             148.\n 8 017fc3d9-e8c2… Austroargiole… https://biodi…           -37.5             146.\n 9 0213326f-b3da… Austroargiole… https://biodi…           -37.7             146.\n10 02236ffc-4351… Austroargiole… https://biodi…           -37.7             146.\n# ℹ 3 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;\n\n\nBefore we can plot anything, we will also need to remove all duplicated values and any NA values!\n\n# Remove duplicates & NAs\ndfly |&gt; \n  filter(!duplicated(decimalLongitude) & !duplicated(decimalLatitude)) |&gt; \n  filter(!is.na(decimalLongitude) & !is.na(decimalLatitude) ) -&gt; dfly_clean"
  },
  {
    "objectID": "posts/2022-10-12_alpha-hulls/index.html#map-a-convex-hull",
    "href": "posts/2022-10-12_alpha-hulls/index.html#map-a-convex-hull",
    "title": "Convex and alpha hulls for conservation mapping",
    "section": "Map a convex hull",
    "text": "Map a convex hull\nA convex hull is a way to draw around all the points of a species on a map with as few lines as possible. It’s defined as the smallest polygon that encloses all the points in the data set.\nTo plot a convex hull on a map, we can use chull() to compute a convex hull from our cleaned Powdered Flatwing data. chull() computes a series of points that make up our convex hull.\n\n# Compute convex hull\ndfly_clean |&gt; \n  dplyr::select(decimalLongitude, decimalLatitude) |&gt;  \n  chull() -&gt; dfly_chull\n\ndfly_chull\n\n [1] 284 245  98 405 383  84 221 264 105  87 552\n\n\nNext, we join the first point of the hull vector to the last point, creating a closed outline which can be plotted on a map.\n\n# Join first point of hull to the last point\ndfly_chull_pts &lt;- c(dfly_chull, dfly_chull[1])\n\nNow we can get a map of Australia from the {ozmaps} package and use st_transform() to make sure it has the correct projection of 4326.\n\n# Get map of Australia\naus &lt;- st_transform(ozmaps::ozmap_country, 4326)\n\nAnd finally, we plot our Powdered Flatwing occurrence records and its convex hull on a map!\n\n# Plot occurrences and convex hull\nggplot() + \n  geom_sf(data = aus, \n          colour = \"black\", \n          fill = \"white\")  + \n  geom_point(data = dfly_clean, \n             mapping = aes(decimalLongitude, decimalLatitude), \n             colour = \"black\", size = 0.8) + \n  geom_polygon(data = dfly_clean[dfly_chull_pts, ], \n               mapping = aes(decimalLongitude, decimalLatitude), \n               fill = \"orange\", \n               colour = \"black\", \n               alpha = 0.5) + \n  coord_sf(xlim=c(142, 152), \n           ylim=c(-32,-44)) +\n  labs(title = \"Convex hull\", \n       x = \"Longtitude (DD)\", \n       y = \"Latitude (DD)\") + ## DD here stands for decimal degrees\n  theme_bw()"
  },
  {
    "objectID": "posts/2022-10-12_alpha-hulls/index.html#what-is-an-alpha-hull",
    "href": "posts/2022-10-12_alpha-hulls/index.html#what-is-an-alpha-hull",
    "title": "Convex and alpha hulls for conservation mapping",
    "section": "What is an alpha hull?",
    "text": "What is an alpha hull?\nLike a convex hull, an alpha hull is also a way to draw the smallest polygon that encloses all the points in a data set. However, alpha hulls differ because they use an alpha parameter to control how tightly the boundary fits around a set of points. This method creates concave, arched edges that fit around occurrence records more tightly. A tighter boundary around our points helps us avoid over-predicting the range of a species.\nTo illustrate, here are three alpha hulls with increasing values for alpha. Notice as the alpha value increases, the tightness of our boundary decreases.\n\n\nCode\n# Compute alpha shapes and store in list column within a tibble\ntibble(\n  alpha_value = c(1, 2, 5),\n  ahull_ls = map(.x = c(1, 2, 5),\n                 .f = ~ dfly_clean |&gt; \n                   select(decimalLongitude, decimalLatitude) |&gt; \n                   ahull(alpha = .x)) \n) -&gt; dfly_ahulls\n\n\n# Transform alpha hull to an `sp` object and set map projection to 4326\nset_map_proj &lt;- function(sp_obj){\nsp_obj@proj4string &lt;- sp::CRS(\"EPSG:4326\") \n\nsp_obj\n}\n\ndfly_ahulls |&gt; \n  mutate(ahull_sp = map(.x = ahull_ls,\n                        .f = hull2spatial::ahull2poly),\n         ahull_sp = map(.x = ahull_sp,\n                        .f = set_map_proj)\n         ) -&gt; dfly_ahulls\n\n\n# Transform `sp` object into a `sf` object \ndfly_ahulls |&gt; \n  mutate(ahull_sf = map(.x = ahull_sp,\n                        .f = st_as_sf)\n         ) -&gt; dfly_ahulls\n\n# Transform occurrences into `sf` object for plotting\nst_as_sf(dfly_clean, \n         coords = c(\"decimalLongitude\", \"decimalLatitude\"), \n         crs = 4326) -&gt; dfly_sf\n\n## A function to compose map \nplot_ahull_fun &lt;- function(ahull_sf, title = NULL){\n  p &lt;- ggplot() + \n    geom_sf(data = aus, colour = \"black\", fill = \"white\")  +\n    geom_sf(data = dfly_sf, colour = \"black\", size = 0.5) +  \n    geom_sf(data = ahull_sf, fill = \"orange\", alpha = 0.5) +\n    coord_sf(xlim=c(142, 152),ylim=c(-32,-44)) +\n    ggtitle(paste(\"a = \", as.character(title))) +\n    labs(x = \"Longtitude (DD)\", y = \"Latitude (DD)\") + \n    theme_bw(base_size = 12)\n  \n  p\n}\n\ndfly_ahulls |&gt; \n  mutate(ahull_maps = map2(.x = ahull_sf,\n                           .y = alpha_value,\n                           .f = ~ plot_ahull_fun(.x , .y)) \n  ) -&gt; dfly_ahulls\n\n\n\n\n\n\n\n\n\n\n\nAlpha = 2 is the alpha value we’ve most commonly come across in research, and is the value recommended by the IUCN for various forms of species vulnerability analysis.\nSo, let’s learn how to make the a = 2 plot above!"
  },
  {
    "objectID": "posts/2022-10-12_alpha-hulls/index.html#map-an-alpha-hull",
    "href": "posts/2022-10-12_alpha-hulls/index.html#map-an-alpha-hull",
    "title": "Convex and alpha hulls for conservation mapping",
    "section": "Map an alpha hull",
    "text": "Map an alpha hull\nTo make an alpha hull, we will rely on the hull2spatial package (developed by Cecina Babich Morrow). This package allows us to convert “ahull” objects into ggplot-friendly objects (to learn more, check out their blog post about the package).\nInstall the package from GitHub using:\n\nremotes::install_github(\"babichmorrowc/hull2spatial\")\nlibrary(hull2spatial)\n\nTo compute our alpha hull, we’ll provide the longitude and latitude coordinates of our data points to the ahull() function, and set alpha = 2. ahull() creates a list object with far more complexity than our convex hull. A nice way to understand the difference is to look at the first 5 rows of the arcs component of our list dfly_ahull, which stores information like the center and radius of each arch in our alpha hull.\n\n# Compute an alpha hull\ndfly_clean |&gt; \n  dplyr::select(decimalLongitude, decimalLatitude) |&gt; \n  ahull(alpha = 2) -&gt; dfly_ahull\n\n# See first 5 values of `arcs` component of list\ndfly_ahull$arcs |&gt; head(5L)\n\n           c1        c2 r        v.x        v.y        theta end1 end2\n[1,] 143.7540 -36.13036 2  0.7915500 -0.6111044 8.326528e-02  221  264\n[2,] 145.2171 -35.22839 2  0.5608382 -0.8279254 4.870812e-01  264  524\n[3,] 146.5099 -34.22352 2  0.5731316 -0.8194633 3.713225e-01  524  203\n[4,] 148.1218 -33.33548 2  0.6121914 -0.7907096 6.333623e-01  203  105\n[5,] 151.0611 -32.16307 2 -0.5081885 -0.8612458 4.673462e-05  105   87\n\n\nNext we’ll transform our alpha hull and occurrence points into spatial objects for plotting.\nThe ahull2poly() function converts our alpha hull to one type of spatial object (an sp object), but we’ll use st_as_sf() to convert our result to an sf object (because it’s easier to plot) and set our map projection to 4326. We’ll do the same for our damselfly occurrence points.\n\n# Transform  `ahull` into spatial object, convert to sf, set coordinates\nhull2spatial::ahull2poly(dfly_ahull) |&gt; \n  st_as_sf() |&gt; \n  st_set_crs(st_crs(aus)) -&gt; dfly_sf_ahull\n\n# Convert occurrence points to `sf` for plotting\ndfly_clean |&gt; \n  st_as_sf(coords = c(\"decimalLongitude\", \"decimalLatitude\"), \n           crs = 4326) -&gt; dfly_sf\n\nFinally, we can create our plot!\n\n# Plot the occurrences and alpha hull\nggplot() + \n  geom_sf(data = aus, colour = \"black\", fill = \"white\")  +\n  geom_sf(data = dfly_sf, colour = \"black\", size = 0.5) +  \n  geom_sf(data = dfly_sf_ahull, fill = \"orange\", alpha = 0.5) +\n  coord_sf(xlim=c(142, 152),ylim=c(-32,-44)) +\n  ggtitle(\"Alpha hull\") +\n  labs(x = \"Longtitude (DD)\", y = \"Latitude (DD)\") + \n  theme_bw()\n\n\n\n\n\n\n\n\n\nAlpha hull with filtered observations\nCitizen science data are often excluded from scientific analyses due to poor data quality e.g. rare species can be misidentified by someone who’s not an expert. Although a strict data criteria will reduce the number of data points, we can still compute and plot alpha hulls for the Powdered Flatwing - this is the beauty of them!\nLet’s repeat exactly the same steps as above for generating an alpha hull, but only use a subset of our damselfly observations that comes from specimen data. We can do this by specifying the basisOfRecord with galah_filter().\n\n# Create a vector excluding human observations\ninstitution_only &lt;- c(\"PRESERVED_SPECIMEN\", \"LIVING_SPECIMEN\", \n                   \"MACHINE_OBSERVATION\", \"MATERIAL_SAMPLE\")\n\ngalah_call() |&gt; \n  galah_identify(\"Austroargiolestes calcaris\") |&gt; \n  galah_filter(basisOfRecord == institution_only,\n               profile = \"ALA\") |&gt; \n  galah_select(group = \"basic\") |&gt; \n   atlas_occurrences() -&gt; dfly_specionly\n\nBelow is our alpha hull of our specimen-only damselfly data. You’ll notice that there are two separate hulls in this map! This is another benefit of using an alpha hull over a convex hull. The mathematical constraints of a convex hull mean all points must be contained within a single polygon - this can lead to an over-estimation of a species’ range."
  },
  {
    "objectID": "posts/2022-10-12_alpha-hulls/index.html#a-real-life-example",
    "href": "posts/2022-10-12_alpha-hulls/index.html#a-real-life-example",
    "title": "Convex and alpha hulls for conservation mapping",
    "section": "A real-life example",
    "text": "A real-life example\nAlpha hulls, and their ability to generate multiple hulls when data is sparse, can help us understand how sensitive certain species are to environmental change over time, even when species have few existing observations.\nFor example, Dr. Takach and their team wanted to investigate how the distribution of mammals in the tropical savanna like Mesembriomys gouldii (the Black-Footed Tree Rat) shrink or expand in response to pressures like habitat loss and changing climate. Using alpha hulls, they found that the ecological niche of this species has shrunk due to a loss of suitable habitat over time.\n\n\n\n\n\n\n \n\n\n\n\n\n \n\n\n\n\nA Black-Footed Tree Rat perched on a branch by Colin Trainor CC-BY-NC 4.0\n\nThe published paper didn’t provide a visual of this species’ distribution, so we’ve made a map below with ALA data to show the change in distribution over time:\n\n\nCode\n# Download records\ngalah_call() |&gt; \n  galah_identify(\"Mesembriomys gouldii\") |&gt; \n  galah_filter(profile = \"ALA\") |&gt; \n  galah_select(group = \"basic\") |&gt; \n  atlas_occurrences() -&gt; tree_rat\n\n\nRetrying in 1 seconds.\nRetrying in 2 seconds.\n\n\nCode\n# Remove duplicates and NAs\ntree_rat |&gt; \n  filter(! duplicated(decimalLongitude) & ! duplicated(decimalLatitude)) |&gt; \n  filter(! is.na(decimalLongitude) & ! is.na(decimalLatitude) ) -&gt; tree_ratclean\n\n# Convert occurrence points to sf for plotting\ntree_ratclean |&gt; \n  st_as_sf(coords = c(\"decimalLongitude\", \"decimalLatitude\"), \n           crs = 4326) -&gt; tree_rat_sf\n\n# Compute alpha hull\ntree_ratclean |&gt; \n  select(decimalLongitude, decimalLatitude) |&gt; \n  ahull(alpha = 2) -&gt; tree_rat_ahull\n\n# Transform `ahull` to `sf`, set projection\nhull2spatial::ahull2poly(tree_rat_ahull) |&gt; \n  st_as_sf() |&gt;\n  st_set_crs(st_crs(aus)) -&gt; tree_rat_sf_ahull\n\n# Convert occurrence points to sf for plotting\ntree_ratclean |&gt; \n  st_as_sf(coords = c(\"decimalLongitude\", \"decimalLatitude\"), \n           crs = 4326) -&gt; tree_rat_sf\n\n# Get map of Australia & set projection\naus &lt;- st_transform(ozmaps::ozmap_country, 4326)\n\n#---\n\n# Download tree rat records after 2000\ngalah_call() |&gt;\n  galah_identify(\"Mesembriomys gouldii\") |&gt;\n  galah_filter(profile = \"ALA\",\n               year &gt;= 2000,) |&gt;\n  galah_select(group = \"basic\") |&gt;\n  atlas_occurrences() -&gt; Rtree_rat\n\n\nRetrying in 1 seconds.\n\n\nCode\n# Remove duplicates & exclude NAs\nRtree_rat |&gt; \n  filter(!duplicated(decimalLongitude) & !duplicated(decimalLatitude)) |&gt; \n  filter(!is.na(decimalLongitude) & !is.na(decimalLatitude) ) -&gt; Rtree_ratclean\n\n# Compute an alpha hull for our specimen only occurrences\nRtree_ratclean |&gt; \n  select(decimalLongitude, decimalLatitude) |&gt; \n  ahull(alpha = 2) -&gt; Rtree_rat_ahull\n\n# Transform `ahull` to sf, set coordinates\nhull2spatial::ahull2poly(Rtree_rat_ahull) |&gt; \n  st_as_sf() |&gt; \n  st_set_crs(st_crs(aus)) -&gt; Rtree_rat_sf_ahull\n\n# Transform occurrence points to sf for plotting \nRtree_ratclean |&gt; \n  st_as_sf(coords = c(\"decimalLongitude\", \"decimalLatitude\"), \n           crs = 4326) -&gt; Rtree_rat_sf\n\n#---\n\n# Nice title\nrat_title &lt;- expression(italic(\"Mesembriomys gouldii \"), \"alpha hulls\")\n\n# Plot!\nggplot() + \n  geom_sf(data = aus, colour = \"black\", fill = \"white\")  +\n  geom_sf(data = tree_rat_sf_ahull, aes(fill = \"chartreuse3\") ,alpha = 0.5, colour = \"black\", position = \"identity\") +\n    geom_sf(data = Rtree_rat_sf_ahull, aes(fill = \"blueviolet\"), alpha = 0.5, colour = \"black\", position = \"identity\") +\n  scale_fill_identity(guide = \"legend\",\n                      name = \"Record date ranges\",\n                      labels = c('2000 Onwards', 'All Records')) +\n  guides(colour = guide_legend(override.aes = list(alpha = 0.1))) +\n  coord_sf(xlim=c(125, 145),ylim=c(-20,-10)) +\n  ggtitle(rat_title) +\n  labs(x = \"Longtitude (DD)\", y = \"Latitude (DD)\") + \n  theme_bw() +\n  theme(legend.position = \"bottom\") -&gt; combinedtree_rat_ahull_p"
  },
  {
    "objectID": "posts/2022-10-12_alpha-hulls/index.html#final-thoughts",
    "href": "posts/2022-10-12_alpha-hulls/index.html#final-thoughts",
    "title": "Convex and alpha hulls for conservation mapping",
    "section": "Final thoughts",
    "text": "Final thoughts\nWhile sophisticated tools for modelling species distribution exist, they require a lot of data to make reliable estimates. Convex polygons and alpha hulls are flexible alternatives that can help us understand dynamic changes to distributions of understudied or vulnerable data-deficient species.\n\n\n\n\n\n\nAcknowledgement:\n\n\n\nThe work in this post is part of project titled: Curated biodiversity data for rapid assessment of bushfire impact. This project is funded by the Australian Research Data Commons (ARDC) bushfire data challenges program.\n\n\n\n\nExpand for session info\n\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Australia.utf8\n ctype    English_Australia.utf8\n tz       Australia/Sydney\n date     2024-02-12\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package       * version date (UTC) lib source\n alphahull     * 2.5     2022-06-16 [1] CRAN (R 4.3.2)\n dplyr         * 1.1.4   2023-11-17 [1] CRAN (R 4.3.2)\n forcats       * 1.0.0   2023-01-29 [1] CRAN (R 4.3.2)\n galah         * 2.0.1   2024-02-06 [1] CRAN (R 4.3.2)\n ggplot2       * 3.4.4   2023-10-12 [1] CRAN (R 4.3.1)\n htmltools     * 0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n hull2spatial  * 0.1.0   2022-10-12 [1] Github (babichmorrowc/hull2spatial@921594f)\n lubridate     * 1.9.3   2023-09-27 [1] CRAN (R 4.3.2)\n ozmaps        * 0.4.5   2021-08-03 [1] CRAN (R 4.3.2)\n pacman        * 0.5.1   2019-03-11 [1] CRAN (R 4.3.2)\n patchwork     * 1.1.3   2023-08-14 [1] CRAN (R 4.3.1)\n purrr         * 1.0.2   2023-08-10 [1] CRAN (R 4.3.2)\n readr         * 2.1.4   2023-02-10 [1] CRAN (R 4.3.2)\n remotes       * 2.4.2.1 2023-07-18 [1] CRAN (R 4.3.2)\n sessioninfo   * 1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n sf            * 1.0-14  2023-07-11 [1] CRAN (R 4.3.2)\n sp            * 2.1-2   2023-11-26 [1] CRAN (R 4.3.2)\n stringr       * 1.5.1   2023-11-14 [1] CRAN (R 4.3.2)\n tibble        * 3.2.1   2023-03-20 [1] CRAN (R 4.3.2)\n tidyr         * 1.3.0   2023-01-24 [1] CRAN (R 4.3.2)\n tidyverse     * 2.0.0   2023-02-22 [1] CRAN (R 4.3.2)\n xaringanExtra * 0.7.0   2022-07-16 [1] CRAN (R 4.3.2)\n\n [1] C:/Users/KEL329/R-packages\n [2] C:/Users/KEL329/AppData/Local/Programs/R/R-4.3.2/library\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "posts/2022-05-23-ggnewscale/index.html",
    "href": "posts/2022-05-23-ggnewscale/index.html",
    "title": "Multiple colour scales in choropleth maps with {ggnewscale}",
    "section": "",
    "text": "Author\nShandiya Balasubramaniam\n\n\nDate\n23 May 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChoropleth maps visually summarise how variables (like species richness or population density, for example) vary across geographic areas. These maps require two inputs:\n\na geospatial object with information on regional boundaries\na numerical variable that can be mapped to each geographic unit using colour\n\nHere, I walk through the process of mapping the density of plant records from the ALA to geographic bioregions across Australia, using two colour scales to differentiate between marine and terrestrial records.\n\nGet geospatial and count data\nLet’s start by loading the packages we’ll need.\n\nlibrary(galah)\nlibrary(here)\nlibrary(sf)\nlibrary(rmapshaper)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(ggnewscale)\n\nNext, we’ll need some regional boundaries. I think the IBRA7 and IMCRA4 bioregions will work nicely for what we’re planning. These boundaries classify Australia’s landscapes and waters into geographically distinct bioregions based on variables like climate, geomorphology, and species information.\nAfter downloading the data, we can read it in using the sf package and check that it looks correct. Here, I’ve also elected to use ms_simplify() from the rmapshaper package to simplify the geospatial features and speed up computation.\n\n# read in IMCRA shapefile\nimcra_shp &lt;- st_read(here(\"posts\", \n                          \"data\",\n                          \"imcra_mesoscale_bioregions\",\n                          \"imcra4_meso.shp\"), \n                     quiet = TRUE) |&gt; \n  ms_simplify(keep = 0.1)\n\n# read in IBRA shapefile\nibra_shp &lt;- st_read(here(\"posts\",\n                         \"data\",\n                         \"IBRA7_regions\",\n                         \"ibra7_regions.shp\"),\n                    quiet = TRUE) |&gt; \n  ms_simplify(keep = 0.1)\n\nAnd finally, let’s get the number of plant records in the ALA using the galah package, grouped by IBRA or IMCRA region. To do this, we need to know what the ALA calls the IBRA and IMCRA layers.\nUsing the search_fields() function, we can determine that the IBRA layer we’re after is called cl1048 and the IMCRA layer, cl966.\n\nsearch_fields(\"IBRA\")\n\n# A tibble: 3 × 3\n  id     description       type  \n  &lt;chr&gt;  &lt;chr&gt;             &lt;chr&gt; \n1 cl20   IBRA 6 Regions    fields\n2 cl1048 IBRA 7 Regions    fields\n3 cl1049 IBRA 7 Subregions fields\n\nsearch_fields(\"IMCRA\")\n\n# A tibble: 2 × 3\n  id    description                 type  \n  &lt;chr&gt; &lt;chr&gt;                       &lt;chr&gt; \n1 cl21  IMCRA Regions               fields\n2 cl966 IMCRA Meso-scale Bioregions fields\n\n\nTo get counts of records from the ALA, we can pass a query with galah_call() and build our query using pipes.\nWe will specify that we only want plant records matching Plantae or Chlorophyta using galah_identify(), apply the default set of ALA data quality filters to remove poor quality records using galah_filter(), group records by region using galah_group_by(), and finally return the counts of records that match all our criteria with atlas_counts().\n\n# counts in IBRA regions\nibra_counts &lt;- galah_call() |&gt;\n  galah_identify(\"plantae\", \"chlorophyta\") |&gt;\n  galah_filter(profile = \"ALA\") |&gt; \n  galah_group_by(\"cl1048\") |&gt;      # IBRA regions\n  atlas_counts()\n\nhead(ibra_counts)\n\n# A tibble: 6 × 2\n  cl1048                      count\n  &lt;chr&gt;                       &lt;int&gt;\n1 Sydney Basin              2809259\n2 South Eastern Highlands   1833611\n3 South Eastern Queensland  1104671\n4 NSW North Coast            925380\n5 South East Corner          909572\n6 Murray Darling Depression  904340\n\n# counts in IMCRA regions\nimcra_counts &lt;- galah_call() |&gt;\n  galah_identify(\"plantae\", \"chlorophyta\") |&gt;\n  galah_filter(profile = \"ALA\") |&gt; \n  galah_group_by(\"cl966\") |&gt;      # IMCRA bioregions\n  atlas_counts()\n\nhead(imcra_counts)\n\n# A tibble: 6 × 2\n  cl966                 count\n  &lt;chr&gt;                 &lt;int&gt;\n1 Shoalwater Coast     434913\n2 Lucinda-Mackay Coast 260228\n3 Torres Strait        242812\n4 West Cape York       215772\n5 Wet Tropic Coast     143362\n6 Pellew                91955\n\n\n\n\nJoin geospatial and count data\nWe now have the two things we need to make a choropleth map:\n\nIBRA/IMCRA boundaries\ncounts of plant records in each region\n\nTo create a plot, we need to combine the geospatial and numeric data. But first, let’s check if the data needs to be tidied.\nAs we’re going to be joining the spatial and count data, we need to be sure that the names of the IBRA/IMCRA regions match in both datasets. To double check that all of our region names match, we’ll use setdiff(). There are no name mismatches when character(0) is returned, but if any region names are returned that means there is a problem somewhere that we need to fix before joining our dataframes.\nWhen we run setdiff(), the IBRA names match perfectly, but there’s a mismatch in two IMCRA names.\n\n# check region names match\nsetdiff(ibra_counts$cl1048, ibra_shp$REG_NAME_7)\n\ncharacter(0)\n\nsetdiff(imcra_counts$cl966, imcra_shp$MESO_NAME)\n\n[1] \"Pilbarra (nearshore)\" \"Pilbarra (offshore)\" \n\n\nReversing the order of IMCRA data frames in setdiff() reveals that that Pilbara is misspelled in the imcra_counts dataset. We can easily change this and confirm both sets of names match before continuing.\n\n# check the reverse for IMCRA names\nsetdiff(imcra_shp$MESO_NAME, imcra_counts$cl966)\n\n[1] \"Pilbara (offshore)\"  \"Pilbara (nearshore)\"\n\n# replace \"Pilbarra\" with \"Pilbara\" \nimcra_counts &lt;- imcra_counts |&gt; \n  mutate(cl966 = str_replace(string = cl966, \n                             pattern = \"Pilbarra\", \n                             replacement = \"Pilbara\"))\n\n# check names match\nsetdiff(imcra_counts$cl966, imcra_shp$MESO_NAME)\n\ncharacter(0)\n\n\nNow let’s check how our data are distributed so we can decide whether we should scale them with a transformation before plotting. Data skewed too far to the right will not show differences very clearly when they are mapped.\nChecking the distribution of counts in each dataset shows a substantial skew to the right.\nhist(imcra_counts$count)\nhist(ibra_counts$count)\n\n\n\n\n\n\n\n\n\n\nApplying a log-transformation to the count data makes the distribution more symmetrical.\nhist(log(imcra_counts$count))\nhist(log(ibra_counts$count))\n\n\n\n\n\n\n\n\n\n\nNext, we join the geospatial and numeric data. Along the way, we rename some columns, remove unnecessary columns, calculate counts as a proportion of the area of each region (so we’re plotting density of records, not counts of records), and convert the resulting dataframe into a simple features object.\n\nimcra_join &lt;- imcra_counts |&gt; \n  full_join(y = imcra_shp, by = c(\"cl966\" = \"MESO_NAME\")) |&gt; \n  rename(\"imcra\" = \"cl966\") |&gt; \n  select(imcra, count, AREA_KM2, geometry) |&gt; \n  mutate(density_log10 = log10(count / AREA_KM2)) |&gt; \n  select(imcra, density_log10, geometry) |&gt; \n  st_as_sf()\n\nibra_join &lt;- ibra_counts |&gt; \n  full_join(y = ibra_shp, by = c(\"cl1048\" = \"REG_NAME_7\")) |&gt; \n  rename(\"ibra\" = \"cl1048\") |&gt; \n  select(ibra, count, SQ_KM, geometry) |&gt; \n  mutate(density_log10 = log10(count / SQ_KM)) |&gt; \n  select(ibra, density_log10, geometry) |&gt; \n  st_as_sf()\n\n\n\nMake a map\nFinally, we’ll use the ggnewscale package to apply different colour palettes to the marine and terrestrial data in a choropleth map.\n\nggplot() + \n  geom_sf(data = imcra_join,\n          aes(fill = density_log10),\n          colour = NA) +\n  scale_fill_distiller(name = \"IMCRA\",\n                       type = \"seq\",\n                       palette = \"BuPu\",\n                       direction = 1,\n                       labels = c(\"0.001\", \"0.01\", \"0.1\", \"1\", \"10\"),\n                       guide = guide_colorsteps(direction = \"horizontal\",\n                                                label.position = \"bottom\",\n                                                title.position = \"left\")) +\n  # adds new colour scale\n  ggnewscale::new_scale_fill() +\n  geom_sf(data = ibra_join,\n          aes(fill = density_log10),\n          colour = NA) +\n  scale_fill_distiller(name = \"IBRA\",\n                       type = \"seq\",\n                       palette = \"YlOrBr\",\n                       direction = 1,\n                       labels = c(\"0.1\", \"1\", \"10\", \"100\"),\n                       guide = guide_colorsteps(direction = \"horizontal\",\n                                                label.position = \"bottom\",\n                                                title.position = \"left\")) +\n  # adds a title for both legends\n  annotate(\"text\", \n           x = 133, \n           y = -45.5, \n           label = \"No. of records per square km\",\n           size = 6) +\n  coord_sf(xlim = c(110, 155), ylim = c(-45, -10)) +\n  theme_void() +\n  theme(legend.position = \"bottom\",\n        legend.key.width = unit(12, 'mm'))\n\n\n\n\n\n\n\n\n\n\nSuccess!\nOne thing to note is that we didn’t necessarily have to use ggnewscale here; we could just as easily have combined all the data and plotted them on the same map without keeping the IBRA and IMCRA datasets separate. But, i) it’s nice to be able to differentiate marine and terrestrial regions at a glance, and ii) using two legends also makes it clear that there’s a stark difference in the number of plant records for marine and terrestrial regions.\n\n\nExpand for session info\n\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Australia.utf8\n ctype    English_Australia.utf8\n tz       Australia/Sydney\n date     2024-02-12\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n dplyr       * 1.1.4   2023-11-17 [1] CRAN (R 4.3.2)\n galah       * 2.0.1   2024-02-06 [1] CRAN (R 4.3.2)\n ggnewscale  * 0.4.9   2023-05-25 [1] CRAN (R 4.3.2)\n ggplot2     * 3.4.4   2023-10-12 [1] CRAN (R 4.3.1)\n here        * 1.0.1   2020-12-13 [1] CRAN (R 4.3.2)\n htmltools   * 0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n rmapshaper  * 0.5.0   2023-04-11 [1] CRAN (R 4.3.2)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n sf          * 1.0-14  2023-07-11 [1] CRAN (R 4.3.2)\n stringr     * 1.5.1   2023-11-14 [1] CRAN (R 4.3.2)\n\n [1] C:/Users/KEL329/R-packages\n [2] C:/Users/KEL329/AppData/Local/Programs/R/R-4.3.2/library\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "posts/2022-02-17_sunburst-plots-for-taxonomic-data/post.html",
    "href": "posts/2022-02-17_sunburst-plots-for-taxonomic-data/post.html",
    "title": "Sunburst plots for taxonomic data",
    "section": "",
    "text": "Author\nMartin Westgate\n\n\nDate\nFebruary 17 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTaxonomy is pretty important at the ALA. Every occurrence record in the atlas is linked to a unique taxonomic identifier. These identifiers are themselves drawn from expertly curated taxonomic datasets. This system of classification is so important to our infrastructure that we have a special name for it; the ‘taxonomic backbone’. But what does it look like?\nVisualising trees is not particularly easy for me; I didn’t train in it, and the data structures involved can be a bit complex. More importantly, until recently it was difficult to download detailed taxonomic information from the ALA. Since version 1.3.1 of galah, however, it has been possible to download taxonomic trees using the atlas_taxonomy() function. Let’s have a go at visualising these trees now.\n\nDownloading taxonomic trees\nThe first step is to choose a taxonomic group to represent in tree form. I’ve chosen the chordates (Phylum Chordata) because they aren’t too large a group and the names are fairly well-known. We can specify this within galah using the function galah_identify. The second piece of information we need to supply is how far ‘down’ the tree to travel. I’ve chosen the Order level here using galah_down_to(order); while we could have gone to the Family or even Genus, trying to traverse too many levels (i.e. to Genus or Species) would take a very long time. A full list of accepted ranks can be found by calling show_all_ranks().\n\nlibrary(galah)\nchordate_orders &lt;- galah_call() |&gt;\n  galah_identify(\"chordata\") |&gt;\n  galah_down_to(order) |&gt;\n  atlas_taxonomy()\n\nThe object returned by atlas_taxonomy is slightly unusual; it uses the data.tree package, meaning that the dataset is literally structured like a tree. This is notably different from other representations of networks, such as you might find in igraph, for example. To get an idea of what the data look like, we can use the inbuilt print method for this data type:\n\nlibrary(data.tree)\nprint(chordate_orders, pruneMethod = \"dist\", limit = 10)\n\n                            levelName\n1  Chordata                          \n2   ¦--Cephalochordata               \n3   ¦   °--Amphioxi                  \n4   ¦       °--... 1 nodes w/ 0 sub  \n5   ¦--Tunicata                      \n6   ¦   ¦--Appendicularia            \n7   ¦   ¦   °--... 1 nodes w/ 0 sub  \n8   ¦   ¦--Ascidiacea                \n9   ¦   ¦   °--... 5 nodes w/ 0 sub  \n10  ¦   °--Thaliacea                 \n11  ¦       °--... 3 nodes w/ 0 sub  \n12  °--Vertebrata                    \n13      ¦--Agnatha                   \n14      ¦   °--... 2 nodes w/ 2 sub  \n15      °--Gnathostomata             \n16          °--... 5 nodes w/ 134 sub\n\n\nThis shows there are three nodes directly beneath Chordata in the taxonomic hierarchy, of which the largest (by number of sub-nodes) is the vertebrates (Vertebrata). There is a lot we could do with this tree; each node contains a unique taxonomic identifer, for example, meaning that we could use individual nodes to make new queries using galah. However, for now a useful task is simply to visualise the structure of the whole tree.\n\n\nGetting plot-ready data\nTaxonomic trees are complex. While all species have a Kingdom, Phylum, Order, Class and Family, there are many intermediate categories that are ‘optional’. In practice, this means that when we convert to a data.frame for plotting, there are a lot of missing values; nodes that apply to some rows but not others.\n\ndf_rank &lt;- ToDataFrameTypeCol(chordate_orders, type = \"rank\")\ndf_rank[10:20,] |&gt; tibble::as_tibble() |&gt; print(max_footer_lines = 2)\n\n# A tibble: 11 × 10\n   rank_phylum rank_su…¹ rank_…² rank_…³ rank_…⁴ rank_…⁵ rank_…⁶ rank_…⁷ rank_…⁸\n   &lt;chr&gt;       &lt;chr&gt;     &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  \n 1 Chordata    Tunicata  Thalia… &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   \n 2 Chordata    Vertebra… &lt;NA&gt;    Myxini… &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   \n 3 Chordata    Vertebra… &lt;NA&gt;    Petrom… &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   \n 4 Chordata    Vertebra… Amphib… Gnatho… Lissam… &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   \n 5 Chordata    Vertebra… Amphib… Gnatho… &lt;NA&gt;    Labyri… &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   \n 6 Chordata    Vertebra… Amphib… Gnatho… &lt;NA&gt;    Salien… &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   \n 7 Chordata    Vertebra… Aves    Gnatho… Neogna… &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   \n 8 Chordata    Vertebra… Aves    Gnatho… Neogna… &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   \n 9 Chordata    Vertebra… Aves    Gnatho… Palaeo… &lt;NA&gt;    Ratitae &lt;NA&gt;    &lt;NA&gt;   \n10 Chordata    Vertebra… Aves    Gnatho… Palaeo… &lt;NA&gt;    Ratitae &lt;NA&gt;    &lt;NA&gt;   \n11 Chordata    Vertebra… Aves    Gnatho… &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   \n# … with 1 more variable: rank_order &lt;chr&gt;, and abbreviated variable names\n#   ¹​rank_subphylum, ²​rank_class, ³​rank_informal, ⁴​rank_subclass, …\n\n\nThese missing values will show up as empty sections in the resulting diagram, which isn’t ideal. Instead, we can build this data.frame so as to place all nodes in order by row, with empty ‘levels’ being placed at the end. This also avoids the problem where ‘unnamed’ ranks are grouped in the same column. To achieve this, we simply choose a different node attribute (level in this case) to supply to the type argument.\n\ndf_level &lt;- ToDataFrameTypeCol(chordate_orders, type = \"level\")\ndf_level[10:20, ] |&gt; tibble::as_tibble()\n\n# A tibble: 11 × 8\n   level_1  level_2    level_3       level_4     level_5 level_6 level_7 level_8\n   &lt;chr&gt;    &lt;chr&gt;      &lt;chr&gt;         &lt;chr&gt;       &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  \n 1 Chordata Tunicata   Thaliacea     Salpida     &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   \n 2 Chordata Vertebrata Agnatha       Myxini      Myxini… &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   \n 3 Chordata Vertebrata Agnatha       Petromyzon… Petrom… &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   \n 4 Chordata Vertebrata Gnathostomata Amphibia    Lissam… Anura   &lt;NA&gt;    &lt;NA&gt;   \n 5 Chordata Vertebrata Gnathostomata Amphibia    Labyri… Temnos… &lt;NA&gt;    &lt;NA&gt;   \n 6 Chordata Vertebrata Gnathostomata Amphibia    Salien… Spheno… &lt;NA&gt;    &lt;NA&gt;   \n 7 Chordata Vertebrata Gnathostomata Aves        Neogna… Accipi… &lt;NA&gt;    &lt;NA&gt;   \n 8 Chordata Vertebrata Gnathostomata Aves        Neogna… Phaeth… &lt;NA&gt;    &lt;NA&gt;   \n 9 Chordata Vertebrata Gnathostomata Aves        Palaeo… Ratitae Casuar… &lt;NA&gt;   \n10 Chordata Vertebrata Gnathostomata Aves        Palaeo… Ratitae Dinorn… &lt;NA&gt;   \n11 Chordata Vertebrata Gnathostomata Aves        Accipi… &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;   \n\n\nAnother problem in this dataset is the existence of duplicated taxonomic names. This happens because different authorities place the same taxon in different parts of the tree, and while the ALA tries to clean up these issues, some disagreements remain. The code below assumes that each name is only present once, so we have to remove duplicates to proceed. Fortunately there is a function in package base that flags duplcated values as TRUE and unique values as FALSE. We can use this function to identify rows where order is not unique.\n\nlibrary(dplyr)\nkeep_rows &lt;- !duplicated(df_rank$rank_order)\ndf_rank &lt;- filter(df_rank, keep_rows)\ndf_level &lt;- filter(df_level, keep_rows)\n\nThe next step is to determine how to represent this structure in a plot. At the moment we can’t do this, because the data are in ‘wide’ format. Instead, we need to reorder our data so that each node/taxon is represented once, and other plotting aesthetics can be added as additional columns. To achieve this, we first convert to ‘long’ format, preserving information like what row and column each taxonomic label was recorded in.\n\ndf_long &lt;- tibble(\n  row = rep(seq_len(nrow(df_level)), ncol(df_level)),\n  level = rep(seq_len(ncol(df_level)), each = nrow(df_level)),\n  taxon = do.call(c, df_level)) |&gt; \n  filter(!is.na(taxon)) # remove missing values\n\nThen, we can summarize this plot so that each row is a single taxon, recording some metadata about rows and columns from the original dataset\n\ndf_plot &lt;- df_long |&gt;\n  group_by(taxon) |&gt;\n  summarize(\n    xmin = min(row) - 1, \n    xmax = max(row), \n    ymin = level[1] - 1,\n    ymax = level[1])\n     \ndf_plot\n\n# A tibble: 161 × 5\n   taxon             xmin  xmax  ymin  ymax\n   &lt;chr&gt;            &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt;\n 1 Acanthopterygii     61    74     6     7\n 2 Accipititrifomes    15    16     5     6\n 3 Accipitriformes     19    20     4     5\n 4 Actinopterygii      56    96     4     5\n 5 Agnatha             10    12     2     3\n 6 Albuliformes        57    58     6     7\n 7 Amphibia            12    15     3     4\n 8 Amphioxi             0     1     2     3\n 9 Amphioxiformes       0     1     3     4\n10 Anguilliformes      58    59     6     7\n# … with 151 more rows\n\n\n\n\nDrawing\nOur dataset now contains all the information we need to plot the structure of our taxonomic tree. As usual, we’re going to plot this with ggplot2.\n\nlibrary(ggplot2)\nggplot(df_plot) +\n  geom_rect(\n    mapping = aes(\n      xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, \n      group = taxon,\n      fill = ymax),\n    color = \"white\")\n\n\n\n\n\n\n\n\nWhile this is (probably) accurate, it’s not very informative. The most obvious missing element is labels; to add these, we’ll need to determine which nodes are ‘leaves’, and which are ‘branches’. We’ll also want to restrict labelling to larger branches, to avoid the text looking crowded. Finally, there is no need to label leaves with both a rectangle and text; so we’ll remove the leaf rectangles from the plot.\n\ndf_plot &lt;- df_plot |&gt; mutate(\n  x_dist = xmax - xmin,\n  is_leaf = taxon %in% df_rank$rank_order)\n\np &lt;- ggplot() +\n  geom_rect(\n    data = filter(df_plot, !is_leaf),\n    mapping = aes(\n      xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, \n      group = taxon,\n      fill = ymax),\n    color = \"white\")\n\np +\n  # branch labels\n  geom_text(\n    data = filter(df_plot, x_dist &gt; 5),\n    mapping = aes(\n      x = xmin + (x_dist * 0.5), \n      y = ymin + 0.5,\n      label = taxon),\n    color  = \"white\",\n    size = 3) +\n  # leaf labels\n  geom_text(\n    data = filter(df_plot, is_leaf),\n    aes(x = xmin + 0.5, y = ymin, label = taxon),\n    angle = 90,\n    hjust = 0,\n    size = 2.5,\n    color = \"grey20\") \n\n\n\n\n\n\n\n\nThis is better, but not ideal. A much more pleasing look is to use coord_polar() to generate a circular plot; but this leads to linear text on a circular plot, which looks messy. Fortunately, the new package geomtextpath solves this problem. All we have to do is replace geom_text with geom_textpath, leaving all other code the same, and add coord_polar() at the end.\n\nlibrary(geomtextpath)\n\np &lt;- p + \n  geom_textpath(\n    data = filter(df_plot, x_dist &gt; 5),\n    mapping = aes(\n      x = xmin + (x_dist * 0.5), \n      y = ymin + 0.5,\n      label = taxon),\n    color  = \"white\",\n    size = 2.7) +\n  geom_textpath(\n    data = filter(df_plot, is_leaf),\n    aes(x = xmin + 0.5, y = ymin, label = taxon),\n    angle = 90,\n    hjust = 0,\n    size = 2.3,\n    color = \"grey20\") +\n  coord_polar()\np\n\n\n\n\n\n\n\n\nFinally, we can add some finishing touches by changing the color scheme, hiding the background colors and legend, and resizing the y axis so all the labels are visible.\n\nlibrary(viridis)\n\np +\n  scale_fill_viridis(begin = 0, end = 0.9, direction = -1) +\n  lims(y = c(0, 9)) +\n  theme_void() + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\nDone! This is a fun plot, but there are ways it could be expanded or improved, the most obvious of which is to find ways to add supplementary information. Wouldn’t it be great, for example, to add leaf-level record counts as marginal barplots? Or scale the size of segments to the number of records, rather than the number of clades? While none of these are impossible, I’m going to leave this here for now. I hope you like the result!\n\n\nExpand for session info\n\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.2 (2022-10-31 ucrt)\n os       Windows 10 x64 (build 19044)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Australia.utf8\n ctype    English_Australia.utf8\n tz       Australia/Sydney\n date     2023-03-29\n pandoc   2.19.2 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package      * version date (UTC) lib source\n data.tree    * 1.0.0   2020-08-03 [1] CRAN (R 4.2.1)\n dplyr        * 1.1.0   2023-01-29 [1] CRAN (R 4.2.2)\n galah        * 1.5.2   2023-03-20 [1] Github (AtlasOfLivingAustralia/galah@1b35520)\n geomtextpath * 0.1.1   2022-08-30 [1] CRAN (R 4.2.1)\n ggplot2      * 3.4.1   2023-02-10 [1] CRAN (R 4.2.2)\n htmltools    * 0.5.4   2022-12-07 [1] CRAN (R 4.2.2)\n sessioninfo  * 1.2.2   2021-12-06 [1] CRAN (R 4.2.1)\n viridis      * 0.6.2   2021-10-13 [1] CRAN (R 4.2.1)\n viridisLite  * 0.4.1   2022-08-22 [1] CRAN (R 4.2.1)\n\n [1] C:/Users/KEL329/R-packages\n [2] C:/Users/KEL329/AppData/Local/Programs/R/R-4.2.2/library\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "posts/2021-03-20_creating-a-color-palette-from-an-image/index.html",
    "href": "posts/2021-03-20_creating-a-color-palette-from-an-image/index.html",
    "title": "Creating a color palette from an image",
    "section": "",
    "text": "Author\nMartin Westgate\n\n\nDate\nMarch 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nColors in R\nColor palettes are important to people, and the R ecosystem includes literally hundreds of possible palettes. If you want a “complete” list, go and check out Emil Hvitfeldt’s list of palettes here; but in practice there are only a few that we use routinely. Our default at ALA labs is to use viridis for continuous scales, because (to quote their CRAN page) it’s color-blind friendly, perceptually uniform, and pretty. The default purple-green-yellow color scheme is lovely, but I’m a big fan of ‘magma’, which has a black-purple-orange-yellow scheme\n\nlibrary(galah)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(viridis)\n\n\n# Get field code for states/territories\nsearch_fields(\"state\") # layer: cl22 OR stateProvince\n\n# A tibble: 14 × 3\n   id                    description                                      type  \n   &lt;chr&gt;                 &lt;chr&gt;                                            &lt;chr&gt; \n 1 cl22                  Australian States and Territories                fields\n 2 cl927                 States including coastal waters                  fields\n 3 cl938                 Fruit Fly Exclusion Zone - Tri State             fields\n 4 cl2013                ASGS Australian States and Territories           fields\n 5 cl10900               Australia's Indigenous forest estate (2013) v2.0 fields\n 6 cl10922               PSMA State Electoral Boundaries (2018)           fields\n 7 cl10925               PSMA States (2016)                               fields\n 8 cl110922              PSMA State Electoral Boundary Classes (2018)     fields\n 9 cl110925              PSMA States - Abbreviated (2016)                 fields\n10 stateInvasive         &lt;NA&gt;                                             fields\n11 stateProvince         State/Territory                                  fields\n12 raw_stateProvince     State/Territory (unprocessed)                    fields\n13 stateConservation     State conservation                               fields\n14 raw_stateConservation State conservation (unprocessed)                 fields\n\n# Download record counts by state/territory\nrecords &lt;- galah_call() %&gt;%\n  galah_group_by(cl22) %&gt;%\n  atlas_counts()\n\n# Add state information back to data frame\nrecords$State &lt;- factor(seq_len(nrow(records)), labels = records$cl22) \n\n# Plot\nggplot(records, aes(x = State, y = log10(count), fill = count)) + \n  geom_bar(stat = \"identity\") +\n  coord_flip() +\n  scale_fill_viridis(option = \"magma\", begin = 0.10, end = 0.95) +\n  theme_bw() +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\nMy default for categorical color schemes is the ‘dark2’ palette from RColorBrewer; but given the subject matter of our work, it’s worth mentioning the wonderful feather package by Shandiya Balasubramaniam, which gives colors based on Australian bird plumage.\n\n# remotes::install_github(repo = \"shandiya/feathers\")\nlibrary(feathers)\n\nrcfd &lt;- galah_call() %&gt;%\n  galah_identify(\"Rose-crowned Fruit-Dove\") %&gt;%\n  galah_group_by(cl22) %&gt;%\n  atlas_counts()\n  \nrcfd$State &lt;- factor(seq_len(nrow(rcfd)), labels = rcfd$cl22) \n\nggplot(rcfd, aes(x = State, y = log10(count), fill = State)) + \n  geom_bar(stat = \"identity\") +\n  coord_flip() +\n  scale_fill_manual(values = get_pal(\"rose_crowned_fruit_dove\")) +\n  theme_bw() +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\nAll of this is fine, but what if you have a specific image that you want to take colors from? A logical choice is to pick the colors you want using an image editting program, but if we want to try something automated, there are options in R as well.\n\n\nExtracting colors\nNational Eucalypt Day aims to raise awareness about Eucalypts and celebrate their influence on the lives of Australians. In honour of National Eucalypt day, we wanted to created a plot based on occurrences data held in the Atlas of Living Australia, themed using colours from actual Eucalypts.\nWe used this image from a tweet by Dean Nicolle:\n\n\nHappy 'National Eucalypt Day'!The Western Australian gimlet (Eucalyptus salubris) has just been announced as Eucalypt of the Year for 2021. Renowned for its fluted, smooth, shiny, and colourful trunk & branches. pic.twitter.com/pOsufQtxWS— Dean Nicolle (@DeanNicolle1) March 22, 2021\n\n\n\n\n\n\nImage of Eucalyptus salubris by Dean Nicolle\n\n\nFirst, get observations of the Eucalypt of the Year 2021 from ALA using the galah package. Specifically, we use atlas_counts() to determine how many records of Eucalyptus salubris are held by the ALA:\n\nn_records &lt;- galah_call() %&gt;%\n  galah_identify(\"Eucalyptus salubris\") %&gt;%\n  atlas_counts()\n\nHere is what the data look like:\n\nn_records %&gt;% head()\n\n# A tibble: 1 × 1\n  count\n  &lt;int&gt;\n1   892\n\n\nThen get a color scheme from images of the species in question using the paletter package (which needs to be installed from GitHub) \n\n# remotes::install_github(\"AndreaCirilloAC/paletter\")\nlibrary(paletter)\n\nimage_pal &lt;- create_palette(\n  image_path = \"./data/Dean_Nicolle_Esalubris_image_small.jpeg\",\n  type_of_variable = \"categorical\",\n  number_of_colors = 15)\n\n\n\n\n\n\n\n\n\n\nNote that we downsized the image before running the paletter code, as large images take much longer to process.\n\n\nCreating a plot\nOnce we have this palette, the obvious question is what kind of plot to draw. We could have done a map, but those can be a bit boring. We decided to try something that represented the number of observations we had of this species at ALA, and included color, but was otherwise just a pretty picture that didn’t need to contain any further information. Rather than have a traditional x and y axis, therefore, we decided to try out the igraph package to plot the points in an interesting way.\nFirst, we create a vector containing as many points as we want to display, and distribute our colors among them as evenly as possible\n\n# create a vector to index colours\nrep_times &lt;- floor(n_records / length(image_pal))\n\ncolour_index &lt;- rep(seq_along(image_pal),\n  each = as.integer(rep_times))\n\nThen we can create a network using igraph, and use it to create a layout for our points\n\nlibrary(igraph)\n\ngraph_list &lt;- lapply(c(1:15), function(a){\n  lookup &lt;- which(colour_index == a)\n  return(\n    tibble(\n    from = lookup[c(1:(length(lookup)-1))],\n    to = lookup[c(2:length(lookup))])\n    )\n  })\ngraph_df &lt;- as_tibble(do.call(rbind, graph_list)) %&gt;%     # build matrix\n  tidyr::drop_na() %&gt;%\n  as.matrix(.)\ncolour_graph &lt;- graph_from_edgelist(graph_df)             # create network graph\n\n# convert to a set of point locations\ntest_layout &lt;- as.data.frame(layout_nicely(colour_graph)) # convert to df\ncolnames(test_layout) &lt;- c(\"x\", \"y\")                      # change colnames\ntest_layout$colour_index &lt;- factor(colour_index)          # add colour_index col\n\nFinally, we draw the plot with ggplot2, removing axes with theme_void()\n\nggplot(test_layout, aes(x = x, y = y, colour = colour_index)) +\n  geom_point(size = 3, alpha = 0.9) +\n  scale_color_manual(values = image_pal) +\n  coord_fixed() +\n  theme_void() +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\nThat’s it! While I like the effect here, I think the paletter package is best suited to cases where there are large areas of strongly contrasting colors; it’s less ideal for images with subtle color differences. It also doesn’t appear to have been updated lately, which may mean it’s not being supported any more. But I’m happy with this plot, and would definitely consider using it again.\n\n\nExpand for session info\n\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Australia.utf8\n ctype    English_Australia.utf8\n tz       Australia/Sydney\n date     2024-02-12\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version    date (UTC) lib source\n dplyr       * 1.1.4      2023-11-17 [1] CRAN (R 4.3.2)\n feathers    * 0.0.0.9000 2022-10-11 [1] Github (shandiya/feathers@4be766d)\n galah       * 2.0.1      2024-02-06 [1] CRAN (R 4.3.2)\n ggplot2     * 3.4.4      2023-10-12 [1] CRAN (R 4.3.1)\n htmltools   * 0.5.7      2023-11-03 [1] CRAN (R 4.3.2)\n igraph      * 1.5.1      2023-08-10 [1] CRAN (R 4.3.2)\n paletter    * 0.0.0.9000 2023-01-10 [1] Github (AndreaCirilloAC/paletter@c09605b)\n sessioninfo * 1.2.2      2021-12-06 [1] CRAN (R 4.3.2)\n viridis     * 0.6.4      2023-07-22 [1] CRAN (R 4.3.2)\n viridisLite * 0.4.2      2023-05-02 [1] CRAN (R 4.3.1)\n\n [1] C:/Users/KEL329/R-packages\n [2] C:/Users/KEL329/AppData/Local/Programs/R/R-4.3.2/library\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "about/index.html",
    "href": "about/index.html",
    "title": "About",
    "section": "",
    "text": "We are responsible for:\n\nData analysis & reporting on key projects\nR package development & maintenance\nOutreach & engagement with the research community\n\n\n\nMeet the team\nClick on photos to view their articles and contributions\n\n\n\n\n\n\n\n\n\n\nMartin Westgate\n\nTeam Leader\n\n\n\n\n\n\n\n\n\n\nShandiya Balasubramaniam\n\nData Analyst\n\n\n\n\n\n\n\n\n\n\nAmanda Buyan\n\nData Analyst\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDax Kellie\n\nData Analyst\n\n\n\n\n\n\n\n\n\n\nOlivia Torresan\n\nSupport Officer\n\n\n\n\n\n\n\n\n\n\nJuliet Seers\n\nTraining & Outreach Coordinator"
  },
  {
    "objectID": "about/Waite_Callum/index.html",
    "href": "about/Waite_Callum/index.html",
    "title": "Callum Waite",
    "section": "",
    "text": "Bio\n\n\n\n\n\n\n\n\n\n\n\n\n\nCallum is an ecological data analyst with a Masters in Quantitative Biology. He has a background in population ecology modelling and is passionate about effective and aesthetic data visualisation. As a data analyst with the ALA, he works on projects that support biosecurity and improve data visualisation using ALA data.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Posts\nCombining multiple species distributions on one map with hexagons and points Visualising multiple species distributions in a single figure can be difficult if there are areas where ranges overlap. In this post we introduce a way to show several species distributions in an area at once using a novel twist on the commonly used hexbin map."
  },
  {
    "objectID": "about/Seers_Juliet/index.html",
    "href": "about/Seers_Juliet/index.html",
    "title": "Juliet Seers",
    "section": "",
    "text": "Bio\n\n\n\n\n\n\n\n\n\n\n\n\n\nJuliet specialises in education and engagement in the environmental sector. Her work as the Training & Outreach Coordinator at the ALA involves identifying and addressing knowledge gaps users have with ALA’s use and functionality, and helping to elevate ALA’s profile with our stakeholders.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Posts"
  },
  {
    "objectID": "about/Buyan_Amanda/index.html",
    "href": "about/Buyan_Amanda/index.html",
    "title": "Amanda Buyan",
    "section": "",
    "text": "Bio\n\n\n\n\n\n\n\n\n\n\n\n\n\nAmanda is a data analyst for EcoCommons, and is based at the Atlas of Living Australia. She completed her PhD in Structural Biology, and uses her extensive Python skills to manage the integration of data within EcoCommons. She also works to optimize the available scientific workflows within the platform.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Posts\nAdd a buffer to a shapefile and account for obscured species locations Knowing what species have been observed in a local area is a regular task for ecosystem management. Here we show how to add a buffer to a shapefile using {shapely} and {geopandas}. We then demonstrate how data that have been obfuscated (obscured by reducing their precision) may affect the buffer size required to confidently capture threatened species in the area using {galah-python} and {matplotlib}.\nDownload a species list and cross-reference with conservation status lists in R Knowing what species have been observed in a local area is a regular task for ecosystem management. Here we show how to make a species list and how to cross-reference this list with threatened and sensitive species lists. We show how to do this task using 2 methods, with {galah} and using an external shapefile and species list. We then show how to visualise this information as a bar chart and a waffle chart using {ggplot2}.\nDownload a species list and cross-reference with conservation status lists Knowing what species have been observed in a local area is an important, regular task for ecosystem management and environmental impact assessment. Here we show how to make a species list with {galah-python} and how to cross-reference this list with threatened and sensitive species lists. We also show how to visualise this information as a waffle chart using {pywaffle} & {matplotlib}.\nBeginner’s guide to making a quick map of species occurrences in Python and R The ability to make a map quickly is an essential skill in ecology and conservation. This post shows how to make a quick, simple map of Peron’s tree frog occurrences & set a custom font using either Python or R.\nPlotting invasive species distributions with alpha shapes and choropleth maps in Python Invasive and introduced species can expand quickly into new habitats, altering ecosystems. In this post we use Python’s {galah}, {alphashape} and {GeoPandas} packages to visualise the growing distribution of Rhinella marina (cane toads) and the expanding range of Pittisporum undulatum in Australia."
  },
  {
    "objectID": "about/Balasubramaniam_Shandiya/index.html",
    "href": "about/Balasubramaniam_Shandiya/index.html",
    "title": "Shandiya Balasubramaniam",
    "section": "",
    "text": "Bio\n\n\n\n\n\n\n\n\n\n\n\n\n\nShandiya is an evolutionary ecologist with interests in conservation genetics and wildlife disease. She is the Decision Support Program Lead. Her work as a data analyst at the ALA focuses on streamlining reproducible pathways for researchers to access and analyse open data.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Posts\nAn introduction to species distribution modelling using {tidysdm} & {tidymodels} Species distribution modelling is a common task for ecologists in R. Here we show the fundamental steps to build, assess and use models to predict species distributions using {tidymodels} & {tidysdm}, modern packages that use tidy syntax to run and plot geospatial models.\nCombining multiple species distributions on one map with hexagons and points Visualising multiple species distributions in a single figure can be difficult if there are areas where ranges overlap. In this post we introduce a way to show several species distributions in an area at once using a novel twist on the commonly used hexbin map.\nAlternatives to box plots: Using beeswarm and raincloud plots to summarise ecological data Box plots are a common way to summarise data in ecology and biology research, but box plots have their weaknesses. Here we’ll show how easy it can be to make beeswarm and raincloud plots—two alternatives with greater data transparency—using plant trait data from {austraits}.\nMultiple colour scales in choropleth maps with {ggnewscale} Using multiple colour scales can be a great way to visually differentiate between geographic categories on a map. Here, we demonstrate this by creating a choropleth map to represent the density of plant records from the ALA across bioregions in Australia, and add multiple colour scales to differentiate marine and terrestrial records"
  },
  {
    "objectID": "about/Kellie_Dax/index.html",
    "href": "about/Kellie_Dax/index.html",
    "title": "Dax Kellie",
    "section": "",
    "text": "Bio\n\n\n\n\n\n\n\n\n\n\n\n\n\nDax is an evolutionary biologist, with a PhD in biological sciences and social psychology. As a data analyst and science lead at the ALA, he tries to make data in the ALA accessible for scientists to use in ways that are robust and transparent.  Dax is the primary editor of ALA Labs.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Posts\nAdd a buffer to a shapefile and account for obscured species locations Knowing what species have been observed in a local area is a regular task for ecosystem management. Here we show how to add a buffer to a shapefile using {shapely} and {geopandas}. We then demonstrate how data that have been obfuscated (obscured by reducing their precision) may affect the buffer size required to confidently capture threatened species in the area using {galah-python} and {matplotlib}.\nDownload a species list and cross-reference with conservation status lists in R Knowing what species have been observed in a local area is a regular task for ecosystem management. Here we show how to make a species list and how to cross-reference this list with threatened and sensitive species lists. We show how to do this task using 2 methods, with {galah} and using an external shapefile and species list. We then show how to visualise this information as a bar chart and a waffle chart using {ggplot2}.\nModelling the impact of fire on the Southern Greater Glider Major fire events impact flora and fauna, particularly in areas where fire can dramatically reshape the livable habitat area. Here we investigate how greater gliders, a tree-dwelling marsupial species, were impacted by the 2019-2020 bushfires using {tidymodels} and {tidysdm}.\nShow seasonal species trends using a ridgeline plot Displaying ecological trends of many species or groups at once can sometimes appear messy or crowded. In this post we show how ridgeline plots are a useful way to show trends in seasonality by displaying observations of migratory bird species over the year using {ggridges}.\nAn introduction to species distribution modelling using {tidysdm} & {tidymodels} Species distribution modelling is a common task for ecologists in R. Here we show the fundamental steps to build, assess and use models to predict species distributions using {tidymodels} & {tidysdm}, modern packages that use tidy syntax to run and plot geospatial models.\nDownload a species list and cross-reference with conservation status lists Knowing what species have been observed in a local area is an important, regular task for ecosystem management and environmental impact assessment. Here we show how to make a species list with {galah-python} and how to cross-reference this list with threatened and sensitive species lists. We also show how to visualise this information as a waffle chart using {pywaffle} & {matplotlib}.\nBeginner’s guide to making a quick map of species occurrences in Python and R The ability to make a map quickly is an essential skill in ecology and conservation. This post shows how to make a quick, simple map of Peron’s tree frog occurrences & set a custom font using either Python or R.\nAlternatives to box plots: Using beeswarm and raincloud plots to summarise ecological data Box plots are a common way to summarise data in ecology and biology research, but box plots have their weaknesses. Here we’ll show how easy it can be to make beeswarm and raincloud plots—two alternatives with greater data transparency—using plant trait data from {austraits}.\nPlotting invasive species distributions with alpha shapes and choropleth maps in Python Invasive and introduced species can expand quickly into new habitats, altering ecosystems. In this post we use Python’s {galah}, {alphashape} and {GeoPandas} packages to visualise the growing distribution of Rhinella marina (cane toads) and the expanding range of Pittisporum undulatum in Australia.\nMake a highlighted time-series plot Time-series analyses can be handy for seeing trends over time, and exploring how trends relate to major events. Here, we show how to create an exploratory time-series plot comparing observations of waterbirds prior to and during the COVID-19 pandemic.\nAnimated species distribution maps with {gifski} One useful way to see changes in a species’ habitat range over time is by using animation to view multiple distributions in succession. Here we will model the distribution of Nudibranchia across Australia each month to create an animated GIF of its distribution over a year.\nCounting points in multipolygon shapefiles for choropleth mapping Choropleth maps are an excellent way to visualise numbers of observations in each region. When using point data, calculating the number of points in each polygon can be difficult when using shapefiles. Here we demonstrate how to extract and summarise the number of points in each polygon within a shapefile to create a choropleth map.\nQuantify geographic sampling bias with {sampbias} Human biases play a large role in the data we collect about species. Here we show a simple method to quantify the bias of roads, cities, rivers and airports on species observations of legless lizards in the Northern Territory\nDownload plant species data by hexagon to make a 3D hex map Making plots eye-catching can be useful for science communication. Here, we show how to make 3D plots in R with the rayshader package by visualising the number of species identified from ALA observations since 2020"
  },
  {
    "objectID": "about/Torresan_Olivia/index.html",
    "href": "about/Torresan_Olivia/index.html",
    "title": "Olivia Torresan",
    "section": "",
    "text": "Bio\n\n\n\n\n\n\n\n\n\n\n\n\n\nOlivia is a graduate from the Australian National University (ANU), acquiring an interdisciplinary double degree in philosophy and natural resource management. At the ALA, she works as a support officer with a primary focus on monitoring the research impact of the Atlas. She is passionate about accessibility, environmental justice and diversity in STEMM.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Posts\nCounting points in multipolygon shapefiles for choropleth mapping Choropleth maps are an excellent way to visualise numbers of observations in each region. When using point data, calculating the number of points in each polygon can be difficult when using shapefiles. Here we demonstrate how to extract and summarise the number of points in each polygon within a shapefile to create a choropleth map."
  },
  {
    "objectID": "about/Westgate_Martin/index.html",
    "href": "about/Westgate_Martin/index.html",
    "title": "Martin Westgate",
    "section": "",
    "text": "Bio\n\n\n\n\n\n\n\n\n\n\n\n\n\nMartin leads the Science & Decision Support Team. He holds a doctorate in landscape ecology and conservation biology from the Australian National University. His work focuses on conceptual, computational and statistical tools to better understand patterns in nature.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Posts\nHex maps for species occurrence data Hex maps are a neat way to represent spatial information. Here, we show how to draw one using the most common species in the ALA database: the iconic Australian Magpie.\nSunburst plots for taxonomic data Since version 1.3.1 of galah, it has been possible to download taxonomic data using a ‘tree’ format from the data.tree package. Here I’ll demonstrate some ideas for plotting these trees using circular diagrams.\nCreating a color palette from an image There are hundreds of color palettes in the R ecosystem, but sometimes we might want to use colors from a specific image. Here I show how to use the paletter package to create a color palette for the 2020 Eucalypt of the Year: the Western Australian Gimlet."
  },
  {
    "objectID": "books/index.html",
    "href": "books/index.html",
    "title": "Books",
    "section": "",
    "text": "Cleaning Biodiversity Data in R\nData cleaning is a process that anyone who works with data must engage with if they want use their data to answer questions about the world and the environment. Cleaning Biodiversity Data in R is a practical guide on cleaning geo-referenced biodiversity data using R. It is a targeted resource for anyone working with or interested in answering questions using data in ecology and evolution."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to ALA Labs",
    "section": "",
    "text": "This site is a resource for coding projects that use data sourced from the ALA. We hope that users will find interesting content, whether their focus is ecological modelling, data visualisation, or simply investigating the natural world through a digital lens. Enjoy!\n\n\n\n\n\n\n\n  \n\n\n\n\n\nALA  Lens\n\n\nDive into data using a new interactive interface for exploring ALA data. Try out new views of the ALA, designed to encourage exploration and discovery of species, data and place.\nDesigned by Mitchell Whitelaw and Adrian Mackenzie of the Australian National University (ANU)\nImages (all CC-BY-NC): Kai Squires, andrewpavlov, mikegrow, kerrbrad, Matt Campbell, Toby Esplin, darcywhittaker\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPosts\n\nHow-to articles for solving scientific problems\n\n\n\n\n\n\n\n\n\nSummaries\n\n\n\n\n\n\n\nMaps\n\n\n\n\n\n\n\nTrees\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\nResearch\n\nHighlighting research supported by ALA data\n\n\n\n\n\n\n\n\n\nSelected\nhighlights\n\n\n\n\n\n\n\nComplete list\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSoftware\n\nTools supported by the Science & Decision Support Team\n\n\n\n\n\n\n\n\n\nPackages\n\n\n\n\n\n\n\n\n\n\n\n\n\nBooks\n\nLong-form resources by the Science & Decision Support Team\n\n\n\n\n\n\n\n\n\nBooks\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n We value\n\n\n\n\n\n\n\n\n\n\n\n    Openness\n\nData are most useful when they are widely available and easy to use. We try to encourage the sharing of tools that make data from the Atlas of Living Australia more open and useful for everyone\n\n\n\n\n\n\n    Scientific transparency\n\nTransparency is necessary for reproducible science. We encourage that decisions, methods and deviations are clear and transparent in a workflow from the planning phase, to the retrieval and analysis of data, to the final output\n\n\n\n\n\n\n    Robust methods\n\nNo method or analytic procedure is perfect. We value consideration for strengths and limitations of each method or analysis. This attitude helps researchers choose methods that provide robust results for their specific question"
  },
  {
    "objectID": "posts/2021-04-14_hex-maps-for-species-occurrence-data/index.html",
    "href": "posts/2021-04-14_hex-maps-for-species-occurrence-data/index.html",
    "title": "Hex maps for species occurrence data",
    "section": "",
    "text": "Author\nMatilda Stevenson\nDax Kellie\nMartin Westgate\n\n\nDate\nMarch 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nArticle updated 6 February, 2023. Updates streamline code, and provide more examples of output after each step. More in-text detail has also been added about what is happening at each step.\n\n\nThe Atlas of Living Australia (ALA) holds records of magpie sightings from a number data providers like iNaturalist, eBird and BirdLife Australia. Let’s make a visualisation of Australian Bird of the Year 2018 winner, Magpies, using records held in the ALA.\n\nGetting species occurrences\nAs with any R project, a good first step is to load the required packages.\n\n# packages\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(ozmaps)\nlibrary(sf)\nlibrary(hexbin)\n\nWe will use the {galah} package to download records.\nTo download species occurrence records, the {galah} package requires you to add an email registered with the ALA to galah_config(). If running this code yourself, you will need to add an email using the code below, substituting your email with myemail@email.com. This email address should be registered with the ALA, which you can do here\n\nlibrary(galah)\ngalah_config(email = \"myemail@email.com\")\n\nNow we can download magpie occurrence records by using atlas_occurrences(). Note that we also set our data ‘profile’ to ‘ALA’; this means we only download records that meet some basic data quality standards enforced by the atlas. This is optional, but tends to improve the quality of the data returned. (If you wish to see the data quality filters applied in the ALA profile, use search_all(profiles, \"ALA\") |&gt; show_values())\n\nmagpie_occ &lt;- galah_call() %&gt;%\n  galah_identify(\"Cracticus tibicen\") %&gt;%\n  galah_apply_profile(ALA) %&gt;%\n  atlas_occurrences()\n\nRetrying in 1 seconds.\nRetrying in 2 seconds.\nRetrying in 4 seconds.\nRetrying in 8 seconds.\nRetrying in 16 seconds.\nRetrying in 32 seconds.\nRetrying in 60 seconds.\n\n\nLet’s have a look at the first few rows of the data we’ve just downloaded:\n\nmagpie_occ %&gt;% head()\n\n# A tibble: 6 × 8\n  recordID        scientificName taxonConceptID decimalLatitude decimalLongitude\n  &lt;chr&gt;           &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n1 0000032b-8690-… Gymnorhina ti… https://biodi…           -37.0             145.\n2 0000150d-489d-… Gymnorhina ti… https://biodi…           -37.9             145.\n3 00001736-1fd8-… Gymnorhina ti… https://biodi…           -34.8             151.\n4 00001e12-29cf-… Gymnorhina ti… https://biodi…           -39.6             144.\n5 00001f60-0371-… Gymnorhina ti… https://biodi…           -35.2             149.\n6 000035cd-c3a1-… Gymnorhina ti… https://biodi…           -37.6             144.\n# ℹ 3 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;\n\n\nFor the purpose of this exercise, we’re going to filter records not on the mainland or Tasmania.\n\nfiltered_occ &lt;- magpie_occ %&gt;% filter(decimalLongitude &lt; 155,\n                                      decimalLongitude &gt; 110,\n                                      decimalLatitude &gt; -45,\n                                      decimalLatitude &lt; -10)\n\n\n\nPlotting binned data\nThe easiest way to create a hex map is using the hexbin package. However, because there are some areas that have many more observations than other areas, without standardising our data the result is not very useful.\n\nggplot() +\n  geom_hex(data = filtered_occ,\n           mapping = aes(x = decimalLongitude, \n                         y = decimalLatitude), \n           bins = 47, \n           colour = \"white\") +\n  coord_sf(ylim = c(-45, -10), \n           xlim = c(110, 155)) +\n  scale_fill_gradientn(colours = c(\"#EEECEA\", \"#E06E53\")) +\n  theme_void()\n\n\n\n\n\n\n\n\nTo make a more informative hex map, in this case it might be useful to try to create our hexagons manually. We can do this by creating a grid of hexagons, filtering the grid to the outline of Australia, and adding our data of magpie counts to set the fill color of those hexagons.\nTo achieve this, we can first convert the map of Australia provided by ozmaps to the same coordinate system as ALA data.\n\naus &lt;- st_transform(ozmaps::ozmap_country, 4326)\n\nNext we’ll create a grid of hexagons.\n\ngrid_all &lt;- st_make_grid(aus, \n                         cellsize = 1, \n                         what = \"polygons\", \n                         square = FALSE,\n                         flat_topped = TRUE)\n\nggplot() +\n  geom_sf(data = grid_all)\n\n\n\n\n\n\n\n\nNow we’ll extract all the hexagons in our full grid that intersect our map of Australia, and filter our grid to only include those hexagons by only keeping the hexagon rows that are returned after running st_intersects().\n\n# extract rows that are within AUS land\nkeep_hexes &lt;- st_intersects(grid_all, aus) %&gt;%\n  as.data.frame(.) %&gt;%\n  pull(row.id)\n\n# filter full grid to only hexagon IDs in AUS\noz_grid &lt;- grid_all[keep_hexes]\n\nggplot() + geom_sf(data = oz_grid)\n\n\n\n\n\n\n\n\nNow to figure out how many magpie observations are within each hexagon. To do this, first we’ll convert our magpie observation points to an sf spatial object and make sure the point projection is the same as our map of Australia. Then we can use st_intersects() again to return a list, where each data.frame within the list shows which hexagon ID each point is within.\n\nmagpie_points_sf &lt;- filtered_occ %&gt;% \n  st_as_sf(coords = c(\"decimalLongitude\", \"decimalLatitude\"), \n  crs = st_crs(4326))\n\n\nintersect &lt;- st_intersects(magpie_points_sf, oz_grid)\n\nintersect[5:10]\n\n[[1]]\n[1] 69\n\n[[2]]\n[1] 43\n\n[[3]]\n[1] 414\n\n[[4]]\n[1] 31\n\n[[5]]\n[1] 185\n\n[[6]]\n[1] 67\n\n\nWith all points in their own separate data.frame, we can use the wicked-fast table() function from base R to count how many points match each hexagon ID, giving us our point counts! A little renaming and wrangling helps to get our counts in the right format.\n\n# condense counts into tibble\ncounts &lt;- as_tibble(table(unlist(intersect)), \n          .name_repair = \"unique\") %&gt;%\n  rename(\"hex_id\" = 1,\n         \"count\" = 2) %&gt;%\n  mutate(hex_id = as.integer(hex_id)) %&gt;%\n  replace_na(list(count = 0))\n\nWe’ll add our count column from complete_counts to our oz_grid, along with an id column containing the row number. This column will act as a reference column to join with complete_counts. Then we’ll also make sure that oz_grid is an sf object for plotting.\n\noz_grid &lt;- oz_grid %&gt;%\n  as_tibble() %&gt;%\n  mutate(id = row_number()) %&gt;%\n  full_join(counts,\n            by = join_by(id == hex_id)) %&gt;%\n  st_as_sf()\n\noz_grid |&gt; head()\n\nSimple feature collection with 6 features and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 144.8105 ymin: -44.13203 xmax: 148.5632 ymax: -41.63203\nGeodetic CRS:  WGS 84\n# A tibble: 6 × 3\n                                                            geometry    id count\n                                                       &lt;POLYGON [°]&gt; &lt;int&gt; &lt;int&gt;\n1 ((146.5425 -43.63203, 146.8312 -44.13203, 147.4085 -44.13203, 147…     1   591\n2 ((145.6765 -43.13203, 145.9652 -43.63203, 146.5425 -43.63203, 146…     2     9\n3 ((147.4085 -43.13203, 147.6972 -43.63203, 148.2746 -43.63203, 148…     3  1602\n4 ((144.8105 -42.63203, 145.0991 -43.13203, 145.6765 -43.13203, 145…     4     6\n5 ((146.5425 -42.63203, 146.8312 -43.13203, 147.4085 -43.13203, 147…     5  9692\n6 ((145.6765 -42.13203, 145.9652 -42.63203, 146.5425 -42.63203, 146…     6    71\n\n\nFinally, let’s build our map! We’ll use scale_fill_gradientn() to add a nice legend, and standardise our data using a log-transformation so that the colours on our map are scaled to be more informative.\n\nggplot() +\n  geom_sf(data = oz_grid, aes(fill = count), size = .01) +\n  scale_fill_gradientn(colours = c(\"#EEECEA\", \"#E06E53\"), \n                       na.value = \"white\", \n                       trans = \"log10\",\n                       labels = scales::comma_format(),\n                       n.breaks = 6,\n                       guide = guide_colourbar(title = \"Observations\")) +\n  coord_sf(ylim = c(-45, -10), \n           xlim = c(110, 155)) +\n  theme_void()\n\n\n\n\n\n\n\n\nThat’s it! All the extra work does make a difference in this case, providing a better representation of the spread of Mapgies across Australia. Manually constructing hex maps can be useful in other circumstances, too. For example, if we wanted to compare the number of magpies to contextual information within each polygon (such as rainfall or human population data), then manually constructing our own hexagons could help us to combine data from different sources.\nA final point is that we could have achieved the same result by creating polygons first, then querying the ALA for the number of magpie records in each polygon using galah_geolocate(). That’s a bit more challenging, and not worthwhile in this case; but it can be an efficient solution where you require information on more species than there are polygons, for example. You can learn how to do this in this ALA Labs article, if you are interested to learn how!\n\n\nExpand for session info\n\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Australia.utf8\n ctype    English_Australia.utf8\n tz       Australia/Sydney\n date     2024-02-12\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n dplyr       * 1.1.4   2023-11-17 [1] CRAN (R 4.3.2)\n galah       * 2.0.1   2024-02-06 [1] CRAN (R 4.3.2)\n ggplot2     * 3.4.4   2023-10-12 [1] CRAN (R 4.3.1)\n hexbin      * 1.28.3  2023-03-21 [1] CRAN (R 4.3.2)\n htmltools   * 0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n ozmaps      * 0.4.5   2021-08-03 [1] CRAN (R 4.3.2)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n sf          * 1.0-14  2023-07-11 [1] CRAN (R 4.3.2)\n tidyr       * 1.3.0   2023-01-24 [1] CRAN (R 4.3.2)\n\n [1] C:/Users/KEL329/R-packages\n [2] C:/Users/KEL329/AppData/Local/Programs/R/R-4.3.2/library\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "posts/2022-05-17_3d-map/index.html",
    "href": "posts/2022-05-17_3d-map/index.html",
    "title": "Download plant species data by hexagon to make a 3D hex map",
    "section": "",
    "text": "Grabbing people’s attention in a content-filled world can be difficult. 3D maps can be particularly eye-catching, and thanks to the rayshader package it has become relatively simple to make a beautiful 3D plot with the help of {ggplot2}.\nIn this post, we’ll make a 3D hex map of the number of plant species identified from ALA observations since 2020. This map builds on a previous hex map post, but this time we will use a more unique “grid-to-data” method to download our data, where instead of plotting hexagons over our map after extracting data, we’ll create a grid of hexagons that map to Australia before extracting any data and query the ALA for data for each hexagon. This method is cool because it saves a lot of work wrangling your data to fit your plot later on."
  },
  {
    "objectID": "posts/2022-05-17_3d-map/index.html#footnotes",
    "href": "posts/2022-05-17_3d-map/index.html#footnotes",
    "title": "Download plant species data by hexagon to make a 3D hex map",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nIf you get a weird error related to the scales package, updating to the latest version should fix it: https://github.com/tylermorganwall/rayshader/issues/181#:~:text=Update%20to%20the,install.packages(%27rayshader%27) ↩︎"
  },
  {
    "objectID": "posts/2022-07-22_sample-bias/index.html",
    "href": "posts/2022-07-22_sample-bias/index.html",
    "title": "Quantify geographic sampling bias with {sampbias}",
    "section": "",
    "text": "Being human plays a big role in the species we observe, when we observe them and where we observe them. In particular, we tend to collect more data in areas that are closer to places we live (or have access to) because there are more opportunities to see species in areas we spend more time in than areas that are far away or inaccessible.\nLarge, public datasets like the Atlas of Living Australia are especially prone to this sampling bias because they largely reflect opportunistic observations rather than systematic monitoring programs. However, not all species observations are affected equally by these biases, and it’s useful to quantify how biased data are before interpreting them.\nThanks to the sampbias package, we can easily quantify and compare the effects of these biases on our data, specifically whether data are influenced by cities, roads, airports and rivers.\nThis post expands on a Twitter thread by Dr Ian Brennan to show how sampling bias affects museum records of reptiles. Dr Brennan is currently a Post Doctoral researcher at the Australian National University (ANU). Check out his website to learn more about him and his cool research."
  },
  {
    "objectID": "posts/2022-07-22_sample-bias/index.html#quolls",
    "href": "posts/2022-07-22_sample-bias/index.html#quolls",
    "title": "Quantify geographic sampling bias with {sampbias}",
    "section": "Quolls",
    "text": "Quolls\n\nQuolls & Mulgaras\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLeft: Dasyurus hallucatus (David White CC BY-NC 4.0), Right: Dasycercus blythi (Robert Browne-Cooper CC-BY-NC 3.0 (Au))"
  },
  {
    "objectID": "posts/2022-07-22_sample-bias/index.html#little-kingfisher",
    "href": "posts/2022-07-22_sample-bias/index.html#little-kingfisher",
    "title": "Quantify geographic sampling bias with {sampbias}",
    "section": "Little Kingfisher",
    "text": "Little Kingfisher\n\nLittle Kingfisher\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLeft: Ceyx pusillus (Greg Holland CC BY-NC 4.0), Right: Ceyx pusillus (Graham Winterflood CC-BY-SA 4.0 (Au))"
  },
  {
    "objectID": "posts/2022-07-22_sample-bias/index.html#mantids",
    "href": "posts/2022-07-22_sample-bias/index.html#mantids",
    "title": "Quantify geographic sampling bias with {sampbias}",
    "section": "Mantids",
    "text": "Mantids\n\nMantids\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLeft: Hierodula majuscula (Michael Mcmaster CC BY-NC 4.0), Right: Tenodera australasiae (Reiner Richter CC BY-NC-SA 4.0))"
  },
  {
    "objectID": "posts/2022-07-22_sample-bias/index.html#green-birdflower",
    "href": "posts/2022-07-22_sample-bias/index.html#green-birdflower",
    "title": "Quantify geographic sampling bias with {sampbias}",
    "section": "Green birdflower",
    "text": "Green birdflower\n\nGreen birdflower\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLeft: Crotalaria cunninghamii (Gerald Krygsman CC BY-NC 4.0), Right: Crotalaria cunninghamii (Steve Dew CC BY-NC 4.0))"
  },
  {
    "objectID": "posts/2022-07-22_sample-bias/index.html#footnotes",
    "href": "posts/2022-07-22_sample-bias/index.html#footnotes",
    "title": "Quantify geographic sampling bias with {sampbias}",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nfor biases↩︎\nfrom over-interpreting your data↩︎"
  },
  {
    "objectID": "posts/2023-01-12_counting-points-in-shapefiles/index.html",
    "href": "posts/2023-01-12_counting-points-in-shapefiles/index.html",
    "title": "Counting points in multipolygon shapefiles for choropleth mapping",
    "section": "",
    "text": "Choropleth maps are an excellent way to visualise differences in variables (eg. number of species observed) across several geographic regions (eg. countries, states, study areas). Often, creating a choropleth map from species observations requires two things:\nHowever, to create a choropleth map of species observations requires us to summarise our points to a single statistic for each polygon of our shapefile. This conversion from points to polygons can sometimes be tricky!\nHere, we show you how to extract and count the number of points inside each polygon of a shapefile to create a choropleth map of the number of species observations per km2 in each suburb of the Australian Capital Territory (ACT)."
  },
  {
    "objectID": "posts/2023-01-12_counting-points-in-shapefiles/index.html#download-data",
    "href": "posts/2023-01-12_counting-points-in-shapefiles/index.html#download-data",
    "title": "Counting points in multipolygon shapefiles for choropleth mapping",
    "section": "Download data",
    "text": "Download data\nFirst we will load the R packages that we need:\n\nlibrary(galah)\nlibrary(here) \nlibrary(rmapshaper) \nlibrary(tidyverse) \nlibrary(sf)\nlibrary(ggtext)\n\n\nDownload shapefile\nNext we will need a shapefile. You can find many shapefiles online from reputable sources. For this example, I’ve downloaded a shapefile of suburb boundaries in the city of Canberra, ACT from the ACT’s open-access map database.\nUsually when you download a shapefile, it is compressed within a zip folder. Save this downloaded zip folder in a local folder inside your current R project. If you need to unzip your folder, you can do so with the following code:\n\nzip_folder &lt;- here(\"folder-name\", \"shapefile-folder-name.zip\")\noutput_dir &lt;- \"folder-name-to-save-unzipped-files\" \nunzip(zip_folder, exdir = output_dir) \n\nNow we load this unzipped shapefile into R. To save space, we’ll remove some complexity from our shapefile polygons with ms_simplify() from the {rmapshaper} package.\nThe actsuburbs shapefile contains both suburb boundaries and “district” boundaries, which can encompass several suburbs. To avoid confusion, we will remove districts using filter(LOC_CLASS != \"District\"). We’ll also use st_make_valid() to make sure any weird invalid geometries in our shapefile are made valid, and therefore plot correctly.\n\nactsuburbs &lt;- st_read(here(\"folder-name\",\n                           \"folder-name-2\",\n                           \"shapefilename.shp\")) |&gt;\n                     ms_simplify(keep = 0.1) |&gt; \n  st_transform(crs = st_crs(\"WGS84\")) |&gt; \n  st_make_valid() |&gt; \n  filter(LOC_CLASS != \"District\")\n\nNow to see if our shapefile plots correctly, we can use geom_sf() (and it looks like it does!)\n\nggplot() +\n  geom_sf(data = actsuburbs) +\n  theme(axis.text.x = element_text(angle = -90, hjust = 0))\n\n\n\n\n\n\n\n\n\n\nDownload species observations\nNext let’s use the {galah} package to download bird occurrence records from the Atlas of Living Australia (ALA).\nWe can download all Aves (bird) data provided by BirdLife Australia within the ACT by using galah_filter() to narrow our download. We’ll also add ALA’s data profile, or what the ALA calls a set of data quality filters to remove suspicious records, using galah_apply_profile(ALA).\nYou will need to provide a registered email with the ALA using galah_config() before retrieving records.\n\ngalah_config(email = \"your-email@email.com\") \n\n\nbirdocc &lt;- galah_call() |&gt; \n  galah_identify(\"Aves\") |&gt; \n  galah_apply_profile(ALA) |&gt;\n  galah_filter(stateProvince == \"Australian Capital Territory\",\n               dataProviderName == \"BirdLife Australia\") |&gt;  \natlas_occurrences()\n\nRetrying in 1 seconds.\nRetrying in 2 seconds.\nRetrying in 4 seconds.\nRetrying in 8 seconds.\n\nbirdocc |&gt; head(8L)\n\n# A tibble: 8 × 8\n  recordID        scientificName taxonConceptID decimalLatitude decimalLongitude\n  &lt;chr&gt;           &lt;chr&gt;          &lt;chr&gt;                    &lt;dbl&gt;            &lt;dbl&gt;\n1 0001983b-e50e-… Rhipidura (Rh… https://biodi…           -35.3             149.\n2 0001cc23-26e4-… Tachybaptus n… https://biodi…           -35.2             149.\n3 0001d4d1-761e-… Malurus (Malu… https://biodi…           -35.2             149.\n4 0001e1d0-ce75-… Philemon (Tro… https://biodi…           -35.2             149.\n5 0001e509-54d7-… Turdus merula  https://biodi…           -35.2             149.\n6 00026573-8ea6-… Strepera (Str… https://biodi…           -35.2             149.\n7 0002d2ef-54b8-… Platycercus (… https://biodi…           -35.2             149.\n8 000301c9-b3b1-… Cacatua (Caca… https://biodi…           -35.2             149.\n# ℹ 3 more variables: eventDate &lt;dttm&gt;, occurrenceStatus &lt;chr&gt;,\n#   dataResourceName &lt;chr&gt;\n\n\n\nFor those unfamiliar with Australian geography, the ACT is located here:"
  },
  {
    "objectID": "posts/2023-01-12_counting-points-in-shapefiles/index.html#count-points-in-each-polygon",
    "href": "posts/2023-01-12_counting-points-in-shapefiles/index.html#count-points-in-each-polygon",
    "title": "Counting points in multipolygon shapefiles for choropleth mapping",
    "section": "Count points in each polygon",
    "text": "Count points in each polygon\nTo prepare our data, we’ll convert each observation into a format suitable for spatial mapping. st_as_sf() transforms each point into an sf spatial object (which plots nicely with {ggplot2}). We’ll also make sure the points are projected to crs = set_crs(\"WGS84\"), the same as our shapefile, so that the points line up correctly.\n\nbird_points_sf &lt;- birdocc |&gt; \n  st_as_sf(coords = c(\"decimalLongitude\", \"decimalLatitude\"), \n  crs = st_crs(\"WGS84\"))\n\nNow we’ll find and count how many points are in each of our suburbs.\nThe st_intersects() function checks whether each point is within, or “intersects”, a specified POLYGON and then marks it as TRUE or FALSE in a matrix. Using st_intersects() in a loop with pmap() allows us to run st_intersects() on each row of a supplied list.\nIn our case, because each row of actsuburbs$geometry corresponds to each suburb, pmap_dbl() recursively checks which points are within each of our ACT suburbs! Adding lengths() around st_intersects() will count the number of rows returned for each suburb list, returning the total number of points that intersect each suburb. 1. We’ve saved this count in a new column bird_count.\n\n\n\n\n\n\nWarning\n\n\n\nThis function takes ~3.5 minutes to run\n\n\n\nact_counts &lt;- actsuburbs |&gt; \n  mutate(bird_count = pmap_dbl(.l = list(x = actsuburbs$geometry),\n                           .f = function(x) {\n                             lengths(st_intersects(x, bird_points_sf))\n                             }))\n\nact_counts |&gt; \n  select(LOC_NAME, bird_count) |&gt; \n  head(8L) # see sample of counts\n\nSimple feature collection with 8 features and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 149.0563 ymin: -35.48032 xmax: 149.2188 ymax: -35.15856\nGeodetic CRS:  WGS 84\n   LOC_NAME bird_count                       geometry\n1     Acton        693 POLYGON ((149.1269 -35.2929...\n2   Ainslie        121 POLYGON ((149.1555 -35.2504...\n3    Amaroo         50 POLYGON ((149.1152 -35.1677...\n4    Aranda         36 POLYGON ((149.0895 -35.2568...\n5     Banks          0 POLYGON ((149.0908 -35.4751...\n6    Barton        667 POLYGON ((149.1291 -35.3063...\n7     Beard          0 POLYGON ((149.2188 -35.3413...\n8 Belconnen       1518 POLYGON ((149.0804 -35.2309...\n\n\nShowing the total number of bird observations on a choropleth map can be misleading because areas that are larger might have more records simply because they are large areas! It’s a good idea to standardise your data to avoid this bias. In this case, we will show the number of observations per square kilometer.\nTo do this, we will use sf::st_area() to help us get the area per m2 of our suburbs & convert it to km2 by dividing by 1000, saving this in a new column area_km2. Then we’ll divide our bird_count by area_km2.\n\nact_counts &lt;- act_counts |&gt;\n  rowwise() |&gt; \n  mutate(area_km2 = as.integer(st_area(geometry))/1000,\n         counts_km2 = bird_count/area_km2) |&gt;\n  replace_na(list(counts_km2 = 0))\n\nact_counts |&gt; rmarkdown::paged_table() # final data frame\n\n\n  \n\n\n\nIt’s a good idea to check the distribution of our data before we plot so we know what we should expect it to look like. If we check our bird counts, we can notice that our count data is skewed because many regions have lower numbers of observations, and only a few regions have very high numbers of observations.\n\nhist(act_counts$bird_count, main = \"bird_count distribution\")\n\n\n\n\n\n\n\n\nLog transformation will reduce the skew in our data, ultimately making our final choropleth map easier to interpret. We will handle this when we make our ggplot in the final step!"
  },
  {
    "objectID": "posts/2023-01-12_counting-points-in-shapefiles/index.html#footnotes",
    "href": "posts/2023-01-12_counting-points-in-shapefiles/index.html#footnotes",
    "title": "Counting points in multipolygon shapefiles for choropleth mapping",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nMany thanks to Shandiya Balasubramaniam for suggesting this method, and for many other very helpful edits!↩︎"
  },
  {
    "objectID": "posts/2023-04-03_highlighted-time-series/index.html",
    "href": "posts/2023-04-03_highlighted-time-series/index.html",
    "title": "Make a highlighted time-series plot",
    "section": "",
    "text": "Author\nThai Rushbrook\nOlivia Torresan\nDax Kellie\n\n\nDate\n3 April 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntern Post\n\n\n\n\n\n\nA majority of species observations in the Atlas of Living Australia are collected opportunistically, where people record observations incidentally rather than through an ongoing monitoring program.\nHowever, whether an observation is recorded or not doesn’t just depend on the species. It might be rainy, it might be too hot, an area might be inaccessible; all of these factors can affect whether people make an observation.\nThe COVID-19 pandemic had a major impact on people’s health, behaviour and travel. In Australia, several lockdowns over 2020-2021 imposed restrictions on people’s movements, limiting them to certain activities near their homes. Melbourne experienced the longest continuous lockdown in the world.\nTo what extent did COVID-19 and lockdowns affect the number of species observations people made over that time? Here, we’ll use a highlighted time-series plot to investigate how lockdowns in Melbourne affected the observations of Anatidae (ducks, geese and swans), a taxonomic group frequently seen on walks and outdoor gatherings, compared to previous years.\n\nGet data\nWe’ll start by downloading Anatidae records.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLeft: Tadorna (Casarca) tadornoides (Tracey Hinton CC-BY-NC 4.0 (Int)) Middle: Cygnus (Chenopis) atratus (jpshahady CC-BY-NC 4.0 (Int)) Right: Spatula rhynchotis (Annette Green CC-BY-NC 4.0 (Int))\n\nFirst, let’s load some packages:\n\n# Load packages\nlibrary(galah)\nlibrary(tidyverse)\nlibrary(grid)\nlibrary(pilot) # remotes::install_github(\"olihawkins/pilot\")\nlibrary(ggtext)\nlibrary(showtext)\n\nLet’s use the {galah} package to download Anatidae records in Melbourne from years before and during COVID-19.\nSearching with search_all(fields) shows us that {galah} contains Greater Capital City Statistical Areas, which we can use to filter our query.\n\nsearch_all(fields, \"city\")\n\n# A tibble: 1 × 3\n  id      description                                            type  \n  &lt;chr&gt;   &lt;chr&gt;                                                  &lt;chr&gt; \n1 cl10929 PSMA ABS Greater Capital City Statistical Areas (2016) fields\n\nsearch_all(fields, \"city\") |&gt; search_values(\"melbourne\")\n\n• Showing values for 'cl10929'.\n\n\n# A tibble: 1 × 1\n  cl10929          \n  &lt;chr&gt;            \n1 GREATER MELBOURNE\n\n\nLet’s build our query to return Anatidae records from GREATER MELBOURNE and use galah_select() to return only the eventDate column.\nYou will need to first provide a registered email with the ALA using galah_config() before retrieving records.\n\n# Add registered email (register at ala.org.au)\ngalah_config(email = \"your-email@email.com\")\n\n\nbirds &lt;-\n  galah_call() |&gt;\n  galah_identify(\"Anatidae\") |&gt;\n  galah_filter(\n    cl10929 == \"GREATER MELBOURNE\",\n    year &gt;= 2017,\n    year &lt;= 2021,\n    basisOfRecord == \"HUMAN_OBSERVATION\"\n  ) |&gt;\n  galah_select(eventDate) |&gt;\n  atlas_occurrences()\n\nbirds |&gt; slice_sample(n = 10)\n\n# A tibble: 10 × 2\n   recordID                             eventDate          \n   &lt;chr&gt;                                &lt;dttm&gt;             \n 1 1f2ecd45-a862-46c8-a3ac-629fd43ea95c 2018-02-17 13:54:00\n 2 d2752ab2-ec46-40f1-82f8-422969dc6e5c 2021-07-09 11:02:00\n 3 c2d69c66-24f3-4f35-9701-f1f26b514fec 2019-07-21 08:40:00\n 4 1a8b43ea-109f-453d-9432-b614b9c67424 2021-09-02 16:26:00\n 5 577740ce-701a-4389-aa02-97b62a485ca6 2020-09-18 10:20:00\n 6 6d122db3-1478-419e-9f6b-e31a41ab2488 2021-12-29 13:45:00\n 7 7749f3fb-db99-4339-ba45-e5a6eea9d1bf 2021-08-09 07:52:00\n 8 b45fdcb9-10d8-4aee-a528-8de6df94297d 2019-10-05 09:16:00\n 9 88a30420-0a28-4c99-a628-d06bd4d73e49 2019-11-16 08:31:00\n10 e0e783fe-5183-4e07-b01a-1a7e373836ba 2018-06-09 12:24:00\n\n\nWe’ll then extract the week and year of each date and count the total observations for each week.\n\nbirds_weekly &lt;- birds |&gt; \n  mutate(date = as_date(eventDate),\n         year = year(eventDate),\n         week = week(eventDate)) |&gt;\n  filter(year &gt; 2016) |&gt; # remove stray 2016 records\n  group_by(year, week) |&gt;\n  summarise(week_obs = n())\n\nbirds_weekly \n\n# A tibble: 265 × 3\n# Groups:   year [5]\n    year  week week_obs\n   &lt;dbl&gt; &lt;dbl&gt;    &lt;int&gt;\n 1  2017     1      831\n 2  2017     2      679\n 3  2017     3      725\n 4  2017     4      775\n 5  2017     5      767\n 6  2017     6      771\n 7  2017     7      651\n 8  2017     8      660\n 9  2017     9      703\n10  2017    10      689\n# ℹ 255 more rows\n\n\nWe want to compare observations recorded in 2020-2021 to previous years, but because we know that contributions to the ALA have increased each year, comparing raw numbers will be an unequal comparison and bias our results.\nTo avoid this, let’s scale our weekly record counts by the total number of Anatidae observations each year. Doing this let’s us compare proportions rather than raw numbers.\nFirst let’s download the total Anatidae records for each year.\n\nbirds_yearly &lt;- \n  galah_call() |&gt;    \n  galah_identify(\"Anatidae\") |&gt; \n  galah_filter(cl10929 == \"GREATER MELBOURNE\", \n               year &gt;= 2017, year &lt;= 2021) |&gt; \n  galah_group_by(year) |&gt;\n  atlas_counts() |&gt;\n  rename(year_obs = count) |&gt;\n  mutate(year = as.numeric(year)) |&gt;\n  arrange(-desc(year))\n  \nbirds_yearly\n\n# A tibble: 5 × 2\n   year year_obs\n  &lt;dbl&gt;    &lt;int&gt;\n1  2017    39359\n2  2018    50768\n3  2019    48939\n4  2020    49837\n5  2021    58878\n\n\nNow we’ll join birds_yearly with birds_weekly so we can calculate the proportion of records observed each week. We’ll do this by dividing each row’s weekly total by the yearly total.\n\nbirds_prop &lt;- birds_weekly |&gt; \n  left_join(birds_yearly) |&gt; \n  rowwise() |&gt; \n  mutate(prop = week_obs / year_obs,\n         .keep = \"unused\") |&gt; \n  ungroup()\n\nbirds_prop\n\n# A tibble: 265 × 3\n    year  week   prop\n   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1  2017     1 0.0211\n 2  2017     2 0.0173\n 3  2017     3 0.0184\n 4  2017     4 0.0197\n 5  2017     5 0.0195\n 6  2017     6 0.0196\n 7  2017     7 0.0165\n 8  2017     8 0.0168\n 9  2017     9 0.0179\n10  2017    10 0.0175\n# ℹ 255 more rows\n\n\nTo compare observations in years prior to and during COVID-19, we’ll want to plot two lines:\n\nA baseline of average weekly observation counts in 2017-2019\nA line with weekly observation counts over 2020 and 2021\n\nTo create the average 2017-2019 baseline, let’s calculate the mean proportion of records each week from 2017-2019.\nTo do this, we’ll place our weekly proportions in separate columns using pivot_wider().\n\nbirds_wide &lt;- birds_prop |&gt;\n  pivot_wider(names_from = year, \n              values_from = prop, \n              names_sort = TRUE,\n              names_glue = \"year_{year}\")\n\nbirds_wide\n\n# A tibble: 53 × 6\n    week year_2017 year_2018 year_2019 year_2020 year_2021\n   &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n 1     1    0.0211    0.0209    0.0338    0.0313    0.0225\n 2     2    0.0173    0.0178    0.0350    0.0228    0.0191\n 3     3    0.0184    0.0168    0.0258    0.0239    0.0201\n 4     4    0.0197    0.0158    0.0236    0.0244    0.0190\n 5     5    0.0195    0.0164    0.0201    0.0155    0.0184\n 6     6    0.0196    0.0137    0.0200    0.0180    0.0194\n 7     7    0.0165    0.0176    0.0190    0.0154    0.0168\n 8     8    0.0168    0.0138    0.0184    0.0153    0.0192\n 9     9    0.0179    0.0151    0.0144    0.0131    0.0186\n10    10    0.0175    0.0132    0.0215    0.0115    0.0163\n# ℹ 43 more rows\n\n\nThen we’ll calculate the mean proportion of observations each week across year_2017, year_2018 and year_2019 columns.\n\nbirds_mean_prop &lt;- birds_wide |&gt;\n  rowwise() |&gt;\n  mutate(\n    mean_2017_19 = mean(c_across(year_2017:year_2019)),\n    .keep = \"unused\"\n    ) |&gt;\n  ungroup()\n\nbirds_mean_prop\n\n# A tibble: 53 × 4\n    week year_2020 year_2021 mean_2017_19\n   &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;        &lt;dbl&gt;\n 1     1    0.0313    0.0225       0.0253\n 2     2    0.0228    0.0191       0.0234\n 3     3    0.0239    0.0201       0.0203\n 4     4    0.0244    0.0190       0.0197\n 5     5    0.0155    0.0184       0.0187\n 6     6    0.0180    0.0194       0.0178\n 7     7    0.0154    0.0168       0.0177\n 8     8    0.0153    0.0192       0.0163\n 9     9    0.0131    0.0186       0.0158\n10    10    0.0115    0.0163       0.0174\n# ℹ 43 more rows\n\n\nNow we have all the numbers we need for plotting! We just need to reorganise them so that they plot correctly.\nTwo columns in birds_mean_prop contain proportional counts for 2020 and 2021. Although there are 52 weeks in a year, both years extend from weeks 1-53 because neither year started or ended exactly at the end of the week — 2020 ended on a Thursday and 2021 ended on a Friday.\n\nwday(ymd(\"2020-12-31\"), label = TRUE)\n\n[1] Thu\nLevels: Sun &lt; Mon &lt; Tue &lt; Wed &lt; Thu &lt; Fri &lt; Sat\n\nwday(ymd(\"2021-12-31\"), label = TRUE)\n\n[1] Fri\nLevels: Sun &lt; Mon &lt; Tue &lt; Wed &lt; Thu &lt; Fri &lt; Sat\n\n\nThis means that the proportional counts in week 53 of 2020 and week 1 of 2021 are in the same week! We can combine them to better represent the full week’s observations and save the combined count in week 1 of 2021.\n\nbirds_mean_prop &lt;- birds_mean_prop |&gt;\n  rows_update(tibble(week = 1, year_2021 = sum(birds_mean_prop$year_2020[53] + birds_mean_prop$year_2021[1]))) |&gt;\n  rows_update(tibble(week = 53, year_2020 = NA)) # remove 2020's week 53 count\n\nbirds_mean_prop |&gt; slice_head(n = 3)\n\n# A tibble: 3 × 4\n   week year_2020 year_2021 mean_2017_19\n  &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;        &lt;dbl&gt;\n1     1    0.0313    0.0290       0.0253\n2     2    0.0228    0.0191       0.0234\n3     3    0.0239    0.0201       0.0203\n\nbirds_mean_prop |&gt; slice_tail(n = 3)\n\n# A tibble: 3 × 4\n   week year_2020 year_2021 mean_2017_19\n  &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;        &lt;dbl&gt;\n1    51    0.0181   0.0145       0.0162 \n2    52    0.0216   0.0159       0.0181 \n3    53   NA        0.00124      0.00291\n\n\nTo allow us to plot proportional counts from Jan 2020 to Dec 2021 as one line (105 weeks total), we’ll separate our 2021 proportional counts, revise 2021 week numbers to start from 53, and place them under our 2020 proportions. That’ll let us plot from week 1 to week 105!\n\n# 2021 record count proportions\nbirds_2021 &lt;- birds_mean_prop |&gt;\n  select(-year_2020) |&gt;\n  rename(prop = year_2021) |&gt;\n  mutate(week = week + 52)\n\nglimpse(birds_2021)\n\nRows: 53\nColumns: 3\n$ week         &lt;dbl&gt; 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 6…\n$ prop         &lt;dbl&gt; 0.02902850, 0.01912429, 0.02012636, 0.01897143, 0.0183769…\n$ mean_2017_19 &lt;dbl&gt; 0.02528978, 0.02338032, 0.02031649, 0.01971618, 0.0186806…\n\n# 2020 + 2021 record count proportions\nbirds_final &lt;- birds_mean_prop |&gt;\n  select(-year_2021) |&gt;\n  drop_na() |&gt;\n  rename(prop = year_2020) |&gt;\n  bind_rows(birds_2021) # attach 2021 to the bottom\n\nglimpse(birds_final)\n\nRows: 105\nColumns: 3\n$ week         &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17…\n$ prop         &lt;dbl&gt; 0.031281979, 0.022754179, 0.023857776, 0.024439673, 0.015…\n$ mean_2017_19 &lt;dbl&gt; 0.02528978, 0.02338032, 0.02031649, 0.01971618, 0.0186806…\n\n\n\n\nLockdowns\nDuring the height of the pandemic, Melbourne had 6 distinct lockdowns. Let’s add their start and end dates to a tibble.\nBecause we want to plot 2020 and 2021 on the same plot, we’ll use ifelse() to make sure our week numbers in 2021 match our week numbers in birds_final.\n\nn_lockdown &lt;- c(1:6)\nstart_date &lt;- c(\"2020-03-31\", \"2020-07-09\",\n                \"2021-02-13\", \"2021-05-28\",\n                \"2021-07-16\", \"2021-08-05\")\nend_date &lt;- c(\"2020-05-12\", \"2020-10-27\",\n              \"2021-02-17\", \"2021-06-10\",\n              \"2021-07-27\", \"2021-10-21\")\n\nlockdowns &lt;- tibble(n_lockdown, start_date, end_date) |&gt;\n  mutate(\n    n_days = as_date(ymd(end_date)) - as_date(ymd(start_date)),\n    week_start = ifelse(year(start_date) == 2020, \n                        week(start_date), week(start_date) + 52),\n    week_end = ifelse(year(end_date) == 2020, \n                      week(end_date), week(end_date) + 52),\n    )\nlockdowns \n\n# A tibble: 6 × 6\n  n_lockdown start_date end_date   n_days   week_start week_end\n       &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;drtn&gt;        &lt;dbl&gt;    &lt;dbl&gt;\n1          1 2020-03-31 2020-05-12  42 days         13       19\n2          2 2020-07-09 2020-10-27 110 days         28       43\n3          3 2021-02-13 2021-02-17   4 days         59       59\n4          4 2021-05-28 2021-06-10  13 days         74       75\n5          5 2021-07-16 2021-07-27  11 days         81       82\n6          6 2021-08-05 2021-10-21  77 days         83       94\n\n\n\n\nMake plot\nTo help us see the components of our final plot more clearly, let’s construct our visualisation step-by-step.\nFirst, we’ll add our lockdown dates as highlighted rectangular blocks. To do this we can use geom_rect(), setting the xmin and xmax values to our week_start and week_end columns in lockdowns. We’ll make the rectangle spread across the entire plot by setting ymax = Inf and ymin = 0.\nWe’ll also set our fill inside of aes() and define its value within scale_fill_manual() which will allow us to add the lockdown colour and label to its own legend.\n\np1 &lt;- ggplot() +\n  geom_rect(data = lockdowns,\n            aes(xmin = week_start,\n                xmax = week_end,\n                fill = \"Lockdown\"),\n            ymin = 0,\n            ymax = Inf,\n            alpha=0.2) +\n  scale_fill_manual(\n    values = c(\"Lockdown\" = pilot_color(\"yellow\")))\np1\n\n\n\n\n\n\n\n\nNext we’ll add our proportional species observation counts as lines. We can define their colours and edit the legend and axis labels, too.\n\np2 &lt;- p1 +\n  # add lines\n  geom_line(data = birds_final, \n            aes(x = week, y = prop, \n            color = \"2020-21 Records\"), \n            linewidth = 1) + \n  geom_line(data = birds_final, \n            aes(x = week, y = mean_2017_19, \n            color = \"2017-19 Average\"),\n            linetype = \"twodash\", \n            linewidth = 0.8) + \n  # add fill\n  geom_area(data = birds_final, \n            aes(x = week, y = prop),\n            fill=pilot_color(\"blue\"), \n            alpha=0.3) + \n  scale_color_manual(values = c(pilot_color(\"orange\"),\n                                pilot_color(\"blue\")), \n                     labels = c(\"2017-19 (average)\", \n                                \"2020-21\")) +\n  guides(fill = guide_legend(title = \"\"), \n         color = guide_legend(title = \"Year\")) +\n  labs(y = \"Proportion of year's total observations\",\n       x = \"Month\",\n       title = \"Anatidae observations in Melbourne prior to & during COVID-19\")\np2\n\n\n\n\n\n\n\n\nThe plot above is enough to see everything we need to see from our data. You could stop here if you wished, but we’ve gone ahead and made a more refined visualisation with nice fonts, axis scales, axis labels and titles!\n\n\nCode\n# add fonts\nfont_add_google(\"Montserrat\", family = \"mont\")\nfont_add_google(\"Hind\", family = \"hind\")  \nshowtext_auto(enable = TRUE)\n\np2 + \n  # make axis scales understandable\n  scale_y_continuous(expand = c(0, 0),\n                     limits = c(0, 0.035),\n                     labels = scales::percent_format()) +\n  scale_x_continuous(expand = c(0, 0),\n                     limits = c(1, 105),\n                     breaks = c(1, 14, 27, 40, 52, 65, 78, 91),\n                     labels = c(\"Jan\", \"Apr\", \"Jul\", \"Oct\", \"Jan\", \"Apr\", \"Jul\", \"Oct\")) +\n  # add year x axis labels\n  coord_cartesian(clip = \"off\") +\n  annotate_pilot(label = \"2020\", x = 27, y = 0, \n                 alpha = 0.7, vjust = 3.8,size = 10) +\n  annotate_pilot(label = \"2021\", x = 78, y = 0, \n                 alpha = 0.7, vjust = 3.8, size = 10) +\n  labs(title = \"*Anatidae* observations in Melbourne prior to & during COVID-19\") +\n  theme_pilot(grid = \"\",\n              axes = \"bl\") +\n  theme(axis.title.x = element_text(size = 23, vjust = -1.3),\n        axis.title.y = element_text(size = 23),\n        axis.text.x = element_text(size = 20),\n        axis.text.y = element_text(size = 20),\n        axis.line = element_line(linewidth = 0.5),\n        legend.text = element_text(size = 23),\n        legend.title = element_text(size = 20),\n        plot.caption = element_text(size = 18),\n        text = element_text(family = \"hind\"),\n        plot.title = element_markdown(family = \"mont\", size = 31),\n        plot.subtitle = element_markdown(family = \"mont\", size = 28))\n\n\n\n\n\n\n\n\n\nNow that we have our final plot, we can see a few interesting trends:\n\nIn the first lockdown (soon after COVID-19 arrived in Australia), species observations were lower than the 2017-2019 average.\nIn the 2 longest lockdowns, species observations were higher than the 2017-2019 average.\nIn the last half of all lockdowns except the first lockdown, observations increased.\n\nAre these trends that you expected to see?\nIt’s impossible to make any claims of why these trends emerged from our data visualisation alone, but we can speculate (for fun!)\nWere people making fewer observations in the first lockdown because they were preoccupied with all the other priorities of settling into new working-from-home routines? Did people make more observations at the tail end of lockdowns because they were seeking relief from being inside by spending more time by natural ponds and lakes?\nSome evidence from the US found more people were using natural spaces during COVID-19, and time in these spaces lowered depression and anxiety. A New Zealand study found similar results.\n\n\nFinal thoughts\nThis post has detailed how you can use ALA data to explore relationships between record counts and events. Although we can’t make any causal claims from what we see in our plot, making a time-series is a nice way to do some exploratory analysis on a lot of data!\n\n\nExpand for session info\n\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Australia.utf8\n ctype    English_Australia.utf8\n tz       Australia/Sydney\n date     2024-02-12\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n dplyr       * 1.1.4   2023-11-17 [1] CRAN (R 4.3.2)\n forcats     * 1.0.0   2023-01-29 [1] CRAN (R 4.3.2)\n galah       * 2.0.1   2024-02-06 [1] CRAN (R 4.3.2)\n ggplot2     * 3.4.4   2023-10-12 [1] CRAN (R 4.3.1)\n ggtext      * 0.1.2   2022-09-16 [1] CRAN (R 4.3.2)\n htmltools   * 0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n lubridate   * 1.9.3   2023-09-27 [1] CRAN (R 4.3.2)\n pilot       * 4.0.0   2022-07-13 [1] Github (olihawkins/pilot@f08cc16)\n purrr       * 1.0.2   2023-08-10 [1] CRAN (R 4.3.2)\n readr       * 2.1.4   2023-02-10 [1] CRAN (R 4.3.2)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n showtext    * 0.9-6   2023-05-03 [1] CRAN (R 4.3.2)\n showtextdb  * 3.0     2020-06-04 [1] CRAN (R 4.3.2)\n stringr     * 1.5.1   2023-11-14 [1] CRAN (R 4.3.2)\n sysfonts    * 0.8.8   2022-03-13 [1] CRAN (R 4.3.2)\n tibble      * 3.2.1   2023-03-20 [1] CRAN (R 4.3.2)\n tidyr       * 1.3.0   2023-01-24 [1] CRAN (R 4.3.2)\n tidyverse   * 2.0.0   2023-02-22 [1] CRAN (R 4.3.2)\n\n [1] C:/Users/KEL329/R-packages\n [2] C:/Users/KEL329/AppData/Local/Programs/R/R-4.3.2/library\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "posts/2023-04-28_plotting-invasive-species/index.html",
    "href": "posts/2023-04-28_plotting-invasive-species/index.html",
    "title": "Plotting invasive species distributions with alpha shapes and choropleth maps in Python",
    "section": "",
    "text": "Author\nCaitlin Ramsay\nAmanda Buyan\nDax Kellie\n\n\nDate\n28 April 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIntern Post\n\n\n\n\n\n\nHumans’ movement across the globe has led to the accidental, and sometimes deliberate, transportation of species beyond their native habitats. In Australia since European colonisation, around 3,000 species have been introduced.\nWithin the last 200 years over 100 native species have gone extinct, with invasive species labelled as affecting 82% (1,257 of 1,533) of Australia’s threatened taxa in 2018. Since 1960, invasive species have cost the Australian economy at least $390 billion in damages, and are now considered a main driver of extinctions in native plants and animals.\nHowever, species from outside of Australia aren’t the only ones that can encroach on other species’ habitats. Native Australian species can do it, too. Thanks in part to human activity, changing temperatures and more frequent extreme weather events, some Australian species have established themselves in new areas outside of their native range. Although not as popularly discussed, Australian species that have become pests in new habitats can disrupt ecosystems much like internationally invasive species.\nIn this post, we will use Python and the {galah} package to visualise how distributions of both international invasive species and native introduced pest species have shifted over time. To do this, we will use alpha shapes to visualise the distribution of Rhinella marina (Cane toads) since the 1930s and create a choropleth map to visualise the expanded habitat range of Pittosporum undulatum.\n\nInvasive Species\n\nDownload data\nTo start, we will use the infamous example of the cane toad to illustrate how far an invasive species’ distribution can spread each decade.\n\n\n\n\n\n\n \n\n\n\n\n\n \n\n\n\n\nRhinella marina (Isaac Clarey CC-BY-NC 4.0 (Int))\n\nFirst load the required Python packages.\n\nimport galah\nimport pandas as pd\nimport geopandas\nimport numpy as np\nfrom dateutil.parser import parse\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport alphashape\nfrom flexitext import flexitext\n\nNext, we will use the {galah} package to download occurrence records of cane toads in Australia from the Atlas of Living Australia (ALA). You will need to first provide a registered email with the ALA using galah.galah_config() before retrieving records.\n\n# Add registered email (register at ala.org.au)\ngalah.galah_config(email = \"your-email@email.com\")\ngalah.galah_config(data_profile=\"ALA\")\n\n\ncane_toads = galah.atlas_occurrences(taxa = \"Rhinella marina\", use_data_profile = True)\ncane_toads.head(5)\n\n\n\n\n\n\n\n\ndecimalLatitude\ndecimalLongitude\neventDate\nscientificName\ntaxonConceptID\nrecordID\ndataResourceName\noccurrenceStatus\n\n\n\n\n0\n-38.300000\n145.000000\n1990-04-23T00:00:00Z\nRhinella marina\nhttps://biodiversity.org.au/afd/taxa/e79179f8-...\n58772bea-1c61-4716-a453-f201e89fcc8d\nMuseums Victoria provider for OZCAM\nPRESENT\n\n\n1\n-38.300000\n145.000000\n1990-07-21T00:00:00Z\nRhinella marina\nhttps://biodiversity.org.au/afd/taxa/e79179f8-...\n141f0b10-bdf2-4239-80e4-1b5167e1f76c\nMuseums Victoria provider for OZCAM\nPRESENT\n\n\n2\n-37.820000\n145.230000\n1990-04-14T00:00:00Z\nRhinella marina\nhttps://biodiversity.org.au/afd/taxa/e79179f8-...\nf6d07eb2-4f8f-476e-a212-726b10a4a745\nMuseums Victoria provider for OZCAM\nPRESENT\n\n\n3\n-36.431411\n148.329322\n2017-03-07T00:00:00Z\nRhinella marina\nhttps://biodiversity.org.au/afd/taxa/e79179f8-...\n549908bf-0b34-4227-9288-42a7fa52dabf\nNSW BioNet Atlas\nPRESENT\n\n\n4\n-36.250765\n149.120224\n2021-02-04T00:00:00Z\nRhinella marina\nhttps://biodiversity.org.au/afd/taxa/e79179f8-...\nae36a792-f694-4a73-acfb-e56be564def6\nNSW BioNet Atlas\nPRESENT\n\n\n\n\n\n\n\n\n\nClean data\nWe’ll clean our data to ensure that there are no null or missing values in our coordinates and date fields. Because galah.atlas_occurrences() returns a Pandas dataframe, we have plenty of functions we can use to clean our data.\n\ncane_toads = cane_toads.dropna(subset=[\"eventDate\", \"decimalLatitude\", \"decimalLongitude\"])\n\nWe want to map cane toad’s distribution each decade in our final visualisation. However, the eventDate value for each record is formaatted as a string value yyyy-mm-dd Thh:mm:ssZ. Let’s write our own function convert_date_to_decade() that extract the year from a date string and return its corresponding decade by rounding down to the nearest decade.\n\ndef convert_date_to_decade(value):\n    date = parse(value)\n    return date.year - (date.year%10)\n\nWe’ll create our new decade column by mapping each record’s date value in eventDate to its corresponding decade value.\n\ncane_toads[\"decade\"] = cane_toads[\"eventDate\"].map(convert_date_to_decade)\n\n\n\nMake Australia map\nNext, let’s download a shapefile of Australia with state boundaries. The Australian Bureau of Statistics provides digital boundary files from which you can explore many other Australian shapefiles. Download the States and Territories - 2021 - Shapefile a zip folder. Save the zip folder inside your working folder and then unzip it to access the .shp file inside.\n{GeoPandas} is a package that handles geospatial data in Python and can be used to load in shapefiles as GeoPandas dataframes. Let’s test this out by plotting our Australian state boundary shapefile.\n\nmpl.rcParams['figure.dpi'] = 1200 # generate a high resolution image\nstates = geopandas.read_file(\"Australia_state_boundaries/STE_2021_AUST_GDA2020.shp\")\nstates.plot(edgecolor = \"#5A5A5A\", linewidth = 0.5, facecolor = \"white\")\n\n\n\n\n\n\n\n\n\n\n\n\nGenerate alpha shapes\nAlpha shapes can be used to define and visualise the shape of a set of species occurrence points in space. They are useful because they can be generated on data-deficient species with few available observations, and without using environmental data or complex algorithms. Let’s use alpha shapes to see how cane toads’ distribution has changed each decade since they were introduced.\nFirst, we need to obtain a list of all decades with cane toad observations. We’ll use the decade column from our cane_toads dataframe to group our observations.\n\ndecades = list(set(cane_toads[\"decade\"]))\n\nWe will be using the {alphashape} package to create alpha shapes representing the cane toad distribution for each decade they have been observed. The alphashape.alphashape() function requires two things:\n\nA set of observation coordinates\nAn alpha parameter, which sets how tightly the shape’s lines conform to our observations\n\nLet’s make an alpha shape for each decade’s observations. We’ll also add a slight buffer to each alpha shape to smooth out some of its edges. Then we’ll group all the shapes into one large GeoPandas dataframe.\n\n\n\n\n\n\nNote\n\n\n\nWe used alpha = 1, but it’s good practice to change this parameter depending on how widely distributed the coordinates of your data are. Also note that alphashape.alphashape() requires at least 3 data points to calculate an alpha shape.\n\n\n\nalpha_shape_gdf = geopandas.GeoDataFrame() # GeoPandas data frame to contain all alpha shapes\nfor i, d in enumerate(decades):\n    decade_points = cane_toads[[\"decimalLongitude\", \"decimalLatitude\"]] [cane_toads[\"decade\"] == d]\n    if len(decade_points) &lt;= 3: \n        continue\n    alpha_shape = alphashape.alphashape(decade_points, 1)\n    d = {\"decade\": d, \"geometry\": [alpha_shape.buffer(0.2)]}\n    tmp_gdf = geopandas.GeoDataFrame(d, crs=\"EPSG:7844\")\n    alpha_shape_gdf = pd.concat([alpha_shape_gdf, tmp_gdf])\n\nWARNING:root:Singular matrix. Likely caused by all points lying in an N-1 space.\n\n\nNext, let’s clean up our GeoPandas dataframe so that it is ready for plotting! Sometimes the alphashape.alphashape() algorithm will produce an empty shape that needs to be removed from the dataframe (this generally happens when the chosen alpha parameter is not appropriate for the supplied set of points). Let’s remove these shapes from our data.\n\nalpha_shape_gdf = alpha_shape_gdf[~alpha_shape_gdf[\"geometry\"].is_empty]\n\nNow let’s format our decade string to display correctly on the figure legend by making sure it’s in YYYYs format.\n\nalpha_shape_gdf[\"decade_string\"] = alpha_shape_gdf[\"decade\"].map(lambda d: str(d) + \"s\")\n\nFinally, because we expect cane toad distributions in earlier decades to be smaller than in recent decades, we’ll need to plot earlier distributions on top of later distributions to avoid covering the earlier ones up. To achieve this, let’s order the alpha shapes in descending order by decade.\n\nalpha_shape_gdf.sort_values(by='decade', ascending=False, inplace=True)\n\n\n\nMap alpha shape distributions\nFinally, we can plot our alpha shape distributions for each decade onto our map of Australia!\nThis figure showcases the incredible pace of the cane toad’s spread across northern Australia. Our map shows that cane toads have spread across most of Queensland, the top end of the Northern Territory (from the 1980s to 2010s) and more recently, into the Kimberley region of Western Australia.\n\nax = states.boundary.plot(edgecolor=\"#5A5A5A\", linewidth=0.5, facecolor=\"white\", zorder=-1)\n\nalpha_shape_gdf.plot(ax = ax, cmap=\"plasma\", column = \"decade_string\", legend=True, categorical=True)\nlgd = ax.get_legend()\nlgd.draw_frame(False)\nlgd.set_bbox_to_anchor((1.2, 0.8))\n\ntitle_text = \"&lt;style: italic&gt;Rhinella marina&lt;/&gt; (cane toad) distributions per decade\"\nflexitext(0.5, 1, title_text, va=\"bottom\", ha=\"center\");\n\ncaption_text = \"&lt;color:#5A5A5A, style:italic, size:7&gt;Distributions calculated with alpha hulls of each decade's cane toad observations&lt;/&gt;\"\nflexitext(0.05, 0, caption_text, va=\"top\");\n\nplt.xlim([110, 161])\nplt.ylim([-45, -8])\nplt.axis(\"off\")\nplt.subplots_adjust(left=-0.15, right=1)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\nOther invasive species\nLet’s use the same code as above to visualise other invasive species Camelus dromedarius (Feral dromedary camels) and Echium plantagineum (Paterson’s curse).\n\nCamelsPatterson’s curse\n\n\n\n\nCode\n# Camel\ncamels = galah.atlas_occurrences(\"Camelus dromedarius\", use_data_profile=\"ALA\")\ncamels = camels.dropna(subset=[\"eventDate\", \"decimalLatitude\", \"decimalLongitude\"])\ncamels[\"decade\"] = camels[\"eventDate\"].map(convert_date_to_decade)\ndecades = list(set(camels[\"decade\"]))\n\nalpha_shape_gdf = geopandas.GeoDataFrame() # GeoPandas data frame to contain all alpha shapes\n\nfor i, d in enumerate(decades):\n    decade_points = camels[[\"decimalLongitude\", \"decimalLatitude\"]] [camels[\"decade\"] == d]\n    if len(decade_points) &lt;= 3: \n        continue\n    alpha_shape = alphashape.alphashape(decade_points, 1)\n    d = {\"decade\": d, \"geometry\": [alpha_shape.buffer(0.2)]}\n    tmp_gdf = geopandas.GeoDataFrame(d, crs=\"EPSG:4326\")\n    alpha_shape_gdf = pd.concat([alpha_shape_gdf, tmp_gdf])\n\nalpha_shape_gdf = alpha_shape_gdf[ ~alpha_shape_gdf[\"geometry\"].is_empty]\nalpha_shape_gdf[\"decade_string\"] = alpha_shape_gdf[\"decade\"].map(lambda d: str(d) + \"s\")\nalpha_shape_gdf.sort_values(by='decade', ascending=False, inplace=True)\n\nax = states.boundary.plot(edgecolor=\"#5A5A5A\", linewidth=0.5, facecolor=\"white\", zorder=-1)\n\nalpha_shape_gdf.plot(ax = ax, cmap=\"plasma\", column = \"decade\", legend=True, categorical=True)\nlgd = ax.get_legend()\nlgd.draw_frame(False)\nlgd.set_bbox_to_anchor((1.2, 0.61))\n\ntitle_text = \"&lt;style: italic&gt;Camelus dromedarius&lt;/&gt; (dromedary camel) distributions per decade\"\nflexitext(0.5, 1, title_text, va=\"bottom\", ha=\"center\");\n\ncaption_text = \"&lt;color:#5A5A5A, style:italic, size:7&gt;Distributions calculated with alpha hulls of each decade's dromedary camel observations&lt;/&gt;\"\nflexitext(0.05, 0, caption_text, va=\"top\");\n\nplt.xlim([110, 161])\nplt.ylim([-45, -8])\nplt.axis(\"off\")\nplt.subplots_adjust(left=-0.1, right=1)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Paterson's Curse\nopuntia = galah.atlas_occurrences(\"Echium plantagineum\", use_data_profile=\"ALA\")\nopuntia = opuntia.dropna(subset=[\"eventDate\", \"decimalLatitude\", \"decimalLongitude\"])\nopuntia[\"decade\"] = opuntia[\"eventDate\"].map(convert_date_to_decade)\ndecades = list(set(opuntia[\"decade\"]))\n\nalpha_shape_gdf = geopandas.GeoDataFrame() # GeoPandas data frame to contain all alpha shapes\n\nfor i, d in enumerate(decades):\n    decade_points = opuntia[[\"decimalLongitude\", \"decimalLatitude\"]] [opuntia[\"decade\"] == d]\n    if len(decade_points) &lt;= 3: \n        continue\n    alpha_shape = alphashape.alphashape(decade_points, 1)\n    d = {\"decade\": d, \"geometry\": [alpha_shape.buffer(0.2)]}\n    tmp_gdf = geopandas.GeoDataFrame(d, crs=\"EPSG:4326\")\n    alpha_shape_gdf = pd.concat([alpha_shape_gdf, tmp_gdf])\n\nalpha_shape_gdf = alpha_shape_gdf[ ~alpha_shape_gdf[\"geometry\"].is_empty]\nalpha_shape_gdf[\"decade_string\"] = alpha_shape_gdf[\"decade\"].map(lambda d: str(d) + \"s\")\nalpha_shape_gdf.sort_values(by='decade', ascending=False, inplace=True)\n\nax = states.boundary.plot(edgecolor=\"#5A5A5A\", linewidth=0.5, facecolor=\"white\", zorder=-1)\n\nalpha_shape_gdf.plot(ax = ax, cmap=\"plasma\", column = \"decade\", legend=True, categorical=True)\nlgd = ax.get_legend()\nlgd.draw_frame(False)\nlgd.set_bbox_to_anchor((1.2, 0.85))\n\ntitle_text = \"&lt;style: italic&gt;Echium plantagineum&lt;/&gt; (Paterson's curse) distributions per decade\"\nflexitext(0.5, 1, title_text, va=\"bottom\", ha=\"center\");\n\ncaption_text = \"&lt;color:#5A5A5A, style:italic, size:7&gt;Distributions calculated with alpha hulls of each decade's Paterson's curse observations&lt;/&gt;\"\nflexitext(0.05, 0, caption_text, va=\"top\");\n\nplt.xlim([110, 161])\nplt.ylim([-45, -8])\nplt.axis(\"off\")\nplt.subplots_adjust(left=-0.1, right=1)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNative introduced pest species\nWhen people think of invasive species, they generally think of species that have been introduced to Australia from other countries. However, even Australia’s native species can become pests when introduced to a new ecosystem.\nOne good example of native pests are the trees Pittosporum undulatum (sometimes called Sweet Pittosporum). These trees have been introduced as ornamental plants in gardens across Australia because of their sweet-scented flowers and bright berries. Although Pittosporum undulatum’s native range extends from southern Queensland to eastern Victoria, it is now considered an environmental weed in many regions where it has been introduced.\n\n\n\n\n\n\n \n\n\n\n\n\n \n\n\n\n\nPittosporum undulatum (Chris Clarke CC-BY)\n\nLet’s create a choropleth map to visualise the to visualise the bioregions where Pittosporum undulatum is native and introduced.\n\nDownload IBRA regions\nFirst, let’s download a shapefile of Australia’s bioregions. The IBRA7 bioregions classify areas within Australia that are geographically and ecologically distinct. Download the zip folder, save it in your project directory and unzip it. We can again use the {GeoPandas} package to read in and handle these data.\n\nbioregions = geopandas.read_file(\"IBRA7_regions/ibra7_regions.shp\")\nbioregions.plot(edgecolor = \"#5A5A5A\", linewidth = 0.25, facecolor = \"white\")\n\n\n\n\n\n\n\n\n\n\nWithin our bioregions dataframe, the column REG_NAME_7 contains IBRA bioregion names.\n\nbioregions.head(5)\n\n\n\n\n\n\n\n\nREG_CODE_7\nREG_NAME_7\nHECTARES\nSQ_KM\nREC_ID\nREG_CODE_6\nREG_NAME_6\nREG_NO_61\nFEAT_ID\nShape_Leng\nShape_Area\ngeometry\n\n\n\n\n0\nARC\nArnhem Coast\n3.335669e+06\n33356.686\n1\nARC\nArnhem Coast\n81.0\nGA_100K_Islands\n52.135362\n2.774143\nMULTIPOLYGON (((136.93863 -14.36548, 136.93790...\n\n\n1\nARP\nArnhem Plateau\n2.306023e+06\n23060.226\n2\nARP\nArnhem Plateau\n82.0\nGA_100K_Mainland\n8.206764\n1.921833\nPOLYGON ((134.08186 -12.32124, 134.09525 -12.3...\n\n\n2\nAUA\nAustralian Alps\n1.232981e+06\n12329.805\n3\nAA\nAustralian Alps\n6.0\nGA_100K_Mainland\n63.337626\n1.242821\nMULTIPOLYGON (((145.75905 -37.67486, 145.76034...\n\n\n3\nAVW\nAvon Wheatbelt\n9.517104e+06\n95171.043\n4\nAW\nAvon Wheatbelt\n70.0\nGA_100K_Mainland\n35.275357\n9.012298\nPOLYGON ((115.48396 -28.30698, 115.48428 -28.3...\n\n\n4\nBBN\nBrigalow Belt North\n1.367453e+07\n136745.325\n5\nBBN\nBrigalow Belt North\n22.0\nGA_100K_Islands\n91.288203\n11.986228\nMULTIPOLYGON (((151.14295 -23.71304, 151.14210...\n\n\n\n\n\n\n\n\n\nFind bioregions with observations\nWe’ll once again use {galah} to find numbers of Pittosporum undulatum in each bioregion. First, let’s find which field ID corresponds to bioregions in {galah}\n\ngalah.search_all(fields = \"IBRA\") \n\n\n\n\n\n\n\n\nid\ndescription\ntype\nlink\n\n\n\n\n0\ncl3\nWestern Australian Biodiversity Science Resear...\nlayers\n\n\n\n1\ncl20\nIBRA 6 Regions Interim Biogeographic Regionali...\nlayers\n\n\n\n2\ncl1049\nIBRA 7 Subregions IBRA 7 Subregions\nlayers\n\n\n\n3\ncl1048\nIBRA 7 Regions Interim Biogeographic Regionali...\nlayers\n\n\n\n\n\n\n\n\nIt looks like field cl1048 contains IBRA 7 regions. Let’s check what values this field contains by using galah.show_values().\n\ngalah.show_values(field = \"cl1048\")\n\n\n\n\n\n\n\n\nfield\ncategory\n\n\n\n\n0\ncl1048\nSouth Eastern Queensland\n\n\n1\ncl1048\nSydney Basin\n\n\n2\ncl1048\nSouth Eastern Highlands\n\n\n3\ncl1048\nSouth East Coastal Plain\n\n\n4\ncl1048\nNSW North Coast\n\n\n...\n...\n...\n\n\n84\ncl1048\nCentral Arnhem\n\n\n85\ncl1048\nIndian Tropical Islands\n\n\n86\ncl1048\nLittle Sandy Desert\n\n\n87\ncl1048\nGibson Desert\n\n\n88\ncl1048\nCoral Sea\n\n\n\n\n89 rows × 2 columns\n\n\n\nNow we can use the group_by argument in galah.atlas_counts() to group observations of Pittosporum undulatum by bioregion, returning all bioregions where Pittosporum undulatum has been observed at least once. We’ll extract extract and save the bioregion names in a dataframe.\n\nfound_bioregion_counts = galah.atlas_counts(\"Pittosporum undulatum\",\n                                           group_by=\"cl1048\",\n                                           expand = False)\n\n# extract bioregion names from Pandas dataframe into list\nfound_bioregions = list(found_bioregion_counts[\"cl1048\"])\n\nprint(found_bioregion_counts[0:10])\n\n                     cl1048  count\n0              Sydney Basin  10244\n1  South East Coastal Plain   3300\n2   South Eastern Highlands   2945\n3         South East Corner   2931\n4           NSW North Coast   2445\n5  South Eastern Queensland   1190\n6      Flinders Lofty Block    464\n7   Southern Volcanic Plain    368\n8        Victorian Midlands    200\n9       Brigalow Belt South    173\n\n\n\n\nSeparate native & introduced regions\nNext, let’s separate bioregions where Pittosporum undulatum is native from bioregions where it has been introduced. The Australia Native Plants Society estimates Pittosporum undulatum’s native range overlapping with South Eastern Queensland, NSW North Coast, Sydney Basin, South East Corner and South East Coastal Plain (see here). Let’s save these bioregion names in a separate dataframe and compare them to the overall list found_bioregions.\n\nnative_bioregions = [\"South Eastern Queensland\", \"NSW North Coast\", \"Sydney Basin\", \"South East Corner\", \"South East Coastal Plain\"]\nintroduced_bioregions = [region for region in found_bioregions if region not in native_bioregions]\n\nprint(introduced_bioregions[1:5]) # first 5 introduced regions\n\n['Flinders Lofty Block', 'Southern Volcanic Plain', 'Victorian Midlands', 'Brigalow Belt South']\n\n\nNext we can add a new column native to our GeoPandas bioregion dataframe to identify native and introduced regions. We’ll use the .loc method to assign a “Native”, “Introduced” or “No observations” label to each row depending on whether the region is in native_bioregions or introduced_bioregions.\n\nbioregions.loc[bioregions[\"REG_NAME_7\"].isin(native_bioregions), \"native\"] = \"Native\"\nbioregions.loc[bioregions[\"REG_NAME_7\"].isin(introduced_bioregions), \"native\"] = \"Introduced\"\nbioregions[\"native\"] = bioregions[\"native\"].replace(\"nan\", \"No observations\")\n\n\n\nMake choropleth map\nWhen plotting this GeoPandas dataframe, we can specify that we want the map coloured according to its native label so that native, introduced and not found bioregions are distinguishable colours. This is done by supplying the column argument of the .plot() function with the column of the dataframe that the colouring is based upon. However, matplotlib would choose a default colourmap to colour the bioregions so we will need to specify the exact colours we wanted associated with each type of bioregion.\nTo identify our three categories of regions on our map, we’ll create a new column colour containing colour hex codes for plotting our regions.\n\nbioregions.loc[bioregions[\"native\"] == \"Native\", \"colour\"] = \"#8FBD4C\" # Native\nbioregions.loc[bioregions[\"native\"] == \"Introduced\", \"colour\"] = \"#F7872E\" # Introduced\nbioregions.loc[bioregions[\"native\"] == \"No observations\", \"colour\"] = \"#E4DFCF\" # No observations\n\nWe can use this colour column as the input to our .plot() function.\nOur map shows that Pittosporum undulatum has been observed in Western Australia, Northern Territory, South Australia, and even Tasmania despite having a fairly narrow native range along the east coast of Australia.\n\nbioregions.plot(edgecolor=\"white\", linewidth = 0.25, color = bioregions[\"colour\"])\n\ntitle_text = \"&lt;style:italic&gt;Pittosporum undulatum&lt;/&gt; &lt;color:#8FBD4C, weight:bold&gt;native&lt;/&gt; and &lt;color:#F7872E, weight:bold&gt;introduced&lt;/&gt; Australian bioregions\"\nflexitext(0.5, 1, title_text, va=\"bottom\", ha=\"center\");\n\nplt.xlim([110, 161])\nplt.ylim([-45, -8])\nplt.axis(\"off\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nFinal thoughts\nHuman activity—from constructing buildings to travelling overseas to gardening—plays a part in shaping modern ecosystems. Our maps showed how quickly well-known invasive species have established themselves across Australia, and how widely even native Australian plants can spread when introduced to non-native regions.\nHumans are just one of many drivers of introducing species to new areas. Changes to the environment, for example, can shrink available resources and living space in a habitat, giving introduced species a chance to outcompete native species for what resources and space are left. As species inevitably enter and alter ecosystems, large weather events, extreme temperatures and habitat degradation can give invasives a big leg-up on the native competition, too.\nNonetheless, there is still hope. Research finds native species can still adapt to changing environments and simple tasks like pulling weeds can help native species survive after events like fires.\n\n\nExpand for session info\n\n\nimport math\nimport natsort\nimport pandas\nimport session_info\n\nsession_info.show()\n\n\nClick to view session information\n-----\nalphashape          1.3.1\ndateutil            2.8.2\nflexitext           0.2.0\ngalah               0.8.2\ngeopandas           0.14.1\nmatplotlib          3.8.2\nnatsort             8.4.0\nnumpy               1.26.2\npandas              2.1.3\nsession_info        1.0.0\nshapely             2.0.2\n-----\n\n\nClick to view modules imported as dependencies\nPIL                 10.1.0\nasttokens           NA\nattr                23.1.0\ncertifi             2023.11.17\ncffi                1.15.1\ncharset_normalizer  3.3.2\ncolorama            0.4.6\ncomm                0.2.0\ncycler              0.12.1\ncython_runtime      NA\ndebugpy             1.8.0\ndecorator           5.1.1\ndefusedxml          0.7.1\nexecuting           2.0.1\nfiona               1.9.5\ngoogle              NA\nidna                3.6\nipykernel           6.27.0\nipython_genutils    0.2.0\njedi                0.19.1\nkiwisolver          1.4.5\nmatplotlib_inline   0.1.6\nmpl_toolkits        NA\nnetworkx            3.2.1\npackaging           23.2\nparso               0.8.3\npickleshare         0.7.5\npkg_resources       NA\nplatformdirs        4.1.0\nprompt_toolkit      3.0.41\npsutil              5.9.6\npure_eval           0.2.2\npydev_ipython       NA\npydevconsole        NA\npydevd              2.9.5\npydevd_file_utils   NA\npydevd_plugins      NA\npydevd_tracing      NA\npygments            2.17.2\npyparsing           3.1.1\npyproj              3.6.1\npytz                2023.3.post1\npywin32_bootstrap   NA\npywin32_system32    NA\nrequests            2.31.0\nrtree               1.0.1\nscipy               1.12.0\nsix                 1.16.0\nstack_data          0.6.3\ntornado             6.3.3\ntraitlets           5.13.0\ntrimesh             3.21.5\nurllib3             2.1.0\nwcwidth             0.2.12\nzmq                 25.1.2\n\n \n-----\nIPython             8.17.2\njupyter_client      8.6.0\njupyter_core        5.5.0\nnotebook            6.5.4\n-----\nPython 3.12.0 (tags/v3.12.0:0fb18b0, Oct  2 2023, 13:03:39) [MSC v.1935 64 bit (AMD64)]\nWindows-10-10.0.19045-SP0\n-----\nSession information updated at 2024-02-13 11:25"
  },
  {
    "objectID": "posts/2023-08-28_alternatives-to-box-plots/index.html",
    "href": "posts/2023-08-28_alternatives-to-box-plots/index.html",
    "title": "Alternatives to box plots: Using beeswarm and raincloud plots to summarise ecological data",
    "section": "",
    "text": "Dax Kellie\nShandiya Balasubramaniam\n\n\n\n28 August 2023\nIn ecology and biology research, box plots are a wonderfully simple and efficient way to summarise data from different groups (e.g., species, populations, experimental conditions). However, this simplicity can sometimes hide the underlying structure of data, unintentionally misleading readers.\nLuckily, there are alternatives to displaying data with box plots, and these options have grown increasingly easy to make in R. This post shows more transparent ways to summarise data, seen through an ecological lens.\nIn our example, we’ll compare several species of plants using a leaf trait commonly used to predict a plant’s performance: leaf dry mass per area (or more simply, the size of a leaf relative to its surface area). We’ll explain how to summarise this trait across a set of species using box plots, and show two ways of also displaying the distribution of the data to be more transparent."
  },
  {
    "objectID": "posts/2023-08-28_alternatives-to-box-plots/index.html#why-not-box-plots",
    "href": "posts/2023-08-28_alternatives-to-box-plots/index.html#why-not-box-plots",
    "title": "Alternatives to box plots: Using beeswarm and raincloud plots to summarise ecological data",
    "section": "Why not box plots?",
    "text": "Why not box plots?\nBox plots can mask differences in sample size and underlying data structure, which can make them prone to misinterpretation. One such example, shown below, is based on Cedric Scherer’s blog post on the same topic, which I encourage you to check out.\n\n\nCode\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(glue)\nlibrary(ggtext)\nlibrary(gganimate)\n\n# generate sample data\nset.seed(2021)\n\ndata &lt;- tibble(\n  group = factor(c(rep(\"Group 1\", 100), rep(\"Group 2\", 250), rep(\"Group 3\", 25))),\n  value = c(seq(0, 20, length.out = 100),\n            c(rep(0, 5), rnorm(30, 2, .1), rnorm(90, 5.4, .1), rnorm(90, 14.6, .1), rnorm(30, 18, .1), rep(20, 5)),\n            rep(seq(0, 20, length.out = 5), 5))\n  ) %&gt;% \n  rowwise() |&gt;\n  mutate(value = if_else(group == \"Group 2\", value + rnorm(1, 0, .4), value)) |&gt; \n  group_by(group) |&gt; \n  mutate(sample_size = n())\n\nanim &lt;- ggplot(data) +\n  geom_boxplot(aes(y = value), \n               fill = \"grey92\") +\n   geom_point(aes(x = 0, y = value),\n              size = 2,\n              alpha = .3,\n              position = position_jitter(seed = 1, width = .2)) +\n  labs(title = \"N = {closest_state}\") +\n  pilot::theme_pilot() +\n  scale_x_discrete() +\n  theme(axis.title.y = element_blank(),\n        axis.title.x = element_blank(),\n        axis.text.x = element_markdown(),\n        plot.title = element_text(hjust = 0.5)) +\n  transition_states(sample_size,\n                    transition_length = 1,\n                    state_length = 2) +\n  ease_aes('cubic-in-out') +\n  enter_fly(x_loc = 0, y_loc = 15) +\n  exit_fly(x_loc = 0, y_loc = 10)\n\n\n\n\n\n\n\n\n\n\n\nTo understand how to summarise data more transparently, let’s see how adding data points and distributions can help improve our visualisations."
  },
  {
    "objectID": "posts/2023-08-28_alternatives-to-box-plots/index.html#leaf-mass-per-area-lma",
    "href": "posts/2023-08-28_alternatives-to-box-plots/index.html#leaf-mass-per-area-lma",
    "title": "Alternatives to box plots: Using beeswarm and raincloud plots to summarise ecological data",
    "section": "Leaf mass per area (LMA)",
    "text": "Leaf mass per area (LMA)\nThe plant trait data we’ll download is leaf dry mass per area (LMA), which measures how big and dense a leaf is compared to its surface area. This example from Butrim & Royer (2020) shows that the small, dense leaf on the top has much higher LMA than the two large, light leaves on the bottom.\n\n\nLeaves from 34-33 million years ago, taken from a post by the Botanical Society of America\n\nLeaf mass per area is a morphological trait that can indicate a plant’s survival strategy. LMA can vary widely across species:\n\n\n\n\n\n\n High-LMA\n\n\n Medium-LMA\n\n\n Low-LMA\n\n\n\n\nLeft: Dodonaea stenozyga (Arthur Chapman CC-BY-NC-SA 4.0 (Int), Middle: Melaleuca decora (Greg Tasney CC-BY-SA 4.0 (Int)), Right: Drymophila cyanocarpa (Pete Woodall CC-BY-NC 4.0 (Int))\n\nOn one end of the spectrum, plants with small, dense leaves (High-LMA) acquire resources (like nutrients and energy) gradually and grow slowly, aiming to conserve what resources they have. These plants tend to have an advantage in unproductive environments, where they can efficiently store whatever limited resources are available.\nOn the other end of the spectrum, plants with big, light leaves (Low-LMA) acquire resources quickly and grow fast, aiming to out-compete others for the resources on offer. These plants tend to have an advantage in highly productive environments (where they can get lots of resources and use them quickly) (Poorter et al. 2009)."
  },
  {
    "objectID": "posts/2023-08-28_alternatives-to-box-plots/index.html#extract-trait-data",
    "href": "posts/2023-08-28_alternatives-to-box-plots/index.html#extract-trait-data",
    "title": "Alternatives to box plots: Using beeswarm and raincloud plots to summarise ecological data",
    "section": "Extract trait data",
    "text": "Extract trait data\nTo download LMA trait data, we’ll use extract_trait(). This downloads a list of data and metadata about authors, collection methods, locations, taxonomic information, and data structure. We’ll then use purrr::pluck() to grab the data.frame we want from our list.\n\n\n\n\n\n\nTip\n\n\n\nYou can use lookup_trait() to search for traits\n\n\n\n# lookup_trait(austraits, \"leaf_mass\")\n\n# Get trait data\nleaf_mass &lt;- austraits |&gt; \n  extract_trait(\"leaf_mass_per_area\") |&gt; \n  pluck(\"traits\")\n\nleaf_mass\n\n# A tibble: 27,946 × 24\n   dataset_id  taxon_name      observation_id trait_name value unit  entity_type\n   &lt;chr&gt;       &lt;chr&gt;           &lt;chr&gt;          &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;      \n 1 Ahrens_2019 Corymbia calop… 001            leaf_mass…  185. g/m2  individual \n 2 Ahrens_2019 Corymbia calop… 002            leaf_mass…  138. g/m2  individual \n 3 Ahrens_2019 Corymbia calop… 003            leaf_mass…  169. g/m2  individual \n 4 Ahrens_2019 Corymbia calop… 004            leaf_mass…  151. g/m2  individual \n 5 Ahrens_2019 Corymbia calop… 005            leaf_mass…  142. g/m2  individual \n 6 Ahrens_2019 Corymbia calop… 006            leaf_mass…  156. g/m2  individual \n 7 Ahrens_2019 Corymbia calop… 007            leaf_mass…  150. g/m2  individual \n 8 Ahrens_2019 Corymbia calop… 008            leaf_mass…  175. g/m2  individual \n 9 Ahrens_2019 Corymbia calop… 009            leaf_mass…  148. g/m2  individual \n10 Ahrens_2019 Corymbia calop… 010            leaf_mass…  135. g/m2  individual \n# ℹ 27,936 more rows\n# ℹ 17 more variables: value_type &lt;chr&gt;, basis_of_value &lt;chr&gt;,\n#   replicates &lt;chr&gt;, basis_of_record &lt;chr&gt;, life_stage &lt;chr&gt;,\n#   population_id &lt;chr&gt;, individual_id &lt;chr&gt;, temporal_id &lt;chr&gt;,\n#   source_id &lt;chr&gt;, location_id &lt;chr&gt;, entity_context_id &lt;chr&gt;, plot_id &lt;chr&gt;,\n#   treatment_id &lt;chr&gt;, collection_date &lt;chr&gt;, measurement_remarks &lt;chr&gt;,\n#   method_id &lt;chr&gt;, original_name &lt;chr&gt;"
  },
  {
    "objectID": "posts/2023-08-28_alternatives-to-box-plots/index.html#sample-species",
    "href": "posts/2023-08-28_alternatives-to-box-plots/index.html#sample-species",
    "title": "Alternatives to box plots: Using beeswarm and raincloud plots to summarise ecological data",
    "section": "Sample species",
    "text": "Sample species\nLet’s get a sample of our 6 species to summarise. To make sure that our sample species have enough data points to summarise, let’s filter leaf_mass to only taxa with at least 10 data points. To do this, we’ll count the number of data points by taxon_name, filter to only those with 10 data points or more, and use pull() to extract them. We’ll save this list of names as filtered_names.\n\n# get species with more than 10 records\nfiltered_names &lt;- leaf_mass |&gt;\n  group_by(taxon_name) |&gt;\n  count() |&gt;\n  filter(n &gt;= 10) |&gt;\n  pull(taxon_name)\n\nfiltered_names |&gt; head(10L)\n\n [1] \"Acacia acinacea\"       \"Acacia acuminata\"      \"Acacia anceps\"        \n [4] \"Acacia aneura\"         \"Acacia argyrophylla\"   \"Acacia aulacocarpa\"   \n [7] \"Acacia auriculiformis\" \"Acacia baileyana\"      \"Acacia bidwillii\"     \n[10] \"Acacia brachybotrya\"  \n\n\nNext we’ll filter our leaf_mass data to include only those in filtered_names.\n\nleaf_mass_filtered &lt;- leaf_mass |&gt;\n  filter(taxon_name %in% filtered_names)\n\nThis has removed more than 3,000 taxa from our dataset.\n\n\nCode\nn_taxa &lt;- leaf_mass |&gt; distinct(taxon_name) |&gt; count()\nn_taxa_filtered &lt;- leaf_mass_filtered |&gt; distinct(taxon_name) |&gt; count()\n\nn_taxa - n_taxa_filtered\n\n\n     n\n1 3196\n\n\nNext, let’s get a sample of these taxa to plot. One way to get a random sample of 6 taxa is to use filter to return data of only 6 unique taxa names.\n\nleaf_mass_filtered |&gt; \n  filter(taxon_name %in% sample(unique(taxon_name), 6))\n\nHere’s a random sample of taxa we prepared earlier, which we’ll specify just so we can look at some extra maps after we summarise our plant trait data as well. We’ll call our sample leaf_mass_sample.\n\nsample_names &lt;- c(\"Cryptocarya rigida\", \"Pteridium esculentum\", \n                  \"Eucalyptus baxteri\", \"Melaleuca armillaris\",\n                  \"Eucalyptus wandoo\", \"Eucalyptus piperita\")\n\nleaf_mass_sample &lt;- leaf_mass_filtered |&gt;\n  filter(taxon_name %in% sample_names)"
  },
  {
    "objectID": "posts/2023-08-28_alternatives-to-box-plots/index.html#footnotes",
    "href": "posts/2023-08-28_alternatives-to-box-plots/index.html#footnotes",
    "title": "Alternatives to box plots: Using beeswarm and raincloud plots to summarise ecological data",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nAre plots with bars or boxes any easier to read when oriented up and down (ie. vertically) than side-to-side (ie. horizontally)? You might not have an immediate answer, and so it’s slightly strange (when you think about it) how deep-set the trend of vertical barplots and box plots is in science. Flipping your plot can make longer names easier to read, make group differences easier to spot when stacked in order, and give space to other elements in your plot!↩︎\nFun fact: “How to make it rain” is an actual subheading in the paper↩︎\nIf you would like to add mean and confidence intervals (rather than median and quantile intervals) to your raincloud plot, you can use stat_pointinterval() to do this. However, {ggdist} calculates confidence intervals using a Bayesian method to find point estimates and Highest Density Intervals (HDI). This method returns different estimates to Frequentist confidence intervals, so it’s worth looking up the difference before using HDIs. If you are plotting estimates after running a model, the suggested way by the creator of {ggdist} is to pass this information using dist_student_t() and model parameters from broom::tidy() output. This stack overflow thread we found helpful for getting started.↩︎"
  },
  {
    "objectID": "posts/2024-01-25_hex_point_maps/index.html",
    "href": "posts/2024-01-25_hex_point_maps/index.html",
    "title": "Combining multiple species distributions on one map with hexagons and points",
    "section": "",
    "text": "Callum Waite\nShandiya Balasubramaniam\n\n\n\n25 January 2024\nVisualisations of species distributions can be very simple yet effective ways of conveying biological and ecological information, such as range, habitat, and relative population size.\nRepresenting more than one species distribution in a single figure can be difficult, though, especially where there are areas of overlap. Points and colour-filled polygons will obscure each other even with a degree of transparency, while densities and shaded regions can only show one species at a time.\nHere, we demonstrate a method to visualise distributions of multiple species with overlapping ranges on the same map, with only a small loss in resolution. The technique is a novel twist on the commonly used hexbin map: instead of using a colour fill to represent presence/absence or counts within each hexagon, we use multiple coloured points within each hexagon to represent presence/absence of species, allowing users to get a broad overview of how multiple species are distributed across an area.\nThis method requires a number of steps to build up the elements of the final figure:\nThe final figure will comprise a combination of the basemap, hex grid, and species points once these elements are created.\nLet’s begin by loading the R packages we’ll be using.\nlibrary(galah)\nlibrary(ggtext)\nlibrary(ozmaps)\nlibrary(sf)\nlibrary(showtext)\nlibrary(stringr)\nlibrary(tidyverse)\nWe’ll use the {galah} package to download occurrence records from the Atlas of Living Australia (ALA). To do this, you’ll need to register your email address with the ALA, then pass it to {galah} using galah_config().\ngalah_config(email = \"your-email@email.com\")"
  },
  {
    "objectID": "posts/2024-01-25_hex_point_maps/index.html#download-data",
    "href": "posts/2024-01-25_hex_point_maps/index.html#download-data",
    "title": "Combining multiple species distributions on one map with hexagons and points",
    "section": "Download data",
    "text": "Download data\nSince our goal here is to map distributions of multiple species, we’ve chosen honeyeaters from the genus Melithreptus: this is a distinctive group of 7 small- to medium-sized, short-billed and square-tailed honeyeaters with overlapping distributions across Australia.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLeft: Melithreptus gularis - Black-chinned Honeyeater (Graham Winterflood CC-BY-NC 4.0 (Int)), Middle: Melithreptus chloropsis - Gilbert’s Honeyeater (Wacrakey CC-BY-NC 4.0 (Int)), Right: Melithreptus validirostris - Strong-billed Honeyeater (Bird Explorers CC-BY-NC 4.0 (Int))\n\nWe can get taxonomic information about this group using atlas_species()…\n\nmelithreptus &lt;- galah_call() |&gt;\n  galah_identify(\"Melithreptus\") |&gt;\n  atlas_species()\n\nmelithreptus\n\n# A tibble: 7 × 10\n  species_guid            species author kingdom phylum class order family genus\n  &lt;chr&gt;                   &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;\n1 https://biodiversity.o… Melith… (Viei… Animal… Chord… Aves  Pass… Melip… Meli…\n2 https://biodiversity.o… Melith… (Vigo… Animal… Chord… Aves  Pass… Melip… Meli…\n3 https://biodiversity.o… Melith… Gould… Animal… Chord… Aves  Pass… Melip… Meli…\n4 https://biodiversity.o… Melith… (Goul… Animal… Chord… Aves  Pass… Melip… Meli…\n5 https://biodiversity.o… Melith… (Less… Animal… Chord… Aves  Pass… Melip… Meli…\n6 https://biodiversity.o… Melith… (Goul… Animal… Chord… Aves  Pass… Melip… Meli…\n7 https://biodiversity.o… Melith… Gould… Animal… Chord… Aves  Pass… Melip… Meli…\n# ℹ 1 more variable: vernacular_name &lt;chr&gt;\n\n\n… and then use this information to download occurrence records for the 7 species. We’ll apply a general set of ALA data quality filters to remove low quality records with galah_apply_profile(), and pass in the list of species we’re interested in with galah_identify(). We’ll also filter records to 20221, choosing only those with spatial coordinates and that fall within one of the IBRA bioregions (as a proxy for Australian records only).\n\nspecies_occ &lt;- galah_call() |&gt;\n  galah_apply_profile(ALA) |&gt;\n  galah_identify(melithreptus$species) |&gt;\n  galah_filter(year == 2022,\n               !is.na(cl1048),  # IBRA bioregions\n               !is.na(decimalLatitude),\n               !is.na(decimalLongitude)) |&gt;\n  galah_select(decimalLatitude,\n               decimalLongitude,\n               species, \n               scientificName) |&gt; \n  atlas_occurrences()\n\nhead(species_occ)\n\n\n\n# A tibble: 6 × 4\n  decimalLatitude decimalLongitude species                    scientificName    \n            &lt;dbl&gt;            &lt;dbl&gt; &lt;chr&gt;                      &lt;chr&gt;             \n1           -43.6             147. Melithreptus validirostris Melithreptus (Eid…\n2           -43.6             147. Melithreptus validirostris Melithreptus (Eid…\n3           -43.5             146. Melithreptus validirostris Melithreptus (Eid…\n4           -43.5             147. Melithreptus affinis       Melithreptus (Mel…\n5           -43.5             147. Melithreptus affinis       Melithreptus (Mel…\n6           -43.5             147. Melithreptus validirostris Melithreptus (Eid…\n\n\nSince we’re going to be performing a few spatial operations to assign species to hexagons, let’s convert the species_occ dataframe into a simple features (sf) object, with latitude and longitude columns represented as points in a geometry column named occ_geometry.\n\nspecies_occ_sf &lt;- species_occ |&gt;\n  st_as_sf(coords = c(\"decimalLongitude\", \"decimalLatitude\"), \n           crs = 4326) |&gt; \n  st_set_geometry(\"occ_geometry\")\n\nhead(species_occ_sf)\n\nSimple feature collection with 6 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 146.1362 ymin: -43.59761 xmax: 147.1435 ymax: -43.48602\nGeodetic CRS:  WGS 84\n# A tibble: 6 × 3\n  species                    scientificName                    occ_geometry\n  &lt;chr&gt;                      &lt;chr&gt;                              &lt;POINT [°]&gt;\n1 Melithreptus validirostris Melithreptus (Eidopsarus… (146.8627 -43.59761)\n2 Melithreptus validirostris Melithreptus (Eidopsarus… (146.8627 -43.59761)\n3 Melithreptus validirostris Melithreptus (Eidopsarus… (146.1362 -43.50299)\n4 Melithreptus affinis       Melithreptus (Melithrept… (147.1435 -43.49038)\n5 Melithreptus affinis       Melithreptus (Melithrept… (146.9424 -43.48602)\n6 Melithreptus validirostris Melithreptus (Eidopsarus… (146.9424 -43.48602)"
  },
  {
    "objectID": "posts/2024-01-25_hex_point_maps/index.html#generate-hex-grid",
    "href": "posts/2024-01-25_hex_point_maps/index.html#generate-hex-grid",
    "title": "Combining multiple species distributions on one map with hexagons and points",
    "section": "Generate hex grid",
    "text": "Generate hex grid\nNext, we’ll set up a grid of hexagons across Australia, which we’ll use as bins for plotting summaries of species occurrence.\nst_make_grid() can make a grid that covers the bounding box of the supplied shapefile (here the ozmap_country shapefile), with arguments for specifying the size, type, and orientation of polygons in a grid. We’ll transform the projection to match the coordinate reference system we set for the species occurrence records above (4326), and assign a unique identifier to each hexagon in a column named hex_id.\n\nhex_grid &lt;- st_make_grid(ozmap_country,\n                         cellsize = 2,\n                         what = \"polygons\",\n                         square = FALSE,\n                         flat_topped = TRUE) |&gt; \n  st_as_sf() |&gt; \n  st_set_geometry(\"hex_geometry\") |&gt; \n  st_transform(4326) |&gt; \n  rowid_to_column(var = \"hex_id\")\nhex_grid\n\nSimple feature collection with 703 features and 1 field\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 104.396 ymin: -45.63203 xmax: 170.7912 ymax: -7.632027\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   hex_id                   hex_geometry\n1       1 POLYGON ((106.128 -44.63203...\n2       2 POLYGON ((109.5921 -44.6320...\n3       3 POLYGON ((113.0562 -44.6320...\n4       4 POLYGON ((116.5203 -44.6320...\n5       5 POLYGON ((119.9844 -44.6320...\n6       6 POLYGON ((123.4485 -44.6320...\n7       7 POLYGON ((126.9126 -44.6320...\n8       8 POLYGON ((130.3767 -44.6320...\n9       9 POLYGON ((133.8408 -44.6320...\n10     10 POLYGON ((137.3049 -44.6320...\n\n\nOur grid of hexagons looks like this:\n\n\nCode\nggplot() +\n  geom_sf(data = ozmap_states, \n          colour = \"darkgrey\", \n          fill = NA, \n          linewidth = 0.3) +\n  geom_sf(data = hex_grid, \n          fill = NA, \n          col = \"deepskyblue4\", \n          linewidth = 0.2) +\n  theme_void()\n\n\n\n\n\n\n\n\n\n\nRemove empty hexes\nYou’ve probably noticed there are a lot of redundant hexagons in the grid we just created. Not every terrestrial hexagon will contain an occurrence record, and we can confidently assume hexagons in the ocean will not contain records of honeyeaters.\nWe’ll remove these empty hexagons with a spatial join (which behaves similarly to dplyr::left_join() for spatial objects). This returns a dataframe that has all the information from our original occurrence download, where each row is a record of a species in a particular location, but each record’s point location has now been matched to a hexagon from the grid we just created.\n\nhex_with_species &lt;- st_join(x = hex_grid, \n                            y = species_occ_sf,\n                            join = st_intersects,\n                            left = FALSE)\n\nhead(hex_with_species, n = 10)\n\nSimple feature collection with 10 features and 3 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 145.9652 ymin: -44.63203 xmax: 148.2746 ymax: -42.63203\nGeodetic CRS:  WGS 84\n     hex_id                    species                          scientificName\n32       32 Melithreptus validirostris Melithreptus (Eidopsarus) validirostris\n32.1     32 Melithreptus validirostris Melithreptus (Eidopsarus) validirostris\n32.2     32 Melithreptus validirostris Melithreptus (Eidopsarus) validirostris\n32.3     32       Melithreptus affinis     Melithreptus (Melithreptus) affinis\n32.4     32       Melithreptus affinis     Melithreptus (Melithreptus) affinis\n32.5     32 Melithreptus validirostris Melithreptus (Eidopsarus) validirostris\n32.6     32 Melithreptus validirostris Melithreptus (Eidopsarus) validirostris\n32.7     32 Melithreptus validirostris Melithreptus (Eidopsarus) validirostris\n32.8     32 Melithreptus validirostris Melithreptus (Eidopsarus) validirostris\n32.9     32       Melithreptus affinis     Melithreptus (Melithreptus) affinis\n                       hex_geometry\n32   POLYGON ((145.9652 -43.6320...\n32.1 POLYGON ((145.9652 -43.6320...\n32.2 POLYGON ((145.9652 -43.6320...\n32.3 POLYGON ((145.9652 -43.6320...\n32.4 POLYGON ((145.9652 -43.6320...\n32.5 POLYGON ((145.9652 -43.6320...\n32.6 POLYGON ((145.9652 -43.6320...\n32.7 POLYGON ((145.9652 -43.6320...\n32.8 POLYGON ((145.9652 -43.6320...\n32.9 POLYGON ((145.9652 -43.6320...\n\n\nThis means any hexagons we initially created in the grid that don’t intersect with occurrence records have been removed:\n\n\nCode\nggplot() +\n  geom_sf(data = ozmap_states, \n          colour = \"darkgrey\", \n          fill = NA, \n          linewidth = 0.3) +\n  geom_sf(data = count(hex_with_species, hex_id, hex_geometry), \n          fill = NA, \n          col = \"deepskyblue4\", \n          linewidth = 0.4) +\n  theme_void()\n\n\n\n\n\n\n\n\n\n\n\nVisualising multiple species in a hexagon\nAs some hexagons will contain occurrence records for more than one species, we need a way to display these overlaps. We’ll do this by setting up 7 positions in each hexagon, 1 for each species, and assign each species a position and colour so they can be visually differentiated.\nThe figure below summarises the process we’ll follow: for each hexagon remaining in the grid, we’ll generate a smaller hexagon, then get the coordinates of each vertex and centroid of the smaller hexagon. This gives us 7 positions to display up to 7 species in each hexagon.\n\n\n\n\n\n\n\n\n\n\n\n\n\nSet up 7 points\nLet’s start by extracting the unique identifiers and spatial coordinates for every hexagon containing an occurrence record2. Each hex_id refers to one of the remaining hexagons in our grid. This is step 1 from the figure above.\n\nunique_hex &lt;- hex_with_species |&gt; \n  count(hex_id, hex_geometry) |&gt; \n  select(-`n`)\nunique_hex\n\nSimple feature collection with 157 features and 1 field\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 113.0562 ymin: -44.63203 xmax: 155.2028 ymax: -9.632027\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   hex_id                   hex_geometry\n1      32 POLYGON ((145.9652 -43.6320...\n2      50 POLYGON ((144.2331 -42.6320...\n3      51 POLYGON ((147.6972 -42.6320...\n4      70 POLYGON ((145.9652 -41.6320...\n5      88 POLYGON ((144.2331 -40.6320...\n6      89 POLYGON ((147.6972 -40.6320...\n7     107 POLYGON ((142.5011 -39.6320...\n8     108 POLYGON ((145.9652 -39.6320...\n9     125 POLYGON ((140.769 -38.63203...\n10    126 POLYGON ((144.2331 -38.6320...\n\n\nNext, we’ll work through steps 2 - 4. Let’s create a smaller hexagon within each original hex using st_buffer(), extract the coordinates of its vertices using st_coordinates(), and assign an integer to each vertex ranging from 1 to 73. We’ve created an anonymous function to pipe these steps together, and used pmap() to apply this function iteratively to every hexagon in the grid.\n\n\n\n\n\n\nNote\n\n\n\n\n\nWe use the dist argument in st_buffer() to define the size of the smaller hexagon, but this depends on the cellsize of the original larger hexagon (in the six-hexagon figure, cellsize = 2). Depending on the number of species you’d like to fit within each polygon and the shape of the polygon you’ve chosen, you may need to try out different values of cellsize and dist to find combinations that work best for your visualisation.\n\n\n\n\nvertex_coords &lt;- unique_hex |&gt; \n  mutate(vertices = pmap(\n    .l = list(x = hex_geometry),\n    .f = function(x) {\n      x |&gt;\n        st_buffer(dist = -0.4) |&gt;         # STEP 2: set size of smaller hex\n        st_coordinates() |&gt;               # STEP 3: get vertex coordinates of smaller hex        \n        as_tibble() |&gt;                    # convert matrix to tibble  \n        st_as_sf(coords = c(\"X\", \"Y\")) |&gt; # convert tibble to simple features\n        select(-L1, -L2) |&gt;               # remove unnecessary columns\n        mutate(vertex_position = 1:7)     # STEP 4: number vertices \n    })) |&gt; \n  unnest(cols = vertices)\n\nhead(vertex_coords, n = 10)\n\nSimple feature collection with 10 features and 2 fields\nActive geometry column: hex_geometry\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 144.2331 ymin: -44.63203 xmax: 148.2746 ymax: -41.63203\nGeodetic CRS:  WGS 84\n# A tibble: 10 × 4\n   hex_id                 hex_geometry             geometry vertex_position\n    &lt;int&gt;                &lt;POLYGON [°]&gt;              &lt;POINT&gt;           &lt;int&gt;\n 1     32 ((145.9652 -43.63203, 146.5… (146.4271 -43.63203)               1\n 2     32 ((145.9652 -43.63203, 146.5… (146.7735 -43.03203)               2\n 3     32 ((145.9652 -43.63203, 146.5… (147.4663 -43.03203)               3\n 4     32 ((145.9652 -43.63203, 146.5… (147.8127 -43.63203)               4\n 5     32 ((145.9652 -43.63203, 146.5… (147.4663 -44.23203)               5\n 6     32 ((145.9652 -43.63203, 146.5… (146.7735 -44.23203)               6\n 7     32 ((145.9652 -43.63203, 146.5… (146.4271 -43.63203)               7\n 8     50 ((144.2331 -42.63203, 144.8…  (144.695 -42.63203)               1\n 9     50 ((144.2331 -42.63203, 144.8… (145.0414 -42.03203)               2\n10     50 ((144.2331 -42.63203, 144.8… (145.7342 -42.03203)               3\n\n\nIn the resulting dataframe, the hex_id and hex_geometry columns contain the unique ID and geometry of the original large hexagons from the grid. Meanwhile, the remaining columns contain information for our newly created smaller hexagons: the geometry column contains the spatial coordinates of each hexagon’s respective corner vertex, and vertex_position identifies each vertex point.\nWe’d like to show information of 7 species in our hexagon, but despite having 7 points in vertex_position, the 7th point contains the same information as the 1st point. This is so that, when drawn by lines, the hexagon is closed. However, because we are only interested drawing points, we can mutate the duplicated row of the 7th vertex to hold the coordinates of the centroid of each hexagon instead. This will gives us seven distinct positions (step 5 in our six-hexagon figure).\n\nvertex_centroid_coords &lt;- vertex_coords |&gt; \n  mutate(geometry = ifelse(vertex_position == 7,      \n                           st_centroid(hex_geometry), \n                           geometry)) |&gt; \n  st_drop_geometry() |&gt;                               \n  st_as_sf(crs = 4326)\n\nhead(vertex_centroid_coords, n = 10)\n\nSimple feature collection with 10 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 144.695 ymin: -44.23203 xmax: 147.8127 ymax: -42.03203\nGeodetic CRS:  WGS 84\n# A tibble: 10 × 3\n   hex_id             geometry vertex_position\n    &lt;int&gt;          &lt;POINT [°]&gt;           &lt;int&gt;\n 1     32 (146.4271 -43.63203)               1\n 2     32 (146.7735 -43.03203)               2\n 3     32 (147.4663 -43.03203)               3\n 4     32 (147.8127 -43.63203)               4\n 5     32 (147.4663 -44.23203)               5\n 6     32 (146.7735 -44.23203)               6\n 7     32 (147.1199 -43.63027)               7\n 8     50  (144.695 -42.63203)               1\n 9     50 (145.0414 -42.03203)               2\n10     50 (145.7342 -42.03203)               3"
  },
  {
    "objectID": "posts/2024-01-25_hex_point_maps/index.html#assign-species-to-positions",
    "href": "posts/2024-01-25_hex_point_maps/index.html#assign-species-to-positions",
    "title": "Combining multiple species distributions on one map with hexagons and points",
    "section": "Assign species to positions",
    "text": "Assign species to positions\nThe melithreptus dataframe (created earlier using atlas_species()) requires a small amount of tidying to be compatible with the rest of our data. The species column contains subgenera, which we can remove with regular expressions (regex)4. We also need to ensure all species have a vernacular name, noting that Melithreptus chloropsis is currently lacking one in the ALA database. We can then assign a number (1-7) denoting each species’ position in a hexagon5.\n\nspecies_data &lt;- melithreptus |&gt;\n  select(species, vernacular_name) |&gt;\n  mutate(species = str_replace_all(species, \"\\\\(.*?\\\\)\\\\s*\", \"\"),\n         vernacular_name = if_else(species == \"Melithreptus chloropsis\", \n                                   \"Gilbert's Honeyeater\",\n                                   vernacular_name),\n         vertex_position = c(1:7))\n\nspecies_data\n\n# A tibble: 7 × 3\n  species                    vernacular_name           vertex_position\n  &lt;chr&gt;                      &lt;chr&gt;                               &lt;int&gt;\n1 Melithreptus lunatus       White-naped Honeyeater                  1\n2 Melithreptus brevirostris  Brown-headed Honeyeater                 2\n3 Melithreptus albogularis   White-throated Honeyeater               3\n4 Melithreptus gularis       Black-chinned Honeyeater                4\n5 Melithreptus affinis       Black-headed Honeyeater                 5\n6 Melithreptus validirostris Strong-billed Honeyeater                6\n7 Melithreptus chloropsis    Gilbert's Honeyeater                    7\n\n\nOur final step is to bring these three dataframes (hex_with_species, species_data, vertex_centroid_coords) together with dplyr::left_join().\nWe begin by joining our distinct hexagon and species combinations (hex_with_species) with our species positions and common names (species_data) using the species column…\n\nspecies_points_a &lt;- hex_with_species |&gt;\n  st_drop_geometry() |&gt;\n  select(hex_id, species) |&gt;\n  distinct() |&gt; \n  left_join(species_data,\n            by = join_by(species))\n\nhead(species_points_a, n = 10)\n\n   hex_id                    species          vernacular_name vertex_position\n1      32 Melithreptus validirostris Strong-billed Honeyeater               6\n2      32       Melithreptus affinis  Black-headed Honeyeater               5\n3      50 Melithreptus validirostris Strong-billed Honeyeater               6\n4      50       Melithreptus affinis  Black-headed Honeyeater               5\n5      51 Melithreptus validirostris Strong-billed Honeyeater               6\n6      51       Melithreptus affinis  Black-headed Honeyeater               5\n7      70       Melithreptus affinis  Black-headed Honeyeater               5\n8      70 Melithreptus validirostris Strong-billed Honeyeater               6\n9      88 Melithreptus validirostris Strong-billed Honeyeater               6\n10     88       Melithreptus affinis  Black-headed Honeyeater               5\n\n\n…and follow this with another join to get the point coordinates of each species’ point in each hexagon (vertex_centroid_coords), using the vertex_position and hex_id columns.\n\nspecies_points &lt;- species_points_a |&gt;\n  left_join(vertex_centroid_coords,\n            by = join_by(vertex_position, hex_id)) |&gt; \n  st_as_sf(crs = 4326)\n\nhead(species_points, n = 10)\n\nSimple feature collection with 10 features and 4 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 145.0414 ymin: -44.23203 xmax: 149.1983 ymax: -41.23203\nGeodetic CRS:  WGS 84\n   hex_id                    species          vernacular_name vertex_position\n1      32 Melithreptus validirostris Strong-billed Honeyeater               6\n2      32       Melithreptus affinis  Black-headed Honeyeater               5\n3      50 Melithreptus validirostris Strong-billed Honeyeater               6\n4      50       Melithreptus affinis  Black-headed Honeyeater               5\n5      51 Melithreptus validirostris Strong-billed Honeyeater               6\n6      51       Melithreptus affinis  Black-headed Honeyeater               5\n7      70       Melithreptus affinis  Black-headed Honeyeater               5\n8      70 Melithreptus validirostris Strong-billed Honeyeater               6\n9      88 Melithreptus validirostris Strong-billed Honeyeater               6\n10     88       Melithreptus affinis  Black-headed Honeyeater               5\n                     geometry\n1  POINT (146.7735 -44.23203)\n2  POINT (147.4663 -44.23203)\n3  POINT (145.0414 -43.23203)\n4  POINT (145.7342 -43.23203)\n5  POINT (148.5055 -43.23203)\n6  POINT (149.1983 -43.23203)\n7  POINT (147.4663 -42.23203)\n8  POINT (146.7735 -42.23203)\n9  POINT (145.0414 -41.23203)\n10 POINT (145.7342 -41.23203)"
  },
  {
    "objectID": "posts/2024-01-25_hex_point_maps/index.html#map",
    "href": "posts/2024-01-25_hex_point_maps/index.html#map",
    "title": "Combining multiple species distributions on one map with hexagons and points",
    "section": "Map",
    "text": "Map\nLet’s check how our three spatial layers—basemap, hexagons, and species points—look on a map.\n\nggplot() +\n  geom_sf(data = ozmap_states, fill = NA) +\n  geom_sf(data = unique_hex, fill = NA) +\n  geom_sf(data = species_points, aes(colour = vernacular_name)) +\n  lims(x = c(112, 155), y = c(-46, -8)) +\n  theme_void()\n\n\n\n\n\n\n\n\nThis all looks correct! Now to add some final flourishes to make our map more aesthetically pleasing, as well as more accessible with a colourblind friendly palette by Paul Tol.\n\n\nCode\nfont_add_google(\"Montserrat\")\nshowtext_auto(enable = TRUE)\n\ntol_muted &lt;- c(\"#88CCEE\", \"#CC6677\", \"#DDCC77\", \"#117733\", \"#332288\", \"#AA4499\", \"#44AA99\")\n\nggplot() +\n  geom_sf(data = ozmap_states, \n          fill = NA, colour = \"#ababab\", linewidth = 0.3) +\n  geom_sf(data = unique_hex, \n          fill = \"#efefef55\", colour = \"#777777\", linewidth = 0.5) +\n  geom_sf(data = species_points, aes(colour = vernacular_name), \n          size = 2.3) +\n  scale_colour_manual(\n    values = tol_muted,\n    guide = guide_legend(title = \"*Melithreptus* &#0020; species\",\n                         override.aes = list(size = 4))\n  ) +\n  lims(x = c(112, 155), y = c(-46, -8)) +\n  theme_void() +\n  theme(legend.title = element_markdown(family = \"Montserrat\", size = 24),\n        legend.text = element_text(family = \"Montserrat\", size = 20),\n        legend.spacing.x = unit(0, \"in\"))"
  },
  {
    "objectID": "posts/2024-01-25_hex_point_maps/index.html#final-thoughts",
    "href": "posts/2024-01-25_hex_point_maps/index.html#final-thoughts",
    "title": "Combining multiple species distributions on one map with hexagons and points",
    "section": "Final Thoughts",
    "text": "Final Thoughts\nThis visualisation is a novel way to show range overlaps and distributions of multiple species at once. A key strength is the consistency of the repeatable hex unit—the fixed positions and colours of the species points make it easy to follow patterns within or between species.\nThis is also a very flexible method. It’s easy to customise:\n\nthe size, shape (hexagons vs squares) and orientation of the polygons\nthe colours and orientations of points within the hexagons, and\nthe spatial scale of the base map\n\nConsider also that you do not necessarily need to use exactly seven different species/taxa—with a bit of creativity, it is possible to fit any number of points from 2-9 into a hexagon (2-7) or square symmetrically…\n\n\n\n\n\n\n\n\n\n\n\nExpand for session info\n\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Australia.utf8\n ctype    English_Australia.utf8\n tz       Australia/Sydney\n date     2024-02-12\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n dplyr       * 1.1.4   2023-11-17 [1] CRAN (R 4.3.2)\n forcats     * 1.0.0   2023-01-29 [1] CRAN (R 4.3.2)\n galah       * 2.0.1   2024-02-06 [1] CRAN (R 4.3.2)\n ggplot2     * 3.4.4   2023-10-12 [1] CRAN (R 4.3.1)\n ggtext      * 0.1.2   2022-09-16 [1] CRAN (R 4.3.2)\n htmltools   * 0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n lubridate   * 1.9.3   2023-09-27 [1] CRAN (R 4.3.2)\n ozmaps      * 0.4.5   2021-08-03 [1] CRAN (R 4.3.2)\n patchwork   * 1.1.3   2023-08-14 [1] CRAN (R 4.3.1)\n purrr       * 1.0.2   2023-08-10 [1] CRAN (R 4.3.2)\n readr       * 2.1.4   2023-02-10 [1] CRAN (R 4.3.2)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n sf          * 1.0-14  2023-07-11 [1] CRAN (R 4.3.2)\n showtext    * 0.9-6   2023-05-03 [1] CRAN (R 4.3.2)\n showtextdb  * 3.0     2020-06-04 [1] CRAN (R 4.3.2)\n stringr     * 1.5.1   2023-11-14 [1] CRAN (R 4.3.2)\n sysfonts    * 0.8.8   2022-03-13 [1] CRAN (R 4.3.2)\n tibble      * 3.2.1   2023-03-20 [1] CRAN (R 4.3.2)\n tidyr       * 1.3.0   2023-01-24 [1] CRAN (R 4.3.2)\n tidyverse   * 2.0.0   2023-02-22 [1] CRAN (R 4.3.2)\n\n [1] C:/Users/KEL329/R-packages\n [2] C:/Users/KEL329/AppData/Local/Programs/R/R-4.3.2/library\n\n──────────────────────────────────────────────────────────────────────────────\n\n\n\n\n\n\n\nSteps to build a grid of points inside each hexagon\n\n\nDistribution of Honeyeater species"
  },
  {
    "objectID": "posts/2024-01-25_hex_point_maps/index.html#footnotes",
    "href": "posts/2024-01-25_hex_point_maps/index.html#footnotes",
    "title": "Combining multiple species distributions on one map with hexagons and points",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nThere are over half a million records from this genus in the ALA, so restricting our download to records from 2022 significantly speeds things up!↩︎\nUsing distinct() produces an identical result to count() here, but is far slower because checking for distinct values in the geometry column is computationally intensive. If your dataframe has fewer rows, you could also do this: hex_with_species |&gt; select(hex_id, hex_geometry) |&gt; distinct().↩︎\nEach hexagon is formed as a closed (rather than open) polygon, whereby the vertices are joined in the following order: 1-2-3-4-5-6-1. So although there are only 6 vertices, we get 7 sets of coordinates, with the first and seventh sets being duplicated to close the polygon.↩︎\nRegular expressions, or regex, are used to match specific patterns in strings. Here, we want to remove the inclusion of subgenera, parentheses, and any extra spaces in species names (e.g. \"Melithreptus (Melithreptus) affinis\" to \"Melithreptus  affinis\"), and we do this using species = str_replace_all(species, \"\\\\(.*?\\\\)\\\\s*\", \"\"). We’re looking for a sequence that starts with an opening parenthesis (\\\\(), is followed by any characters (.*?), and ends with a closing parenthesis (\\\\)). Any spaces following the closing parenthesis (\\\\s*) are also matched. Such sequences are replaced with an empty string (\"\"), effectively removing them.↩︎\nHere we assign the positions simply with vertex_position = c(1:7), however you can reorder the dataframe or this position vector to have more control over which point in the hexagon each species is assigned. For instance, you might wish to do this to separate similar colours within the hexagon, or to assign the most widely distributed species to the centre point.↩︎"
  },
  {
    "objectID": "posts/2024-04-30_sdm-tidymodels/index.html",
    "href": "posts/2024-04-30_sdm-tidymodels/index.html",
    "title": "An introduction to species distribution modelling using {tidysdm} & {tidymodels}",
    "section": "",
    "text": "Dax Kellie\nShandiya Balasubramaniam\n\n\n\n30 April 2024\nSpecies distribution models (SDMs) offer a way to quantify relationships between biodiversity observations and environmental variables, and are widely used in biogeography, conservation biology, and macroecology. SDMs allow us to assess how suitable an area is for a species, which has implications for predicting range shifts of invasive or threatened species, and understanding habitat suitability under different climate change scenarios.\nThe process of fitting and choosing the best model is iterative and, often, different modelling approaches are used to make multiple predictions that can be averaged to get a final result. Here, we walk through the steps of building a SDM for the laughing kookaburra in a small area of New South Wales, Australia, using tidymodels and tidysdm. tidymodels is a collection of packages for modelling using tidyverse principles, and tidysdm implements SDMs using the tidymodels framework.\nTo begin, we can load some packages.\nlibrary(galah)\nlibrary(tidyverse)\nlibrary(tidymodels) \nlibrary(tidysdm) # devtools::install_github(\"EvolEcolGroup/tidysdm\")\nlibrary(terra)\nlibrary(tidyterra)\nlibrary(here)\nlibrary(sf)\nlibrary(ozmaps)"
  },
  {
    "objectID": "posts/2024-04-30_sdm-tidymodels/index.html#download-data",
    "href": "posts/2024-04-30_sdm-tidymodels/index.html#download-data",
    "title": "An introduction to species distribution modelling using {tidysdm} & {tidymodels}",
    "section": "Download data",
    "text": "Download data\n\nDownload biological data\nOur model will use occurrence data of laughing kookaburras (Dacelo novaeguineae) in a small area in New South Wales. The laughing kookaburra is the largest Kingfisher in the world.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLeft: Dacelo (Dacelo) novaeguineae (craigc_86 CC-BY-NC 4.0 (Int)), Middle: Dacelo (Dacelo) novaeguineae (Wildash | questagame.com CC-BY-NC 4.0 (Int)), Right: Dacelo (Dacelo) novaeguineae (c_a_critter CC-BY-NC 4.0 (Int))\n\n\n\nThe laughing kookaburra also has one of the most recognisable bird calls. This video is an amazing example.\nWe’ll choose a region in New South Wales…\n\n# define geographic region\ncustom_bbox &lt;- tibble(ymin = -35, \n                      ymax = -32, \n                      xmin = 149, \n                      xmax = 152.1)\n\n\n\n\n\n\n\n\n\n\n\n\n…and download records from the ALA.\n\ngalah_config(email = \"your-email-here\") # Registered ALA email\n\n# download occurrence records\nkookaburras &lt;- galah_call() |&gt;\n  identify(\"Dacelo novaeguineae\") |&gt;\n  filter(year == 2023) |&gt;\n  galah_apply_profile(ALA) |&gt;\n  galah_geolocate(custom_bbox, type = \"bbox\") |&gt;\n  atlas_occurrences()\n\n\n\n\n\n\n\n\n\n\n\n\nFor many of the later steps we’ll need the coordinates formatted as a spatial object (i.e., geometry). So, let’s convert our occurrence data to a spatial object (sf) defined by the longitude and latitude coordinates, and set the Coordinate Reference System (CRS) to EPSG:43261 (WGS84).\n\n# convert to sf\nkookaburras_sf &lt;- kookaburras |&gt;\n  st_as_sf(coords = c(\"decimalLongitude\", \"decimalLatitude\")) |&gt;\n  st_set_crs(4326)\n\n\n\nDownload environmental data\nTo help with our model prediction, we’ll also download the BioClim variables, a list of 19 biologically relevant environmental variables, for all of Australia as a raster.\n\n\n\n\n\n\nWhat’s a raster?\n\n\n\n\n\nA raster is a spatial grid of cells, where each cell contains a value representing information such as temperature or elevation. This information is often visualised by mapping colours to values in the raster (see image below). The resolution of the raster depends on the size of cells within the grid, with smaller cells corresponding to higher resolution (just like how the resolution of a television screen is determined by the number of pixels).\n\n\nCode\nplot_raster &lt;- function(r) {\n  plot(r, axes = FALSE, legend = FALSE)\n  plot(as.polygons(r, dissolve = FALSE, trunc = FALSE), add = TRUE)\n  text(r, digits = 2)\n}\n\n# Create a 4 x 4 matrix\nm &lt;- matrix(1:16, ncol = 4, nrow = 4)\n# Convert the matrix into a raster\nr16 &lt;- rast(m)\n\nplot_raster(r16)\n\n\n\n\n\nThe colour of the cell/pixel is determined by the value assigned to it\n\n\n\n\n\n\n\n\n\n# Download world climate data\nbioclim &lt;- geodata::worldclim_country(\n    country = \"Australia\",\n    var = \"bio\",\n    res = 5,\n    path = here::here(\"folder-name\", \n                      \"subfolder-name\")\n  )\n\nTo narrow our BioClim data to only within the extent of our defined bounding box, we’ll create an extent object bbox_ext, then crop our bioclim layers to within bbox_ext and project our cropped BioClim data to the same CRS as our kookaburra occurrence points.\n\n# Set the coordinates to our bounding box\nbbox_ext &lt;- terra::ext(\n  c(custom_bbox[[\"xmin\"]], \n    custom_bbox[[\"xmax\"]], \n    custom_bbox[[\"ymin\"]], \n    custom_bbox[[\"ymax\"]]\n    ))\n\n# Crop our worldclim data to within our bounding box coordinates\naus &lt;- bioclim |&gt;\n  terra::crop(bbox_ext) |&gt;\n  terra::project(crs(\"EPSG:4326\"))\n\nTo make sure everything looks correct, let’s plot one of the variables with geom_spatraster() from the tidyterra package2.\n\n# Download NSW map, set CRS projection\nnsw &lt;- ozmaps::ozmap_states |&gt;\n  filter(NAME == \"New South Wales\") |&gt;\n  st_transform(crs = st_crs(4326))\n\n# Map of Annual temperature + points\nfirst_map &lt;- ggplot() +\n  geom_spatraster(data = aus,\n                  aes(fill = wc2.1_30s_bio_1)) +\n  geom_sf(data = kookaburras_sf,\n          colour = \"#312108\",\n          size = 2) +\n  scale_fill_whitebox_c(palette = \"muted\",\n                        na.value = NA) +\n  guides(fill = guide_colorbar(title = \"Annual Mean\\nTemperature\")) +\n  theme_void()\n\nfirst_map"
  },
  {
    "objectID": "posts/2024-04-30_sdm-tidymodels/index.html#prepare-data",
    "href": "posts/2024-04-30_sdm-tidymodels/index.html#prepare-data",
    "title": "An introduction to species distribution modelling using {tidysdm} & {tidymodels}",
    "section": "Prepare data",
    "text": "Prepare data\nNow that we have our occurrence data and environmental data, there are a few steps we’ll complete to prepare our data for modelling.\n\nThinning\nThe first step is to remove data where many points are overlapping. The resolution of our prediction is dependent on the resolution of our environmental data. If each cell in our environmental data defines the average value of one square kilometre, even if we had kookaburra observations at a higher resolution (for example, every square metre of our defined area), we can only detect differences to the lowest resolution of our grid cells.\nSo, we can thin our data so that there is only one observation per cell of our raster3. This step reduces spatial bias and lowers the risk that autocorrelation affects final predictions of our model.\n\n# thin\nset.seed(12345)\nkookaburras_thin &lt;- tidysdm::thin_by_cell(kookaburras_sf, \n                                          raster = aus\n                                          )\n\n# number of observations\ntibble(\n  before = nrow(kookaburras_sf),\n  after = nrow(kookaburras_thin)\n  )\n\n# A tibble: 1 × 2\n  before after\n   &lt;int&gt; &lt;int&gt;\n1   5624  1575\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPseudo-absences\nOur data from the ALA is presence-only data. So, the second step is to create pseudo-absences (also called background points) that represent the full extent of the area where kookaburras haven’t been observed (yet) in our data. Importantly, these are not the same as true absences and this should be taken into account when interpreting results4.\nLet’s add 3 times the number of presences to fill our grid, making sure they aren’t closer than 5 km to another point like our occurrence points.\n\nkookaburras_pseudoabs &lt;- tidysdm::sample_pseudoabs(\n  kookaburras_thin,\n  n = 3 * nrow(kookaburras_thin),\n  raster = aus,\n  method = c(\"dist_min\", km2m(5))\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExtract environmental values\nNow that we have our presence and pseudo-absence points, the third step is to extract the environmental data for each point location in aus and bind the resulting values to our points data in kookaburras_psuedoabs. The result is a tibble with our points, their class, and the specific values of all 19 BioClim variables.\n\nkookaburras_bioclim &lt;- kookaburras_pseudoabs |&gt; \n  bind_cols(\n    terra::extract(aus, \n                   kookaburras_pseudoabs, \n                   ID = FALSE)\n    )\nkookaburras_bioclim\n\nSimple feature collection with 6300 features and 20 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 149.0042 ymin: -34.99952 xmax: 152.0958 ymax: -32.00211\nGeodetic CRS:  WGS 84\n# A tibble: 6,300 × 21\n   class                geometry wc2.1_30s_bio_1 wc2.1_30s_bio_2\n * &lt;fct&gt;             &lt;POINT [°]&gt;           &lt;dbl&gt;           &lt;dbl&gt;\n 1 presence (151.1115 -33.66282)            16.6            9.32\n 2 presence (151.1556 -33.68888)            16.7            9.15\n 3 presence (149.7309 -34.75422)            13.4           12.8 \n 4 presence (150.4131 -33.72526)            13.2            9.78\n 5 presence (151.1531 -33.82185)            17.8            9.29\n 6 presence  (150.6711 -34.0971)            16.7           12.0 \n 7 presence (151.0117 -33.64909)            16.6           10.5 \n 8 presence (150.2013 -33.38858)            11.2            9.94\n 9 presence (150.4419 -34.62589)            12.9           10.1 \n10 presence  (150.1324 -33.3652)            11.2           10.1 \n# ℹ 6,290 more rows\n# ℹ 17 more variables: wc2.1_30s_bio_3 &lt;dbl&gt;, wc2.1_30s_bio_4 &lt;dbl&gt;,\n#   wc2.1_30s_bio_5 &lt;dbl&gt;, wc2.1_30s_bio_6 &lt;dbl&gt;, wc2.1_30s_bio_7 &lt;dbl&gt;,\n#   wc2.1_30s_bio_8 &lt;dbl&gt;, wc2.1_30s_bio_9 &lt;dbl&gt;, wc2.1_30s_bio_10 &lt;dbl&gt;,\n#   wc2.1_30s_bio_11 &lt;dbl&gt;, wc2.1_30s_bio_12 &lt;dbl&gt;, wc2.1_30s_bio_13 &lt;dbl&gt;,\n#   wc2.1_30s_bio_14 &lt;dbl&gt;, wc2.1_30s_bio_15 &lt;dbl&gt;, wc2.1_30s_bio_16 &lt;dbl&gt;,\n#   wc2.1_30s_bio_17 &lt;dbl&gt;, wc2.1_30s_bio_18 &lt;dbl&gt;, wc2.1_30s_bio_19 &lt;dbl&gt;\n\n\n\n\nSelect predictor variables\nThe fourth and final step is to choose predictor variables for our model. These are variables we think explain variation in our outcome (i.e., the probability a kookaburra could live in a given location). When choosing predictor variables, it is good practice to use theory and previous research to inform what variables you choose as predictors5.\n\n\n\n\n\n\nChoosing variables and avoiding multicollinearity\n\n\n\n\n\nIn species distribution models, multicollinearity—high correlation between several independent variables in a model—can have unintended effects that bias predictions6. Data science tools can also help refine your predictor variable choices, too, including some functions in tidysdm that we used below.\nA good start is to choose variables that differentiate between presences and pseudo-absences, which in the plot below are variables that have less overlap between red and blue distributions. To help choose variables with the highest non-overlapping distribution, we can decide on a percentage cut-off of 55% non-overlap, leaving us with the top 3 variables in the table below.\n\nPlotTable\n\n\n\n\nCode\nkookaburras_bioclim |&gt;\n  rename_with(\n    ~ str_remove_all(.x, \"wc2.1_30s_\"), \n    starts_with(\"wc2.1_30s_\")) |&gt;\n  plot_pres_vs_bg(class)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\noverlap &lt;- kookaburras_bioclim |&gt;\n  dist_pres_vs_bg(class) |&gt;\n  enframe(\"bioclim\", \"percent_non_overlap\") |&gt;\n  arrange(desc(percent_non_overlap))\n\noverlap |&gt; gt::gt()\n\n\n\n\n\n\n\n\nbioclim\npercent_non_overlap\n\n\n\n\nwc2.1_30s_bio_12\n0.5638973\n\n\nwc2.1_30s_bio_4\n0.5600276\n\n\nwc2.1_30s_bio_16\n0.5534120\n\n\nwc2.1_30s_bio_11\n0.5394637\n\n\nwc2.1_30s_bio_6\n0.5210402\n\n\nwc2.1_30s_bio_7\n0.5113068\n\n\nwc2.1_30s_bio_13\n0.4997009\n\n\nwc2.1_30s_bio_9\n0.4827577\n\n\nwc2.1_30s_bio_18\n0.4820482\n\n\nwc2.1_30s_bio_1\n0.4599437\n\n\nwc2.1_30s_bio_2\n0.4581933\n\n\nwc2.1_30s_bio_17\n0.4464991\n\n\nwc2.1_30s_bio_19\n0.4221545\n\n\nwc2.1_30s_bio_15\n0.4202146\n\n\nwc2.1_30s_bio_14\n0.4099419\n\n\nwc2.1_30s_bio_8\n0.3411940\n\n\nwc2.1_30s_bio_10\n0.3182850\n\n\nwc2.1_30s_bio_5\n0.2343475\n\n\nwc2.1_30s_bio_3\n0.1002332\n\n\n\n\n\n\n\n\n\n\nNow we can use pair plots to view the relationship between each pair of variables. Variables bio_12 and bio_16 are very highly correlated (94%). To avoid multicollinearity in our model, we’ll include only bio_12 (annual precipitation) and bio_4 (temperature seasonality).\n\n\nCode\naus |&gt;\n  select(wc2.1_30s_bio_12, \n         wc2.1_30s_bio_4, \n         wc2.1_30s_bio_16) |&gt;\n  terra::pairs()\n\n\n\n\n\n\n\n\n\n\n\n\nHere, we selected two BioClim variables that we thought were reasonable environmental predictors (using mainly data science techniques):\n\nBIO4: Temperature Seasonality7\nBIO12: Annual Precipitation\n\nWe’ll filter our point data and BioClim raster data to only include our two variables.\n\n# predictor variable names\nvars &lt;- c(\"wc2.1_30s_bio_4\", \"wc2.1_30s_bio_12\")\n\n# filter point data columns\nkookaburras_bioclim_filtered &lt;- \n  kookaburras_bioclim |&gt; \n  select(all_of(c(vars, \"class\")))\n\nkookaburras_bioclim_filtered |&gt; head(5L)\n\nSimple feature collection with 5 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 149.7309 ymin: -34.75422 xmax: 151.1556 ymax: -33.66282\nGeodetic CRS:  WGS 84\n# A tibble: 5 × 4\n  wc2.1_30s_bio_4 wc2.1_30s_bio_12 class                geometry\n            &lt;dbl&gt;            &lt;dbl&gt; &lt;fct&gt;             &lt;POINT [°]&gt;\n1            391.             1204 presence (151.1115 -33.66282)\n2            390.             1275 presence (151.1556 -33.68888)\n3            504.              673 presence (149.7309 -34.75422)\n4            424.             1273 presence (150.4131 -33.72526)\n5            393.             1164 presence (151.1531 -33.82185)\n\n\n\n# filter bioclim data columns\naus_filtered &lt;- aus[[vars]]\naus_filtered\n\nclass       : SpatRaster \ndimensions  : 360, 372, 2  (nrow, ncol, nlyr)\nresolution  : 0.008333333, 0.008333333  (x, y)\nextent      : 149, 152.1, -35, -32  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource(s)   : memory\nnames       : wc2.1_30s_bio_4, wc2.1_30s_bio_12 \nmin values  :        306.3223,              620 \nmax values  :        582.4574,             1657 \n\n\n\n\nCode\nbioclim4 &lt;- ggplot() +\n  geom_spatraster(data = aus_filtered,\n                  aes(fill = wc2.1_30s_bio_4)) +\n  geom_rect(data = custom_bbox,\n            mapping = aes(xmin = xmin, \n                          ymin = ymin, \n                          xmax = xmax, \n                          ymax = ymax),\n            colour = \"grey50\",\n            fill = NA) +  \n  scale_fill_whitebox_c(palette = \"muted\",\n                        na.value = NA) +\n  guides(fill = guide_colorbar(title = \"Annual Range in\\nTemperature\\n(°C)\")) +\n  theme_void()\n\nbioclim12 &lt;- ggplot() +\n  geom_spatraster(data = aus_filtered,\n                  aes(fill = wc2.1_30s_bio_12)) +\n  geom_rect(data = custom_bbox,\n            mapping = aes(xmin = xmin, \n                          ymin = ymin, \n                          xmax = xmax, \n                          ymax = ymax),\n            colour = \"grey50\",\n            fill = NA) +  \n  scale_fill_whitebox_c(palette = \"deep\",\n                        na.value = NA) +\n  guides(fill = guide_colorbar(title = \"Precipitation (mm)\")) +\n  theme_void()\n\n\n\n\n\n\n\n\n\n\n\nBioClim 4: Temperature Seasonality\n\n\n\n\n\n\n\nBioClim 12: Annual Precipitation"
  },
  {
    "objectID": "posts/2024-04-30_sdm-tidymodels/index.html#fit-model",
    "href": "posts/2024-04-30_sdm-tidymodels/index.html#fit-model",
    "title": "An introduction to species distribution modelling using {tidysdm} & {tidymodels}",
    "section": "Fit model",
    "text": "Fit model\nTidymodels is designed to build a model workflow, train the model’s performance, then test the model’s ability to predict data accurately. This workflow might be slightly different to what many research scientists are used to.\nIn machine learning models, data is like a limited resource that we must divide using a “data budget” for two main purposes: training a reasonable model, and testing the final model.\n\nSplit data\nThe first step to allocating your “data budget” is splitting your data. We can use initial_split() to allocate a reasonable “data budget” into these categories (typically a 75-25% split).\n\n# set training and testing data\nset.seed(100)\n\nkookaburras_split &lt;- \n  kookaburras_bioclim_filtered |&gt;\n  initial_split()\nkookaburras_split\n\n&lt;Training/Testing/Total&gt;\n&lt;4725/1575/6300&gt;\n\n\nNow we can save these data as separate data objects for training() and testing().\n\nkookaburras_train &lt;- training(kookaburras_split)\nkookaburras_test &lt;- testing(kookaburras_split)\n\nWe are left with two dataframes with identical columns but different points.\n\nTrainTest\n\n\n\nkookaburras_train |&gt; head(5L)\n\nSimple feature collection with 5 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 149.0125 ymin: -34.21327 xmax: 150.894 ymax: -32.3875\nGeodetic CRS:  WGS 84\n# A tibble: 5 × 4\n  wc2.1_30s_bio_4 wc2.1_30s_bio_12 class                 geometry\n            &lt;dbl&gt;            &lt;dbl&gt; &lt;fct&gt;              &lt;POINT [°]&gt;\n1            498.              648 pseudoabs  (150.4792 -32.3875)\n2            374.             1442 presence   (150.894 -34.21327)\n3            561.              693 pseudoabs  (149.0125 -32.7875)\n4            486.              835 pseudoabs (150.1625 -32.72917)\n5            435.              890 pseudoabs  (150.7542 -33.1125)\n\n\n\n\n\nkookaburras_test |&gt; head(5L)\n\nSimple feature collection with 5 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 149.6909 ymin: -33.82185 xmax: 151.6858 ymax: -32.9229\nGeodetic CRS:  WGS 84\n# A tibble: 5 × 4\n  wc2.1_30s_bio_4 wc2.1_30s_bio_12 class                geometry\n            &lt;dbl&gt;            &lt;dbl&gt; &lt;fct&gt;             &lt;POINT [°]&gt;\n1            393.             1164 presence (151.1531 -33.82185)\n2            461.             1085 presence (150.2013 -33.38858)\n3            513.              802 presence (149.6909 -33.14061)\n4            408.             1144 presence  (151.6858 -32.9229)\n5            463.             1073 presence (150.1981 -33.37893)\n\n\n\n\n\n\n\nResampling\nNow let’s resample our training data so we can use it to optimise and evaluate our model. One way to resample is using cross-validation, a well-established method of resampling that randomly assigns points to analysis and assessment groups. These randomly resampled and split data sets are known as folds. We can use the spatialsample package to create 5 v-folds with spatial_block_cv(), a function for resampling spatial data.\n\nset.seed(100)\nkookaburras_cv &lt;- spatial_block_cv(kookaburras_train, v = 5)\n\nspatial_block_cv() uses a type of resampling called block cross-validation, which creates a grid of “blocks” and attempts to maintain these blocked groups when resampling data points. Block cross-validation is important because spatial data is not completely random; data from neighbouring locations probably relate in some way (they aren’t completely random), and block cross-validation attempts to preserve this spatial relationship. The plots below demonstrate the general process. The plot on the left shows the blocks, the animation on the right shows the resulting 5 folds.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDefine our model\nNext let’s make our model’s “recipe”. This is the tidymodels term for any pre-processing steps that happen to our data before adding them to a model. A recipe includes our model formula, and any transformations or standardisations we might wish to do8.\nIn our case, let’s define that our model’s outcome variable is the class of presence or absence. We’ll then add our predictor variables to our model, with the formula class ~ ., equivalent to class ~ bio4 + bio12.\n\nkookaburras_recipe &lt;- recipe(\n  kookaburras_train, \n  formula = class ~ .\n  )\nkookaburras_recipe\n\n\n\n\n── Recipe ──────────────────────────────────────────────────────────────────────\n\n\n\n\n\n── Inputs \n\n\nNumber of variables by role\n\n\noutcome:   1\npredictor: 2\ncoords:    2\n\n\nNow we can set our workflow, which merges our formula, any data pre-processing, and specifies which models we’ll use. One of the strengths of using tidymodels is that we can run several different types of models in a single workflow_set() to train and optimise them.\n\nkookaburras_models &lt;-\n  # create the workflow_set\n  workflow_set(\n    preproc = list(default = kookaburras_recipe),\n    models = list(\n      glm = sdm_spec_glm(),        # the standard glm specs\n      rf = sdm_spec_rf(),          # rf specs with tuning\n      gbm = sdm_spec_boost_tree(), # boosted tree model (gbm) specs with tuning\n      maxent = sdm_spec_maxent()   # maxent specs with tuning\n    ),\n    cross = TRUE # make all combinations of preproc and models\n  ) |&gt;\n  # tweak controls to store information needed later to create the ensemble\n  option_add(control = control_ensemble_grid())\n\nkookaburras_models\n\n# A workflow set/tibble: 4 × 4\n  wflow_id       info             option    result    \n  &lt;chr&gt;          &lt;list&gt;           &lt;list&gt;    &lt;list&gt;    \n1 default_glm    &lt;tibble [1 × 4]&gt; &lt;opts[1]&gt; &lt;list [0]&gt;\n2 default_rf     &lt;tibble [1 × 4]&gt; &lt;opts[1]&gt; &lt;list [0]&gt;\n3 default_gbm    &lt;tibble [1 × 4]&gt; &lt;opts[1]&gt; &lt;list [0]&gt;\n4 default_maxent &lt;tibble [1 × 4]&gt; &lt;opts[1]&gt; &lt;list [0]&gt;\n\n\n\n\nFit our model\nNext we will determine what parameters optimise our model’s performance by tuning our model. Tuning uses trial-and-error to figure out which type of model under what hyperparameters makes reasonable predictions.\nLet’s tune our models using our resampled folds (kookaburras_cv).\n\n\n\n\n\n\nHow does tuning work?\n\n\n\n\n\nTuning is the process of simulating many different ways to fit lines made by our models to our training data. The number of curves in a model’s line of best fit increases as a model becomes more complex, determined by its degrees of freedom. By using different functions to set reasonable weighting parameters that penalize a model when lines curve too much, tuning optimises the model’s performance by finding the balance between fitting our current training data and predicting new values correctly. For more information and a visual of this, check out the tunes package Getting Started vignette.\n\n\n\n\nset.seed(2345678) # for reproducability\n\nkookaburras_models_tune &lt;-\n  kookaburras_models |&gt;\n  workflow_map(\"tune_grid\",\n    resamples = kookaburras_cv, \n    grid = 6,                   # increase for more iterations\n    metrics = sdm_metric_set(),\n    verbose = TRUE,\n    control = stacks::control_stack_grid()\n  )\n\nkookaburras_models_tune\n\n# A workflow set/tibble: 4 × 4\n  wflow_id       info             option    result   \n  &lt;chr&gt;          &lt;list&gt;           &lt;list&gt;    &lt;list&gt;   \n1 default_glm    &lt;tibble [1 × 4]&gt; &lt;opts[4]&gt; &lt;rsmp[+]&gt;\n2 default_rf     &lt;tibble [1 × 4]&gt; &lt;opts[4]&gt; &lt;tune[+]&gt;\n3 default_gbm    &lt;tibble [1 × 4]&gt; &lt;opts[4]&gt; &lt;tune[+]&gt;\n4 default_maxent &lt;tibble [1 × 4]&gt; &lt;opts[4]&gt; &lt;tune[+]&gt;\n\nbeepr::beep(2)\n\nWe can use autoplot() to visualise which models performed best by a set of common performance metrics for species distribution models. Models with higher values and smaller confidence intervals performed better.\n\nautoplot(kookaburras_models_tune)\n\n\n\n\n\n\n\n\nWe can also collect each model’s metrics and rank the models by performance.\n\n# see metrics\n1collect_metrics(kookaburras_models_tune)\n\n\n1\n\nAs a general tidymodels tip, many columns with a . at the start of its column name can be retrieved with a collect_ function (e.g., collect_metrics(), collect_parameters()).\n\n\n\n\n# A tibble: 45 × 9\n   wflow_id    .config      preproc model .metric .estimator  mean     n std_err\n   &lt;chr&gt;       &lt;chr&gt;        &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;   &lt;dbl&gt;\n 1 default_glm Preprocesso… spatia… logi… boyce_… binary     0.890     5  0.0374\n 2 default_glm Preprocesso… spatia… logi… roc_auc binary     0.861     5  0.0327\n 3 default_glm Preprocesso… spatia… logi… tss_max binary     0.633     5  0.0617\n 4 default_rf  Preprocesso… spatia… rand… boyce_… binary     0.753     5  0.0907\n 5 default_rf  Preprocesso… spatia… rand… roc_auc binary     0.792     5  0.0400\n 6 default_rf  Preprocesso… spatia… rand… tss_max binary     0.493     5  0.0681\n 7 default_rf  Preprocesso… spatia… rand… boyce_… binary     0.761     5  0.0841\n 8 default_rf  Preprocesso… spatia… rand… roc_auc binary     0.799     5  0.0394\n 9 default_rf  Preprocesso… spatia… rand… tss_max binary     0.505     5  0.0670\n10 default_gbm Preprocesso… spatia… boos… boyce_… binary     0.745     5  0.107 \n# ℹ 35 more rows\n\n\nOur tuning results show that several types of models and parameters performed quite well. Rather than choosing only one model to use for predictions, it’s possible to use several as a “stacked ensemble model”! The stacks package in tidymodels let’s us blend predictions of a few good candidate models (based on whatever metric you choose) to make better overall estimates9.\n\nlibrary(stacks)\nset.seed(123456)\n\nkookaburras_stacked &lt;- \n  stacks() |&gt;                                # initialize the stack\n  add_candidates(kookaburras_models_tune) |&gt; # add candidate members\n  blend_predictions() |&gt;                     # determine how to combine their predictions\n  fit_members()                              # fit the candidates with nonzero stacking coefficients\n\nkookaburras_stacked\n\n# A tibble: 2 × 3\n  member                             type         weight\n  &lt;chr&gt;                              &lt;chr&gt;         &lt;dbl&gt;\n1 .pred_pseudoabs_default_maxent_1_1 maxent        2.25 \n2 .pred_pseudoabs_default_glm_1_1    logistic_reg  0.875\n\n\nHere is a nice visual of how these two member models are weighted to inform our predictions.\n\nautoplot(kookaburras_stacked, type = \"weights\")"
  },
  {
    "objectID": "posts/2024-04-30_sdm-tidymodels/index.html#assess-model",
    "href": "posts/2024-04-30_sdm-tidymodels/index.html#assess-model",
    "title": "An introduction to species distribution modelling using {tidysdm} & {tidymodels}",
    "section": "Assess model",
    "text": "Assess model\nOur model kookaburras_stacked is now ready, and we can use it to make predictions about our test data. We’ll bind the predicted values to the true values of our test data…\n\nkookaburras_test_predictions &lt;-\n  kookaburras_test %&gt;%\n  bind_cols(predict(kookaburras_stacked, ., \n                    type = \"prob\", \n                    save_pred = TRUE))\n\n…which allows us to assess how good our model is at making correct predictions of the “true” classes.\n\nkookaburras_test_predictions |&gt; \n  sdm_metric_set()(truth = class, .pred_presence)\n\n# A tibble: 3 × 3\n  .metric    .estimator .estimate\n  &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt;\n1 boyce_cont binary         0.968\n2 roc_auc    binary         0.848\n3 tss_max    binary         0.565\n\n\nWe can also visualise how well the model has correctly predicted the class of each point by predicting \"class\" rather than \"prob\" and mapping correct vs incorrect predictions.\n\n\nCode\n# predict class\nkookaburras_test_predictions_class &lt;-\n  kookaburras_test %&gt;%\n  bind_cols(predict(kookaburras_stacked, ., \n                    type = \"class\", \n                    save_pred = TRUE))\n\n# plot correct vs incorrect predictions\nkookaburras_test_predictions_class |&gt;\n  mutate(correct = case_when(\n    class == .pred_class ~ \"Correct\",\n    TRUE ~ \"Incorrect\"\n  )) |&gt;\n  ggplot() +\n  geom_sf(aes(geometry = geometry, colour = correct)) +\n  labs(color = NULL) +\n  scale_color_manual(values = c(\"darkred\", \"lightpink\")) + \n  geom_spatraster(data = aus,\n                  aes(fill = wc2.1_30s_bio_4),\n                  alpha = 0.1) +\n  scale_fill_whitebox_c(palette = \"muted\",\n                        na.value = NA) +\n  theme_void()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntidysdm wrapper functions\n\n\n\n\n\ntidysdm offers its own wrapper function simple_ensemble() to run a stack model workflow and some helpful ways to assess their performance.\n\n\n\n\nFinal prediction\nFinally, we can use our model to predict the habitat suitability of laughing kookaburras over our area. We’ll predict an entire surface of values within our aus_filtered area using the incredible predict_raster() function from tidysdm (which saves us quite a few wrangling steps to work nicely with terra).\n\n# predict\nprediction_present &lt;- predict_raster(kookaburras_stacked, \n                                     aus_filtered, \n                                     type = \"prob\")\n\n# map\nggplot() +\n  geom_spatraster(data = prediction_present, \n                  aes(fill = .pred_presence)) +\n  scale_fill_whitebox_c(palette = \"purple\",\n                        na.value = NA) +\n  guides(\n    fill = guide_colorbar(title=\"Relative\\nHabitat\\nSuitability\")\n    ) +\n\n  # plot presences used in the model\n  geom_sf(data = kookaburras_sf,\n          alpha = 0.3) +\n  labs(title=\"Predicted distribution of laughing kookaburras\") +\n  pilot::theme_pilot(grid=\"hv\") +\n  theme(\n    legend.text = element_text(hjust = 0.5)\n  )\n\n\n\n\n\n\n\n\nAnd there we have our predictions of our species distribution model!"
  },
  {
    "objectID": "posts/2024-04-30_sdm-tidymodels/index.html#final-thoughts",
    "href": "posts/2024-04-30_sdm-tidymodels/index.html#final-thoughts",
    "title": "An introduction to species distribution modelling using {tidysdm} & {tidymodels}",
    "section": "Final thoughts",
    "text": "Final thoughts\nWe hope this article has made the steps of species distribution modelling and interpretation clearer. Species distribution models remain one of the most powerful statistical tools for making inferences about species and their habitat range. tidymodels, tidysdm, and tidyterra offer a useful toolset for running these models in R.\nAlthough our model performed decently under several model performance metrics, no model is perfect. For example, you can see that many of the values towards the centre of Australia have low relative habitat suitability despite quite a few kookaburra occurrences. This is a limitation likely caused by our data and our choice of predictor variables. Testing different subsets of predictors and trying environmental layers at different levels of spatial resolution will help to improve the performance of the model. Another option (if collecting more data is not feasible) is to explore other datasets that could be aggregated to enhance the quality of training data.\nOur model above is quite minimalist (for simplicity). If you’d like an example list of variables used in more performant models, check out this paper.\nTo learn more on ALA Labs, check out our posts on spatial bias and mapping multiple overlapping species distributions.\n\n\nExpand for session info\n\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Australia.utf8\n ctype    English_Australia.utf8\n tz       Australia/Sydney\n date     2024-05-02\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package       * version date (UTC) lib source\n broom         * 1.0.5   2023-06-09 [1] CRAN (R 4.3.1)\n dials         * 1.2.0   2023-04-03 [1] CRAN (R 4.3.2)\n dplyr         * 1.1.4   2023-11-17 [1] CRAN (R 4.3.2)\n forcats       * 1.0.0   2023-01-29 [1] CRAN (R 4.3.2)\n galah         * 2.0.2   2024-04-12 [1] CRAN (R 4.3.3)\n ggplot2       * 3.4.4   2023-10-12 [1] CRAN (R 4.3.1)\n glmnet        * 4.1-8   2023-08-22 [1] CRAN (R 4.3.1)\n here          * 1.0.1   2020-12-13 [1] CRAN (R 4.3.2)\n htmltools     * 0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n infer         * 1.0.5   2023-09-06 [1] CRAN (R 4.3.1)\n lubridate     * 1.9.3   2023-09-27 [1] CRAN (R 4.3.2)\n Matrix        * 1.6-4   2023-11-30 [1] CRAN (R 4.3.2)\n maxnet        * 0.1.4   2021-07-09 [1] CRAN (R 4.3.2)\n modeldata     * 1.2.0   2023-08-09 [1] CRAN (R 4.3.1)\n ozmaps        * 0.4.5   2021-08-03 [1] CRAN (R 4.3.2)\n parsnip       * 1.1.1   2023-08-17 [1] CRAN (R 4.3.1)\n purrr         * 1.0.2   2023-08-10 [1] CRAN (R 4.3.2)\n ranger        * 0.16.0  2023-11-12 [1] CRAN (R 4.3.2)\n readr         * 2.1.5   2024-01-10 [1] CRAN (R 4.3.3)\n recipes       * 1.0.8   2023-08-25 [1] CRAN (R 4.3.1)\n rsample       * 1.2.0   2023-08-23 [1] CRAN (R 4.3.1)\n scales        * 1.3.0   2023-11-28 [1] CRAN (R 4.3.2)\n sessioninfo   * 1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n sf            * 1.0-16  2024-03-24 [1] CRAN (R 4.3.3)\n spatialsample * 0.5.1   2023-11-08 [1] CRAN (R 4.3.2)\n stacks        * 1.0.3   2023-11-06 [1] CRAN (R 4.3.3)\n stringr       * 1.5.1   2023-11-14 [1] CRAN (R 4.3.2)\n terra         * 1.7-55  2023-10-13 [1] CRAN (R 4.3.1)\n tibble        * 3.2.1   2023-03-20 [1] CRAN (R 4.3.2)\n tidymodels    * 1.1.1   2023-08-24 [1] CRAN (R 4.3.1)\n tidyr         * 1.3.1   2024-01-24 [1] CRAN (R 4.3.3)\n tidysdm       * 0.9.2   2023-11-13 [1] CRAN (R 4.3.2)\n tidyterra     * 0.5.0   2023-11-21 [1] CRAN (R 4.3.2)\n tidyverse     * 2.0.0   2023-02-22 [1] CRAN (R 4.3.2)\n tune          * 1.1.2   2023-08-23 [1] CRAN (R 4.3.1)\n workflows     * 1.1.3   2023-02-22 [1] CRAN (R 4.3.2)\n workflowsets  * 1.0.1   2023-04-06 [1] CRAN (R 4.3.2)\n xgboost       * 1.7.6.1 2023-12-06 [1] CRAN (R 4.3.1)\n yardstick     * 1.2.0   2023-04-21 [1] CRAN (R 4.3.2)\n\n [1] C:/Users/KEL329/R-packages\n [2] C:/Users/KEL329/AppData/Local/Programs/R/R-4.3.2/library\n\n──────────────────────────────────────────────────────────────────────────────\n\n\n\n\n\n\n\nPredicted distribution of laughing kookaburras"
  },
  {
    "objectID": "posts/2024-04-30_sdm-tidymodels/index.html#footnotes",
    "href": "posts/2024-04-30_sdm-tidymodels/index.html#footnotes",
    "title": "An introduction to species distribution modelling using {tidysdm} & {tidymodels}",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nALA data is projected using CRS EPSG:4326 (the same one used by Google Earth).↩︎\ntidyterra follows the Grammar of Graphics made popular in R by ggplot2 and allows rasters to be plotted using the same syntax. In contrast, the terra package requires users to plot using base R styling (using plot()).↩︎\nIt’s also possible to thin data by distance rather than cell size using tidysdm::thin_by_dist().↩︎\nA true absence has quite a different meaning than a pseudo-absence to a species distribution model. The main difference is in the value a known absence provides compared to a simulated one for our interpretation of the results.A true absence is a point where, at a specific time, an organism was not found there. Alternatively, a pseudo-absence is a point that acts like we haven’t found an animal there, but we don’t actually have data for that location! The model, however, doesn’t know if a point represents a true absence or a psuedo-absence. It only knows the information it is given and will interpret that information using the parameters it is provided (in this way, models are a reflection of the real-world, but never a substitute).Collecting true absence data is difficult, typically requiring expert knowledge, surveys with stricter methodologies, and repeated measures of the same areas over time. Pseudo-absences are much easier to collect—you simply simulate them on a computer—but they are less informative. Keep this trade-off in mind as you interpret your model’s results.↩︎\nKeep in mind that the strength of variables depends on the scale of your prediction. If you wish to make predictions at a broad-scale, variables like temperature and rainfall will likely be strong predictors, whereas if you wish to make predictions at a fine-scale, variables like food scarcity and competition might be stronger predictors for your outcome.↩︎\nA model can only use the information it is provided to make inferences about the world. If multiple variables in a model correlate, the model can place too much weight on those values to determine the outcome! The model isn’t aware of the many other environmental variables that affect the real world outcome.↩︎\nMeasured as the standard deviation of the mean monthly temperature↩︎\nFor example, log transformation, centring scales, setting dummy variables↩︎\nTo learn more about how putting together a stack works, check out this helpful article on the stacks website.↩︎"
  },
  {
    "objectID": "posts/2025-04-02_greater-gliders/index.html",
    "href": "posts/2025-04-02_greater-gliders/index.html",
    "title": "Modelling the impact of fire on the Southern Greater Glider",
    "section": "",
    "text": "Jarod Wright\nDax Kellie\n\n\n\n2 April 2025\nBush fires are a frequent and natural part of Australia’s ecosystems. Australia’s flora and fauna have adapted alongside fire, with some plants needing fire to germinate and regenerate.\nAboriginal and Torres Strait Islander people have also expertly used fire for tens of thousands of years to care for Country, managing vegetation, reducing wildfire risk, and fostering biodiversity. Since European colonisation, however, the disruption of these practices has created a build-up of fuel loads and introduced invasive plant species, increasing Australia’s risk of larger, uncontrollable fires as temperatures rise.\nIn 2019-2020, Australia experienced one of the most catastrophic bushfire seasons on record. Fires burnt approximately 19 million hectares, of which 12.6 million were primarily forest and bushland. An estimated 900 species of plants and animals were severely impacted, and 3 billion animals were killed or displaced.\nIn this post we will explore the impact of the 2019-2020 bushfires on a population of greater gliders (Petauroides volans), a forest-dwelling marsupial species found along the east coast of Australia. We’ll determine greater gliders’ overall habitat range using tidymodels and tidysdm, then use the output of our model to explore whether the impact of fire on greater glider observations since 2019-2020.\nTo begin, we can load the following packages.\nlibrary(galah)\nlibrary(tidyverse)\nlibrary(tidymodels) \nlibrary(tidysdm) # devtools::install_github(\"EvolEcolGroup/tidysdm\")\nlibrary(terra)\nlibrary(tidyterra)\nlibrary(here)\nlibrary(sf)\nlibrary(ozmaps)\nlibrary(elevatr)\nlibrary(geodata)\nlibrary(stacks)\nWe are interested in testing whether observations of gliders changed in areas burnt by the 2019/2020 Black Summer bushfires compared to those that remained unburnt.\nThat means we’ll need a few components for our investigation:\nOur hypothesised effect is that there are fewer occurrences of greater gliders after the fire, and a driver of this effect is that an area was previously burnt during the 2019/2020 bushfires.\nFirst, let’s establish our study area and download records of our species of interest."
  },
  {
    "objectID": "posts/2025-04-02_greater-gliders/index.html#observational-data",
    "href": "posts/2025-04-02_greater-gliders/index.html#observational-data",
    "title": "Modelling the impact of fire on the Southern Greater Glider",
    "section": "Observational data",
    "text": "Observational data\nThe Southern Greater Glider (Petauroides volans) is Australia’s largest gliding marsupial, found in tall eucalypt forests along the east coast, from Queensland to Victoria. They are an endagered nocturnal, tree-dwelling herbivore that primarily feed on eucalyptus leaves and den in hollow bear trees1.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLeft: Petauroides volans (Josh Bowell | CC-BY-NC 3.0 (Au)), Right: Petauroides volans (David Sinnott | CC-BY-NC 4.0 (Int))\n\nWe’re going to focus on a region of South-East New South Wales and the Australian Captial Territory for our investigation. To start, let’s establish a bounding box around our area in a few different formats (tibble, SpatExtent and sf). We’ll also pull in a map of Australia for later rendering and working with our rasters.\n\n# define geographic region of bounding box\n# tibble format is handy for plotting\nse_nsw_bbox &lt;- tibble(\n  ymin = -37.5,\n  ymax = -35,\n  xmin = 148.5,\n  xmax = 151\n)\n# Create a terra extent \n# SpatExtent objects are used for modifying raster layers later on\nbbox_ext &lt;- terra::ext(\n  c(se_nsw_bbox[[\"xmin\"]], \n    se_nsw_bbox[[\"xmax\"]], \n    se_nsw_bbox[[\"ymin\"]], \n    se_nsw_bbox[[\"ymax\"]]\n  ))\n\n# Create an sf object of our bounding box\n# sf object will help specify elevation data later on\nbbox_sf &lt;- st_as_sf(as.polygons(bbox_ext, crs = \"EPSG:4326\"))\n\n# Get outline of Australia\naus &lt;- ozmaps::ozmap_country |&gt;\n  st_transform(crs = \"EPSG:4326\")\n\n\n\n\n\n\n\n\n\n\n\n\nNow let’s use the galah package to download greater glider records from the Atlas of Living Australia over a 10-year time period from 2014 to 2024, which captures observations of greater gliders before and after the 2019-2020 bushfires. Passing our se_nsw_bbox to galah_geolocate() will return only the records in our bounding box. You’ll need to register your email address with the ALA, then pass it to galah using galah_config().\n\ngalah_config(email = \"your-email-here\") # Registered ALA email\n\n# Collect all greater glider records between 2014 and 2024 for the region we defined\ngliders &lt;- galah_call() |&gt;\n  identify(\"Petauroides volans\") |&gt;\n  filter(year &gt;= 2014 & year &lt;= 2024) |&gt;\n  galah_apply_profile(ALA) |&gt;\n  galah_geolocate(se_nsw_bbox, type = \"bbox\") |&gt;\n  atlas_occurrences()\n\n# Create an sf object for spatial analysis & mapping\ngliders_sf &lt;- gliders |&gt;\n  st_as_sf(coords = c(\"decimalLongitude\", \"decimalLatitude\")) |&gt;\n  st_set_crs(4326)\n\n\n\n\n\n\n\n\nGreater Glider Observations (2014-2024)\n\n\n\n\n\nBefore or after fire\nLet’s add a new column fire_period to categorise whether an observation was recorded before or after the fires. Fires lasted over several months so it’s difficult to pinpoint an exact cut-off date. Let’s choose the 1st of December 2019 as a cut-off between pre_fire and post_fire, which marks the beginning of peak bush fire season. Many of the largest bush fires had moved into our study area by this point in time.\n\n# Classify each glider record as pre or post fire\ngliders_sf &lt;- gliders_sf |&gt;\n  mutate(\n    fire_period = if_else(eventDate &lt; as.Date(\"2019-12-01\"), \"pre_fire\", \"post_fire\"),\n    .before = eventDate # position the column so we can see it\n    )\n\n\n\nCode\nggplot() +\n  geom_sf(data = aus, fill = \"grey97\", color = \"grey40\") +\n  geom_rect(data = se_nsw_bbox,\n            mapping = aes(xmin = xmin, \n                          ymin = ymin, \n                          xmax = xmax, \n                          ymax = ymax),\n            colour = \"grey50\",\n            fill = NA) + \n  geom_sf(data = gliders_sf, \n          aes(color = fire_period), \n          size = 2, \n          alpha = 0.7) +\n  scale_colour_manual(values = c(\"#0F3F5C\", \"#CF5F37\")) +\n  labs(color = \"Fire Period\") +\n  coord_sf(xlim = c(se_nsw_bbox$xmin, se_nsw_bbox$xmax), \n           ylim = c(se_nsw_bbox$ymin, se_nsw_bbox$ymax)) +\n  theme_void()\n\n\n\n\n\nGreater glider observations before and after the 2019-2020 bushfires\n\n\n\n\nNow that we have greater glider observations, we can start pulling in our raster data for our model."
  },
  {
    "objectID": "posts/2025-04-02_greater-gliders/index.html#spatial-data",
    "href": "posts/2025-04-02_greater-gliders/index.html#spatial-data",
    "title": "Modelling the impact of fire on the Southern Greater Glider",
    "section": "Spatial data",
    "text": "Spatial data\nThere are a few environmental factors that are useful for determining the suitable habitat area for greater gliders. With the help of previous studies on gliders2, we’ve chosen to download the following four raster layers3 to use as environmental predictors in our species distribution model:\n\nElevation (from the elevatr package)\nTree cover (from Global Land Analysis & Discovery)\nMean annual temperature (BIO1) (from CHELSA)\nAnnual precipitation (BIO12) (from CHELSA)\n\nTo assess bush fire impact, we will also need to download a fifth raster layer that maps the area burnt over the 2019-2020 bushfires:\n\nFire extent and severity mapping (2019-2020) (from the NSW government)\n\nEach raster layer will need to be wrangled so that they fit neatly together (same area, same projection, same resolution). We will perform a common series of modifications to each layer that generally fall into the following steps:\n\nCrop the layer to our study area\nMask (or remove) the ocean from our layer so that it does not skew our model\nRename the layer to something sensible\nResample each layer to the same resolution (so that every layer’s grid aligns correctly)\n\nThese steps might not always be in the same order, but you will recognise them as we go through the next few sections to download our spatial data.\n\nElevation\nFirst we’ll download elevation data for our defined region using the {elevatr} package’s handy get_elev_raster() function. By passing our bounding box bbox_sf to the locations argument we can return elevation data (in metres) for our specified area!\n\n# Download elevation raster\nelevation_data &lt;- get_elev_raster(locations = bbox_sf, \n                                  z = 9, \n                                  prj = \"EPSG:4326\")\n\n# Remove raster information outside of the aus land boundary\nelevation_aligned &lt;- elevation_data |&gt;\n  terra::rast() |&gt;      # convert to SpatRaster class\n  terra::mask(aus) |&gt;   # remove information outside of aus boundary\n  terra::crop(bbox_ext) # crop layer to bbox\n\n# Rename layer for simplicity\nnames(elevation_aligned) &lt;- \"elevation\"\n\n\n\nCode\nggplot() +\n  geom_spatraster(data = elevation_aligned, aes(fill = elevation)) +\n  scale_fill_terrain_c(na.value = NA) +\n  guides(fill = guide_colorbar(title = \"Elevation (m)\")) +\n  theme_minimal()\n\n\n\n\n\nElevation in metres\n\n\n\n\n\n\nTree cover\nNext we’ll download tree cover data. This tree cover raster layer contains satellite data from Hansen et al (2010) where tree cover is recorded as a percentage (0 = no cover and 100 = complete tree cover).\nSpatial data are held on the Global Land Analysis and Discovery website. Tree cover data files are divided in tiles of 10 x 10 latitude/longitude. Because our study area crosses over two tiles (30S_150 and 30S_140), we will need to download and stitch together two rasters. We can then crop them down to our specified area.\nTo download the files, go to the global 2010 treecover dataset –&gt; click on the url link under the Data Links subheading near the bottom of the page –&gt; click on the relevant data links to download. The two file names we are interested in are: treecover2010_30S_140E.tif and treecover2010_30S_150E.tif. Save these files in your local working directory.\n\n\nUse code to download\n\nAlternatively, we can use the following code chunk to download files:\n\ndownload.file(\"https://glad.umd.edu/Potapov/TCC_2010/treecover2010_30S_140E.tif\", destfile=\"treecover2010_30S_140E.tif\")\ndownload.file(\"https://glad.umd.edu/Potapov/TCC_2010/treecover2010_30S_150E.tif\", destfile=\"treecover2010_30S_150E.tif\")\n\n\nLet’s load our files into R as rasters.\n\n# Load the raster\ntree_cover_150 &lt;- terra::rast(here(\"treecover2010_30S_150E.tif\"))\ntree_cover_140 &lt;- terra::rast(here(\"treecover2010_30S_140E.tif\"))\n\nNow we can crop them to our study area and merge them together.\n\n# Crop to bbox\ntree_cover_150_cropped &lt;- tree_cover_150 |&gt; terra::crop(bbox_ext)\ntree_cover_140_cropped &lt;- tree_cover_140 |&gt; terra::crop(bbox_ext)\n\n# Merge\ntree_cover &lt;- merge(tree_cover_150_cropped, tree_cover_140_cropped)\n\n# Rename for simplicity\nnames(tree_cover) &lt;- \"treecover\"\n\n\n\n\n\n\n\nBest practice\n\n\n\nWhen working with spatial data we tend to use up a lot of memory! That’s a big reason why we are performing these cropping steps—so that we can use up the least amount of memory necessary to get our model to function. Because of this, after we have stitched our two rasters together, we should safely delete the other two as we will no longer require them to clear space.\n\n# We can now safely delete the first two raster files to save memory\nrm(tree_cover_140); rm(tree_cover_150)\n\n\n\n\n\nCode\nggplot() +\n  geom_spatraster(data = tree_cover, aes(fill = treecover)) +\n  scale_fill_viridis_c(direction = -1, begin = 0.8, end = 0.1) +\n  guides(fill = guide_colorbar(title = \"Tree Cover (%)\")) +\n  theme_minimal()\n\n\n\n\n\nTree cover (%)\n\n\n\n\n\n\nTemperature & precipitation\nNext we’ll download two bioclimatic raster layers from CHELSA. CHELSA hosts climate projections at high resolutions intended for ecological use (here’s the paper about it). Climate projections extend from 1981 to 2100. Vegetation that greater gliders inhabit is sensitive to temperature and precipitation changes, so we decided to use climate projections for 2011-2040 for the following two climate variables:\n\nBIO1: Mean Annual Temperature\nBIO12: Annual Precipitation\n\nTo download these layers on the CHELSA website, click on ‘Downloads’ in the top bar, under version 2.1 click the ‘Download’ button, then navigate to GLOBAL/* –&gt; climatologies/ –&gt; UKESM1-0-LL –&gt; ssp370/ –&gt; bio/. Then select the files with names beginning with CHELSA_bio1_2011-2040 and CHELSA_bio12_2011-2040. Save these files in your local directory.\n\n\nUse code to download\n\nAlternatively, we can use the following code chunk to download files:\n\n# Download our two raster files\ndownload.file(\"https://os.zhdk.cloud.switch.ch/chelsav2/GLOBAL/climatologies/2011-2040/UKESM1-0-LL/ssp370/bio/CHELSA_bio1_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif\",\n              destfile=\"CHELSA_bio1_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif\", mode=\"wb\")  \n\ndownload.file(\"https://os.zhdk.cloud.switch.ch/chelsav2/GLOBAL/climatologies/2011-2040/UKESM1-0-LL/ssp370/bio/CHELSA_bio12_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif\",\n              destfile=\"CHELSA_bio12_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif\", mode=\"wb\") \n\n\nLet’s load our files into R as rasters.\n\ntemp &lt;- rast(\"CHELSA_bio1_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif\")\nprecip &lt;- rast(\"CHELSA_bio12_2011-2040_ukesm1-0-ll_ssp370_V.2.1.tif\")\n\nNow we’ll mask and crop each layer, then rename them.\n\n# mask and crop to study area\ntemp &lt;- temp |&gt;\n  terra::mask(aus) |&gt;   # remove oceans\n  terra::crop(bbox_ext) # crop to bbox\n\nprecip &lt;- precip |&gt;\n  terra::mask(aus) |&gt;   # remove oceans\n  terra::crop(bbox_ext) # crop to bbox\n\n# Rename for simplicity\nnames(temp) &lt;- \"temp_bio1\"\nnames(precip) &lt;- \"precip_bio12\"\n\n\n\n\n\n\n\n\n\n\nMean Annual Temperature (BIO1)\n\n\n\n\n\n\n\nAnnual Precipitation (BIO12)\n\n\n\n\n\n\n\nBurnt area\n\nFinally, we will download a fire extent raster layer, documenting the area burnt by the 2019-2020 bushfires in New South Wales. The NSW Government’s Fire Extent and Severity Mapping (FESM) 2019/20 dataset contains information on the extent and severity of burnt areas across the state.\nTo download, navigate to the NSW Government website, click on ‘Dataset Packages’, then select the download icon next to ‘FESM v3-data in IMG and TIFF format’. Save this zip folder in your working directory and uncompress the folder.\n\n\n\n\n\n\nWarning: Big zip folder\n\n\n\n\n\nWhile the download itself is only several hundred megabytes, when uncompressed the .tif file is very large (10.3 GB). Please keep this in mind when choosing a place to store the folder!\n\n\n\nLet’s load the fire extent layer into R as a raster.\n\n# Load raster\nfire_extent &lt;- rast(\"cvmsre_NSW_20192020_ag1l0.tif\")\n\nThis file is pretty huge and it’s in the wrong projection, which we can see under coord. ref when we view the object. Our desired CRS is WGS84/EPSG:4326 but this raster is projected using CRS GDA_94_Lambert, which affects the extent and coordinates.\n\nfire_extent\n\nclass       : SpatRaster \ndimensions  : 103386, 107910, 1  (nrow, ncol, nlyr)\nresolution  : 9.993738, 9.993738  (x, y)\nextent      : 8857447, 9935872, 4022290, 5055502  (xmin, xmax, ymin, ymax)\ncoord. ref. : GDA94_NSW_Lambert \nsource      : cvmsre_NSW_20192020_ag1l0.tif \ncolor table : 1 \nname        : Layer_1 \nThis poses an issue for us. Reprojecting the entire file to WGS84 (like we have for other rasters) will take up a lot of processing time and memory if we do this reprojection as a first step.\nTo save time and memory, let’s use an alternative method of cropping first and reprojecting second. We’ll first crop fire_extent to our desired study area by taking our original bbox_ext object and matching its projection to the CRS of fire_extent. We’ll use bbox_ext_gda94 to crop fire_extent to a much smaller area. Then, second, we can reproject our fire_extent_cropped object to the correct projection (and crop again to be certain our layer matches with other layers).\nFirst let’s convert our bounding box bbox_ext, convert it to a polygon and reproject that polygon to use the CRS of fire_extent.\n\n# Convert bbox to polygon with new projection that matches fire_extent\nbbox_ext_gda94 &lt;- bbox_ext |&gt; \n  terra::as.polygons(\n    crs = gliders_sf           # set crs to match glider data\n    ) |&gt;\n  terra::project(fire_extent)  # reproject crs to match fire_extent\n\nbbox_ext_gda94\n\n class       : SpatVector \n geometry    : polygons \n dimensions  : 1, 0  (geometries, attributes)\n extent      : 9432876, 9664886, 4021704, 4305054  (xmin, xmax, ymin, ymax)\n coord. ref. : GDA94_NSW_Lambert \nNow we can use our new bounding box bbox_ext_gda94 to crop fire_extent to our study area, then reproject it to our desired CRS WGS84. When complete, you’ll notice the extent and coord. ref. or fire_extent_cropped have changed to match our expected bounding box and CRS.\n\n\n\n\n\n\nThis process takes a while to run\n\n\n\nThe next few steps to crop and reproject fire_extent takes ~5 minutes to run.\n\n\n\n# Crop fire_extent using the reprojected bbox, then reproject to WGS84\nfire_extent_cropped &lt;- fire_extent |&gt;\n  terra::crop(bbox_ext_gda94) |&gt;\n  terra::project(crs(gliders_sf))   # reproject to match glider data\n\nfire_extent_cropped\n\nclass       : SpatRaster \ndimensions  : 26110, 26732, 1  (nrow, ncol, nlyr)\nresolution  : 9.962733e-05, 9.962733e-05  (x, y)\nextent      : 148.4563, 151.1196, -37.54717, -34.9459  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : spat_38b02a6426e6_14512_80Q6udnsxVen2Mq.tif \nname        : Layer_1 \nmin value   :       0 \nmax value   :       5 \nIf there are a few tailing decimal places that appeared while converting the extent of fire_extent_cropped, we can crop it again using bbox_ext to make sure it matches other rasters (the extent will slightly but noticeably change).\n\nfire_extent_cropped &lt;- fire_extent_cropped |&gt;\n  terra::crop(bbox_ext)\n\nWe’ll now mask out the ocean like we did for other layers.\n\n# Remove ocean\nfire_extent_cropped &lt;- fire_extent_cropped |&gt;\n    terra::mask(aus)\n\nfire_extent_cropped\n\nclass       : SpatRaster \ndimensions  : 2053, 2054, 1  (nrow, ncol, nlyr)\nresolution  : 0.001217593, 0.001217593  (x, y)\nextent      : 148.4994, 151.0003, -37.5001, -35.00038  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource(s)   : memory\nvarname     : cvmsre_NSW_20192020_ag1l0 \nname        : fire_extent \nmin value   :           0 \nmax value   :           5 \n\n\n\n\n\n\n\n\nSave your cropped layer\n\n\n\n\n\nNow would be a good time to save your new cropped raster layer locally. This cropped raster layer is much smaller than our original layer, and it will be easier (and faster) to use this smaller layer in a workflow. Just be sure to document where you downloaded the larger file and the process you used to crop it!\n\n\n\n\n\nCode\nggplot() +\n  geom_spatraster(data = fire_extent_cropped, aes(fill = fire_extent)) +\n  scale_fill_princess_c(palette = \"america\")  +\n  guides(fill = guide_colorbar(title = \"Fire Severity\")) +\n  theme_minimal()\n\n\n\n\n\nFire Severity\n\n\n\n\nThe fire_extent layer contains information of the fire’s severity on a scale from 0 (unburnt) to 5 (extreme). For our purposes, we are mainly interested in whether the area was affected by fire or not, rather than its severity.\n\n\n\n\n\n\nFire severity values\n\n\n\n\n\nIf you are interested, the fire_extent dataset categorises fire severity using the following values:\n\n0 - Unburnt (0% canopy and understory burnt)\n1 - Reserved (Experimental category, is not used in raster right now)\n2 - Low (&gt; 10% burnt upderstory, &gt;90% green canopy)\n3 - Moderate (20-90% canopy scorch)\n4 - High (&gt; 90% canopy scorched, &lt;50% canopy consumed)\n5 - Extreme (&gt;50% canopy biomass consumed)\n\n\n\n\nFor simplicity, let’s recode fire_extent to whether an area is burnt or unburnt and save this info in a new column burnt. We’ll use a dummy variable to make our results easier to interpret where burnt is 1 and unburnt is -1. Then we’ll rename the layer.\n\nburnt_cropped &lt;- fire_extent_cropped |&gt;\n  mutate(\n    # make `burnt` column\n    burnt = case_when(\n      fire_extent &gt;= 1 ~ 1, # burnt\n      fire_extent == 0 ~ -1, # unburnt\n      .default = NA_integer_\n    )\n  ) |&gt;\n  select(-fire_extent) # remove fire_extent column\n\n# Rename for simplicity\nnames(burnt_cropped) &lt;- \"burnt\"\n\nburnt_cropped\n\nclass       : SpatRaster \ndimensions  : 2053, 2054, 1  (nrow, ncol, nlyr)\nresolution  : 0.001217593, 0.001217593  (x, y)\nextent      : 148.4994, 151.0003, -37.5001, -35.00038  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource(s)   : memory\nname        : burnt \nmin value   :    -1 \nmax value   :     1 \n\n\n\n\nMatch resolution\nA final important step is to make sure our layers are projected at the same resolution. Aligning rasters allows for more accurate and reliable results because grid cells won’t overlap in unexpected ways (which would affect our model). Typically, the resolution should match the layer with the lowest resolution. In our case, this is elevation_aligned layer, which you can see if you print the object to the console and compare with other layers.\n\nelevation_aligned\n\nclass       : SpatRaster \ndimensions  : 2053, 2054, 1  (nrow, ncol, nlyr)\nresolution  : 0.001217593, 0.001217593  (x, y)\nextent      : 148.4994, 151.0003, -37.5001, -35.00038  (xmin, xmax, ymin, ymax)\ncoord. ref. : +proj=longlat +datum=WGS84 +no_defs \nsource(s)   : memory\nvarname     : file6d6488e4000 \nname        : elevation \nmin value   :      -728 \nmax value   :      1901 \n\n\nLet’s resample each layer to match the resolution of elevation_aligned using terra::resample().\n\n# Resample our tree cover to the resolution of the elevation data\ntree_cover &lt;- terra::resample(tree_cover, elevation_aligned)\ntemp &lt;- terra::resample(temp, elevation_aligned)\nprecip &lt;- terra::resample(precip, elevation_aligned)\nburnt &lt;- terra::resample(burnt_cropped, elevation_aligned)\n\n\n\nCombine spatial layers\nWe can now combine all of our raster layers into one object containing:\n\nElevation\nTree cover\nMean annual temperature (BIO1)\nAnnual precipitation (BIO12)\nBurnt area from the 2019-2020 bushfires\n\n\ncombined_rasters &lt;- c(elevation_aligned, tree_cover, temp, precip, burnt)\n\ncombined_rasters\n\nclass       : SpatRaster \ndimensions  : 2053, 2054, 5  (nrow, ncol, nlyr)\nresolution  : 0.001217593, 0.001217593  (x, y)\nextent      : 148.4994, 151.0003, -37.5001, -35.00038  (xmin, xmax, ymin, ymax)\ncoord. ref. : +proj=longlat +datum=WGS84 +no_defs \nsource(s)   : memory\nvarnames    : file6d6488e4000 \n              file6d6488e4000 \n              file6d6488e4000 \n              ...\nnames       : elevation, treecover, temp_bio1, precip_bio12, burnt \nmin values  :      -728,   0.00000,  6.293441,     468.7325,    -1 \nmax values  :      1901,  94.93295, 18.281870,    1358.0767,     1 \n\n\nPhew! That was a lot of data preparation. But with our spatial data sorted, we are now ready to begin preparing our model!"
  },
  {
    "objectID": "posts/2025-04-02_greater-gliders/index.html#footnotes",
    "href": "posts/2025-04-02_greater-gliders/index.html#footnotes",
    "title": "Modelling the impact of fire on the Southern Greater Glider",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nSouthern greater gliders grow up to 1m long from head to tail and can glide up to 100 metres through the canopy!↩︎\ne.g. Smith et al. 2007; Ridley et al. 2024↩︎\nFor more info about what rasters are, see the “What’s a raster” section from this ALA Labs article.↩︎\nPseudo-absences, also called background points, are points that represent true absences in our data for modelling. They are there to help our model make predictions about what variables more strongly predict a presence vs an absence. Because we don’t have true presence data, this is one way to provide a model this information, though it is less informative for our interpretation.↩︎\nThey only provide information about the conditions of when a glider was observed but no information about when gliders aren’t observed↩︎\nFor this analysis, it doesn’t really matter whether we have a perfect split.↩︎\nFor more info on what this means, see this section from another ALA Labs article↩︎\nSo well, in fact, that it’s plausible it might be overfitting, making our model poor for prediction outside of our small spatial bounding box in New South Wales. For our intended analysis, this doesn’t matter, but for a model intended for use to make broad future predictions this could pose a problem.↩︎\nTo the extent that the combination of an area being burnt and post_fire might multiply the effect when together.↩︎\nDALEX stands for moDel Agnostic Language for Exploration and eXplanation. It may be one of the strangest acronyms of all time.↩︎\nBased on how our variable is coded, a negative coefficient means that before fires, there is a higher likelihood of absence.↩︎\nBased on how our variable is coded, a positive coefficient means that in burnt areas, there is a higher likelihood of absence.↩︎"
  },
  {
    "objectID": "research/highlights/2023_chytrid-fungus/index.html",
    "href": "research/highlights/2023_chytrid-fungus/index.html",
    "title": "Will frogs bounce back after chytrid fungus?",
    "section": "",
    "text": "Litoria peronii (Giverny CC BY NC 4.0)\n\n\nCitation\n\n\nScheele, B. C., Heard, G. W., Cardillo, M., Duncan, R. P., Gillespie, G. R., Hoskin, C. J., Mahony, M., Newell, D., Rowley, J. J. L., & Sopniewski, J. (2023) An invasive pathogen drives directional niche contractions in amphibians. Nature Ecology & Evolution https://doi.org/10.1038/s41559-023-02155-0\n\n\n\nPage info\nPrepared by Olivia Torresan\n\n\n\n\n\nAlthough it’s well documented that native species decline when invasive species are introduced, less is known of how an invasive species can reshape a native species’ ecological niche (i.e. their place and role within an ecosystem).\nChytrid fungus (Batrachochytrium dendrobatidis) is an invasive fungus that causes chytridiomycosis disease in exposed frogs, an often-fatal disease that breaks down keratin within a frogs’ skin—a vital respiratory organ for frogs. Chytrid fungus was first discovered in Australia in the 1970’s and is responsible for over 90 frog extinctions globally.\nScheele et al. (2023) use frog data from the Atlas of Living Australia, GBIF and FrogID to compare niches of impacted and un-impacted frogs in Australia. Niches extend on a species current occurrence record and incorporate broader environmental, climatic, and dietary preferences of frogs, as well as their larger ecosystem role.\nThe authors found that chytrid fungus contracted frogs’ ecological niches, restricting many species to niches with conditions less favoured by chytrid fungus. This finding shows how chytrid fungus can shrink niches and fragment populations, limiting overall species genetic diversity—an important means for frogs to fight disease and repopulate.\nScheele et al.’s (2023) research suggests that chytrid fungus may have a lasting impact on the ecological niche of impacted frog species, limiting their suitability to live in areas where they were distributed previously."
  },
  {
    "objectID": "research/highlights/2023_koala-photography/index.html",
    "href": "research/highlights/2023_koala-photography/index.html",
    "title": "Zooming in: Improving Koala monitoring with photography",
    "section": "",
    "text": "Phascolarctos cinereus (Charley Geddes CC BY 4.0)\n\n\nCitation\n\n\nDanaher, M., Schlagloth, R., Hewson, M., & Geddes, C. (2023) One Person and a Camera: A relatively nonintrusive approach to Koala citizen science. Australian Zoologist https://doi.org/10.7882/AZ.2023.006\n\n\n\nPage info\nPrepared by Olivia Torresan\n\n\n\n\n\nImages can provide a lot of information useful to conservation efforts. A picture can capture changes in species traits and habitats, and sometimes even identify unique individuals of a species. Koalas are one species where individuals can be distinguished by their fur and markings, making it possible for researchers to monitor individuals in a non-invasive manner.\nDanaher et al. (2023) explained how just one citizen scientist can make a huge impact on monitoring individuals using photography, evidenced by the work of Charley Geddes.\nFor over 10 years, Charley has worked tirelessly to capture koalas in her local area in Central Queensland. Her images provide detailed and intricately collected biodiversity data, so much so that researchers can track each individual’s markings, fur colour, size, posture, and overall demeanour (even how they may dangle a leg)! While nose markings are found to be the most reliable, Charley notes that each koala (like us) has its own personality, and this realisation helps to improve her photography.\nCharley’s Koala monitoring project is available on the Atlas of Living Australia’s BioCollect platform."
  },
  {
    "objectID": "research/highlights/2023_microfossils/index.html",
    "href": "research/highlights/2023_microfossils/index.html",
    "title": "Citizen scientists uncover environmental history with pollen & spore fossils",
    "section": "",
    "text": "Araucaria bidwillii (Michael Hains CC BY 3.0)\n\n\nCitation\n\n\nDjokic, T., Frese, M., Woods, A., Dettmann, M., Flemons, P., Brink, F., & McCurry, M. R. (2023) Inferring the age and environmental characteristics of fossil sites using citizen science. PLOS ONE https://doi.org/10.1371/journal.pone.0284388\n\n\n\nPage info\nPrepared by Olivia Torresan, Margot Schneider\n\n\n\n\n\nMicrofossils are the fossilized remains of bacteria, protists, fungi, animals and plants. The most common way to extract and analyse microfossils is by using a compatible acid to dissolve the rock they are preserved in while leaving the fossil intact. In some cases, though, this method does not work. If the rock matrix and the fossils are too compositionally similar, for instance, the choice of acid can degrade the fossil or reduce its quality.\nFaced with this problem, Djokic and others (2023) used citizen science to analyse images of pollen and spore microfossils from McGrath’s Flat near Gulgong in the Central Tablelands (NSW). Analysing images of microfossils is an incredibly time and resource-consuming feat. A professional scientist usually needs around 6 hours to locate and image 50 microfossils (not including analysis or identification).\nUsing images hosted by Atlas of Living Australia’s online volunteering platform DigiVol, 250 citizen scientists analysed 25,000+ images at three times this pace (!), successfully identifying 300 pollen and spores from the Miocene age (11–20 million-years-ago). The authors hope to encourage other researchers to use the power of citizen science for fossil identification."
  },
  {
    "objectID": "research/highlights/2023_pinus-radiata/index.html",
    "href": "research/highlights/2023_pinus-radiata/index.html",
    "title": "Pining appetites: Insects’ global impact on Pinus radiata",
    "section": "",
    "text": "Pinus radiata (Rachel CC BY NC 3.0)\n\n\nCitation\n\n\nBrockerhoff, E. G., Gresham, B. A., Meurisse, N., Nahrung, H. F., Perret-Gentil, A., Pugh, A. R., Sopow, S. L., & Turner, R. M. (2023) Pining away and at home: global utilisation of Pinus radiata by native and non-native insects. NeoBiota https://doi.org/10.3897/neobiota.84.95864\n\n\n\nPage info\nPrepared by Olivia Torresan\n\n\n\n\n\nGlobally, Pinus radiata is one of the most frequently planted forestry trees due to its versatility: It grows quickly, it can survive in many conditions and climates, and it is used in many kinds of wood and non-wood products. However, at the same time, P. radiata is threatened within its native range of California.\nGiven P. radiata’s global popularity, the spread of pests and disease are both a high risk and a prominent concern for this tree. Insects that feed on the foliage or bore the live layer of growing wood and bark are able to stunt growth or even kill P. radiata.\nBrockerhoff et al. used data of insects known to feed on P. radiata, including data from the Atlas of Living Australia, to map each species invasion status and quantify their impact. They found the Americas to have the greatest number of high-impact invasive species, followed by Australia and Asia. Australasia also had the highest number of different native and non-native species to feed on P. radiata overall and the highest number of migratory insect species to other countries.\nKnowing where herbivorous insect pests are common and where they are migrating globally can help inform and improve current biosecurity protocols when importing and exporting pine products in the future."
  },
  {
    "objectID": "research/highlights/2023_waterwatch/index.html",
    "href": "research/highlights/2023_waterwatch/index.html",
    "title": "Aligning citizen-science objectives to foster research grade data",
    "section": "",
    "text": "Austroargiolestes icteromelas (JohnBundock CC BY 3.0)\n\n\nCitation\n\n\nO’Reilly, W. & Starrs, D. (2023) Science citizen: Shifting to a “science-first” approach and recognising the trade-offs between objectives in a long-term citizen science program. Frontiers in Environmental Science https://doi.org/10.3389/fenvs.2023.1270247\n\n\n\nPage info\nPrepared by Olivia Torresan\n\n\n\n\n\nThere remains ongoing debate on how reliable citizen science data is within ecological research. This debate often questions the accuracy and viability of long-term data collection within citizen science. One prevalent opinion is that citizen science data is unreliable compared to professionally collected data for ecological research. Those in support of citizen science argue that citizen science data can be made reliable with proper methodological planning.\nIn this paper, O’Reilly et al. (2023) review WaterWatch ACT, a thirty-year citizen science project on water quality and biodiversity, to understand its successes and failures. The authors find that diverging objectives between keen citizen scientists and professional researchers was one major difficulty of using citizen science for research-grade data collection.\nFor example, citizen scientists value independence and data ownership; these objectives can empower volunteers to choose sites and times that work best for them to collect data. However, this freedom can fragment sample sizes and sites, making data less accurate than data from professionally collected, methodologically rigourous research projects. Despite the benefits of added rigour, there are limitations to the amount of data professional researchers can collect, too, usually due to short-term project funding or finite time and resource commitments.\nWaterWatch ACT found that balancing these objectives was key to improving data quality while retaining strong citizen science support for their long-term program. Citizen science has huge potential for regular data collection in ecology. Learning to adapt methods will improve the use, breadth and quality of ecological data into the future."
  },
  {
    "objectID": "research/highlights/2024_freshwater-fish-IUCN/index.html",
    "href": "research/highlights/2024_freshwater-fish-IUCN/index.html",
    "title": "Protecting Australia’s freshwater fish at risk of extinction",
    "section": "",
    "text": "Galaxias truttaceus (Bruce Deagle CC BY 4.0)\n\n\nCitation\n\n\nLintermans, M., Lutz, M., Whiterod, N. S., Gruber, B., Hammer, M. P., Kennard, M. J., Morgan, D. L., Raadik, T. A., Unmack, P., Brooks, S., Ebner, B. C., Gilligan, D., Butler, G. L., Moore, G., Brown, C., Freeman, R., Kerezsy, A., Bice, C. M., Le Feuvre, M. C., Beatty, S., Arthington, A. H., Koehn, J., Larson, H. K., Coleman, R., Mathwin, R., Pearce, L., Tonkin, Z., Bruce, A., Espinoza, T., Kern, P., Lieschke, J. A., Martin, K., Sparks, J., Stoessel, D. J., Wedderburn, S. D., Allan, H., Clunie, P., Cockayne, B., Ellis, I., Hardie, S., Koster, W., Moy, K., Roberts, D., Schmarr, D., Sharley, J., Sternberg, D., Zukowski, S., Walsh, C., Zampatti, B., Shelley, J. J., Sayer, C., Chapple, D. G. (2024) Troubled waters in the land down under: Pervasive threats and high extinction risks demand urgent conservation actions to protect Australia’s native freshwater fishes. Biological Conservation https://doi.org/10.1016/j.biocon.2024.110843\n\n\n\nPage info\nPrepared by Olivia Torresan\n\n\n\n\n\nMore than half of Australia’s freshwater fish species are unique to Australia and are found nowhere else in the world. This includes species like the ancient Australian lungfish, the longnose sooty grunter, and the spotted galaxias (pictured here).\nDespite this diversity, discussions on conserving freshwater fish in the last decade have focused largely on pests and disrupted streams, rather than a comprehensive understanding of the unique needs, behaviours and threats of native freshwater fish. Galaxias, for example, require calm and semi-isolated waterbodies like rock pools for protection from other species.\nTo identify gaps in current threatened species assessment, Linterman et al. completed the first holistic assessment of Australian freshwater fishes and their potential risk of extinction through IUCN Red List categorisation protocols. Using current scientific literature and combined data from sources including the Atlas of Living Australia, the authors found that many Australian freshwater fish are showing signs of possible decline without any formal recognition.\nCurrently there are 63 freshwater fish species listed as at risk of extinction nationally and across state jurisdictions, with this study identifying a potential 35 more. Many of these species are already listed on the IUCN Red List. The authors also found another 17 species are suitable for upgraded statuses (e.g., sensitive to threatened). Overall, these findings suggest that the current conservation effort for Australian freshwater fish may not align with the current level of threat, and the authors urge Australia to urgently update their risk assessment to prevent further extinction risk."
  },
  {
    "objectID": "research/highlights/2024_habitat-connectivity-tool/index.html",
    "href": "research/highlights/2024_habitat-connectivity-tool/index.html",
    "title": "Habitat connectivity support tool for Australian forest species",
    "section": "",
    "text": "Columba (Janthoenas) leucomela (Dianne Clarke CC BY NC 4.0)\n\n\nCitation\n\n\nNorman, P. & Mackey, B. (2024) A decision support tool for habitat connectivity in Australia. Conservation Biology https://doi.org/10.1071/PC24008\n\n\n\nPage info\nPrepared by Olivia Torresan\n\n\n\n\n\nWhen habitat is broken up or fragmented, species find it harder to use their habitat effectively. Fragmenting is common in urban areas where roads and property can prevent species from crossing to other habitable areas. This can be a big problem for the organisms that live there. Individuals and populations ultimately become separated, and when compared to larger, connected areas, fragmented areas have lower access to food, shelter, resources, and lower genetic diversity.\nConservation managers and decision makers rely on a variety of expert information about habitat connectivity to make predictions about where species’ might live, or have the ability to live in the future. Outside of whether a habitat is physically connected or not, there are also other variables like climate and geology that will determine habitat suitability. Each organism’s mobility also makes a big difference (e.g., a bird is inherently more mobile compared to a plant or fungus). Therefore, mapping and modelling connectivity can be complicated.\nUnder these concerns, Norman & Mackey (2024) used ALA data to help improve the precision of Australia-wide habitat connectivity maps. Their study mapped both habitat patches and their respective levels of connectivity for several forest-dwellers: Rainforest pigeons, gliding possums, and multiple species of black cockatoos (glossy, Carnaby’s, Baudins and red-tailed). Each map was then adjusted to consider levels of movement fatigue between suitable patches for each species (under a cost assumption that shorter connectivity routes are preferred).\nFindings are available as an interactive tool, intended to provide actionable and quickly accessible prioritisation zones for conservation managers and decision makers to aid habitat connectivity for each species."
  },
  {
    "objectID": "posts/2024-10-18_adding-buffers-in-python/Adding_Buffers_Points.html",
    "href": "posts/2024-10-18_adding-buffers-in-python/Adding_Buffers_Points.html",
    "title": "Add buffers to a shapefile in Python",
    "section": "",
    "text": "Author\nAmanda Buyan\nDax Kellie\n\n\nDate\n23 November 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBuffers are used in many ecological spaces. Most notably, they are used in Species Distribution Models to extend the possible range of rare or threatened species to create a better model. They can also be used to capture occurrences or areas which may have been neglected by a user’s original data. \nIn this post, we show how to use {galah-python}, {geopandas}, {shapely} and {matplotlib} to add a buffer to occurrences of Kangaroo Paw, specifically the Red and Green Kangaroo Paw.\n\n\nChoosing the right taxon\nKangaroo Paw is a common name for a number of species, represented by the genus Anigozanthos. They are perennial plants, native to the south-west of Western Australia. They are unique, bird-attracting flowers which open at the apex with six claw-like structures resembling kangaroo paws, hence their name!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLeft: Anigozanthos manglesii (dhfischer, iNaturalist CC-BY-NC 4.0 (Int), Middle: Anigozanthos flavidus (pimelea, iNaturalist CC-BY 4.0 (Int)), Right: Anigozanthos pulcherrimus (Brigham, John, Citizen Science - ALA Website CC-BY-NC 3.0 (AU))\n\nTo begin, we will look for the number of occurrences for the genus Anigozanthos. To do this, we will first start by loading galah-python.\n\nimport galah\ngalah.galah_config(email=\"your-email-here\")\n\nNow, we will use the atlas_counts() function to see a count of the number of occurrences of all species of Kangaroo’s Paw in the ALA.\n\ngalah.atlas_counts(taxa=\"Anigozanthos\")\n\n   totalRecords\n0          5952\n\n\nIt is surprising to note that there are only 84 occurrences coming up for all species in this genus! To ensure that we have the correct name, we will use search_taxa() to see if there is anything going on with this genus.\n\ngalah.search_taxa(taxa=\"Anigozanthos\")\n\n  scientificName scientificNameAuthorship                                    taxonConceptID   rank  kingdom      phylum         order         family         genus vernacularName   issues\n0   Anigozanthos                  Labill.  https://id.biodiversity.org.au/node/apni/2890004  genus  Plantae  Charophyta  Commelinales  Haemodoraceae  Anigozanthos   Kangaroo Paw  noIssue\n\n\nIf you scroll across to the rank column that is returned by this function, unfortunately, the search item that comes up for search_taxa() is unranked, which explains why we are getting very few records! What we can do now to refine our search is add a higher order of taxonomic classification to our query. By searching on the ALA species pages, we know that Anigozanthos is a genus belonging to the Haemodoraceae family. galah-python has an argument to search_taxa() called scientific_name, which allows the user to disambiguate their query.\n\nNow, if we add the extra taxonomic information, we get thte following query:\n\ngalah.search_taxa(scientific_name={\"family\": [\"Haemodoraceae\"],\"genus\": [\"Anigozanthos\"],\"scientificName\": [\"Anigozanthos\"]})\n\n  scientificName scientificNameAuthorship                                    taxonConceptID   rank  kingdom      phylum         order         family         genus vernacularName   issues\n0   Anigozanthos                  Labill.  https://id.biodiversity.org.au/node/apni/2890004  genus  Plantae  Charophyta  Commelinales  Haemodoraceae  Anigozanthos   Kangaroo Paw  noIssue\n\n\nHere, if we look at the information, we can see that our scientificName matches the genus we want, and the rank is now listed as genus. Now, if we get the total record count using this disambiguation:\n\ngalah.atlas_counts(scientific_name={\"family\": [\"Haemodoraceae\"],\"genus\": [\"Anigozanthos\"],\"scientificName\": [\"Anigozanthos\"]})\n\n   totalRecords\n0          5952\n\n\nAnother, shorter, way to write this query is by using the scientificName and scientificNameAuthorship as the taxon name. To test that we do get the same number of records, we can simply run\n\ngalah.atlas_counts(taxa=\"Anigozanthos Labill.\")\n\n   totalRecords\n0          5952\n\n\n\n\nDownloading occurrence records\nNow that we know the correct genus, we can start to download occurrence records. Since there are ~6000 records, let’s choose a smaller subset to draw buffers around. Since a breeding program was started in 2007 by Kings Park Botanic and Garden Board to protect the Kangaroo Paw from disease and the impact of climate changes, let’s only include occurrence records starting from 2007 onwards.\n\ngalah.atlas_counts(taxa=\"Anigozanthos Labill.\",filters=\"year&gt;=2007\")\n\n   totalRecords\n0          2374\n\n\n1936 is a more manageable number. However, there are different ways to observe a species. Since we want to only include ones humans have observed in the wild, we will add the filter basisOfRecord=HUMAN_OBSERVATION\n\ngalah.atlas_counts(taxa=\"Anigozanthos Labill.\",filters=[\"year&gt;=2007\",\"basisOfRecord=HUMAN_OBSERVATION\"])\n\n   totalRecords\n0          2102\n\n\nNow, we can download all occurrences of all species of Kangaroo Paw and plot it on a map to do an initial check that we have all records in Kangaroo Paw’s natural habitat, southwest WA.\n\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nkanga_paw_occ = galah.atlas_occurrences(taxa=\"Anigozanthos Labill.\",filters=[\"year&gt;=2007\",\"basisOfRecord=HUMAN_OBSERVATION\"])\nstates = gpd.read_file(\"STE_2021_AUST_GDA2020.shp\")\nstates = states.to_crs(4326)\nax = states.plot(edgecolor = \"#5A5A5A\", linewidth = 0.5, facecolor = \"white\", figsize = (12,6))\nplt.scatter(kanga_paw_occ['decimalLongitude'],kanga_paw_occ['decimalLatitude'], c = \"red\")\n\n\n\n\n\n\n\n\nHere, we can see that the ALA has records that are outside WA, and if we want to only draw a buffer region around species in Western Australia, we will have to filter out the points in the east. To do this, we will provide the polygon representing WA to atlas_occurrences() to remove the occurrences seen in the Eastern parts of Australia.\n\nkanga_paw_occ_pol = galah.atlas_occurrences(\n    taxa=\"Anigozanthos Labill.\",\n    filters=[\"year&gt;=2007\",\"basisOfRecord=HUMAN_OBSERVATION\"],\n    polygon = states[states[\"STE_NAME21\"] == \"Western Australia\"][\"geometry\"][4],\n    simplify_polygon=True,\n)\nax = states[states[\"STE_NAME21\"] == \"Western Australia\"].plot(edgecolor = \"#5A5A5A\", linewidth = 0.5, facecolor = \"white\", figsize = (12,6))\nplt.scatter(kanga_paw_occ_pol['decimalLongitude'],kanga_paw_occ_pol['decimalLatitude'], c = \"red\")\n\n\n\n\n\n\n\n\nNow, we have the occurrences we want.\n\ngalah.atlas_counts(\n    taxa=\"Anigozanthos Labill.\",\n    filters=[\"year&gt;=2007\",\"basisOfRecord=HUMAN_OBSERVATION\"],\n    polygon = states[states[\"STE_NAME21\"] == \"Western Australia\"][\"geometry\"][4],\n    simplify_polygon=True,\n    group_by=\"species\",\n    expand=False\n)\n\n                      species  count\n0        Anigozanthos bicolor     86\n1       Anigozanthos flavidus    179\n2      Anigozanthos gabrielae      2\n3        Anigozanthos humilis    602\n4  Anigozanthos kalbarriensis      1\n5      Anigozanthos manglesii    599\n6       Anigozanthos preissii     31\n7   Anigozanthos pulcherrimus      9\n8          Anigozanthos rufus    110\n9        Anigozanthos viridis     35\n\n\nWe can see that the most recorded species is Anigozanthos manglesii, which is the Red and Green Kangaroo Paw and the state emblem of WA. Since there are a decent number of records, but not as many as the entire genus, let’s choose to focus on the Red and Green Kangaroo Paw.\n\nanigozanthos_manglesii = galah.atlas_occurrences(\n    taxa = \"Anigozanthos manglesii\",\n    filters=[\"year&gt;=2007\",\"basisOfRecord=HUMAN_OBSERVATION\"],\n    polygon = states[states[\"STE_NAME21\"] == \"Western Australia\"][\"geometry\"][4],\n    simplify_polygon=True\n)\n\nWe can visualise these points to check that they are in the southwest corner of WA.\n\nax = states[states[\"STE_NAME21\"] == \"Western Australia\"].plot(edgecolor = \"#5A5A5A\", linewidth = 0.5, facecolor = \"white\", figsize = (12,6))\nplt.scatter(anigozanthos_manglesii['decimalLongitude'],anigozanthos_manglesii['decimalLatitude'], c = \"red\")\n\n\n\n\n\n\n\n\n\n\nAdding Buffers\nNow that we’ve got our occurrences, we can start adding buffers around these points. To do this, we will need the {shapely} package in Python. First, we will convert all of the decimalLongitude and decimalLatitude points to Point objects from {shapely}.\n\nimport shapely\nfrom shapely.geometry import Point,Polygon\npoints_angiozanthos_manglesii = [Point((row['decimalLongitude'],row['decimalLatitude'])) for i,row in anigozanthos_manglesii[['decimalLongitude','decimalLatitude']].iterrows()]\n\nNow that we have a list of all the points, we can add them to a geopandas DataFrame. This is so we can manipulate spatial data more easily than in pandas Dataframes. We will also set the Coordinate Reference System (CRS) to EPSG:4326, as this is the CRS of all ALA data points.\n\ngdf_anigozanthos_manglesii = gpd.GeoDataFrame(anigozanthos_manglesii,geometry=points_angiozanthos_manglesii)\ngdf_anigozanthos_manglesii.set_crs(epsg=4326, inplace=True)\n\n     decimalLatitude  decimalLongitude             eventDate                          scientificName                                    taxonConceptID                              recordID                   dataResourceName occurrenceStatus                     geometry\n0         -34.509491        117.012040  2019-10-22T10:37:53Z                  Anigozanthos manglesii  https://id.biodiversity.org.au/node/apni/2900921  24ccb120-2e37-4959-a198-a72629276e8e              iNaturalist Australia          PRESENT  POINT (117.01204 -34.50949)\n1         -34.509391        117.012412  2019-10-22T10:36:58Z                  Anigozanthos manglesii  https://id.biodiversity.org.au/node/apni/2900921  2c5cb0fe-01bd-4927-9ab7-607beaadb315              iNaturalist Australia          PRESENT  POINT (117.01241 -34.50939)\n2         -34.507979        116.907720  2021-10-30T14:55:00Z                  Anigozanthos manglesii  https://id.biodiversity.org.au/node/apni/2900921  57581a54-c592-4547-8864-f0f2034c91cf              iNaturalist Australia          PRESENT  POINT (116.90772 -34.50798)\n3         -34.448681        116.989865  2023-10-29T13:01:00Z                  Anigozanthos manglesii  https://id.biodiversity.org.au/node/apni/2900921  30a2c3ad-6386-4fdf-90a7-4fa81febed7b              iNaturalist Australia          PRESENT  POINT (116.98986 -34.44868)\n4         -34.437661        116.954487  2022-10-29T13:53:16Z                  Anigozanthos manglesii  https://id.biodiversity.org.au/node/apni/2900921  4097f747-ab3d-44da-bba6-98bedaf094ba              iNaturalist Australia          PRESENT  POINT (116.95449 -34.43766)\n..               ...               ...                   ...                                     ...                                               ...                                   ...                                ...              ...                          ...\n594       -27.677102        114.272375  2024-09-22T17:28:42Z                  Anigozanthos manglesii  https://id.biodiversity.org.au/node/apni/2900921  c4befee3-8225-4fc0-9c49-02dfae247127              iNaturalist Australia          PRESENT  POINT (114.27237 -27.67710)\n595       -27.663992        114.295055  2012-10-14T10:32:00Z                  Anigozanthos manglesii  https://id.biodiversity.org.au/node/apni/2900921  1aba7449-a3e1-4127-8ac6-d50bef684987              iNaturalist Australia          PRESENT  POINT (114.29506 -27.66399)\n596       -27.607720        114.420170  2011-09-20T13:44:00Z  Anigozanthos manglesii subsp. quadrans  https://id.biodiversity.org.au/node/apni/2894068  de617c68-bb47-4403-b355-9974bfba6df0              iNaturalist Australia          PRESENT  POINT (114.42017 -27.60772)\n597       -27.564815        114.425332  2016-09-10T16:27:00Z  Anigozanthos manglesii subsp. quadrans  https://id.biodiversity.org.au/node/apni/2894068  f9c14a93-baf9-41c1-b3a1-fe7a9709ffa7              iNaturalist Australia          PRESENT  POINT (114.42533 -27.56481)\n598       -27.260710        114.049158  2022-08-20T16:00:00Z                  Anigozanthos manglesii  https://id.biodiversity.org.au/node/apni/2900921  2788b724-4bbe-4979-aef7-9a9b34617ae7  ALA species sightings and OzAtlas          PRESENT  POINT (114.04916 -27.26071)\n\n[599 rows x 9 columns]\n\n\nNow, to add buffers of a certain radius, we have to convert our current CRS (which represents coordinates in degrees) to a CRS that represents coordinates in meters. This is so so we can directly add buffers in meters. For our example, we will be using EPSG:3577, which is Australian Albers, and a widely used CRS in Australia when one needs to use meters as a unit. This is likely different around the world, so be sure to check what CRS is right for your area.\n\ngdf_anigozanthos_manglesii_meters = gdf_anigozanthos_manglesii.to_crs(3577)\n\nNow, we will be creating five different buffers around our chosen points: 5km, 10km, 15km, 20km, and 25km. For each buffer radius, we will be adding a circle of the chosen radius around each point. We will then put them in a geodataframe so we can easily convert the buffers back from meters into degrees so they agree with our original points. Then, we will perform something called a unary_union, which is a function in shapely that allows you to unify many shapes into one shape object. We will then be storing this in a dictionary.\n\nbuffer_shapes = {}\nbuffer_lengths = {\"5km\": 5000, \"10km\": 10000,\"15km\": 15000,\"20km\": 20000,\"25km\": 20000}\nfor length in buffer_lengths:\n  buffers = [row[\"geometry\"].buffer(buffer_lengths[length]) for i,row in gdf_anigozanthos_manglesii_meters.iterrows()]\n  gdf_buffers = gpd.GeoSeries(buffers).set_crs(3577)\n  gdf_buffers_degrees = gdf_buffers.to_crs(4326)\n  union_buffers_degrees = shapely.unary_union(gdf_buffers_degrees)\n  buffer_shapes[length] = union_buffers_degrees\n\nNow, we can finally plot the buffers! Below is a code using the dictionary we just created to run a for loop over all the buffers to easily plot them, and also colour them in different colours.\n\nax = states[states[\"STE_NAME21\"] == \"Western Australia\"].plot(edgecolor = \"#5A5A5A\", linewidth = 0.5, facecolor = \"white\", figsize = (12,6))\nax.set_ylim([-34,-27])\nax.set_xlim([114,119])\ncolors = [\"red\",\"orange\",\"green\",\"purple\",\"black\"]\nplt.scatter(anigozanthos_manglesii['decimalLongitude'],anigozanthos_manglesii['decimalLatitude'], c = \"blue\", s = 2)\nfor i,length in enumerate(buffer_lengths):\n  for j,geom in enumerate(buffer_shapes[length].geoms):\n    if j==0:\n      plt.plot(*geom.exterior.xy,c=colors[i],lw=0.5,label=length)\n    else:\n      plt.plot(*geom.exterior.xy,c=colors[i],lw=0.5)\nplt.legend(fontsize=16)\n\n\n\n\n\n\n\n\n\n\n\n\nFinal thoughts\nWe hope this point has helped make the steps of adding buffers around points on a map clearer and easier. For more advanced mapping in Python, check out our ALA Labs article on how to map invasive species.\n\n\nExpand for session info\n\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.4.1 (2024-06-14 ucrt)\n os       Windows 10 x64 (build 19045)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Australia.utf8\n ctype    English_Australia.utf8\n tz       Australia/Sydney\n date     2024-10-29\n pandoc   3.1.11 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n htmltools   * 0.5.8.1 2024-04-04 [1] CRAN (R 4.4.1)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.3.2)\n\n [1] C:/Users/KEL329/R-packages\n [2] C:/Users/KEL329/AppData/Local/Programs/R/R-4.4.1/library\n\n─ Python configuration ───────────────────────────────────────────────────────\n python:         C:/Users/KEL329/OneDrive - CSIRO/Documents/ALA/Github/ala-labs/.venv/Scripts/python.exe\n libpython:      C:/Users/KEL329/AppData/Local/Programs/Python/Python312/python312.dll\n pythonhome:     C:/Users/KEL329/OneDrive - CSIRO/Documents/ALA/Github/ala-labs/.venv\n version:        3.12.0 (tags/v3.12.0:0fb18b0, Oct  2 2023, 13:03:39) [MSC v.1935 64 bit (AMD64)]\n Architecture:   64bit\n numpy:          C:/Users/KEL329/OneDrive - CSIRO/Documents/ALA/Github/ala-labs/.venv/Lib/site-packages/numpy\n numpy_version:  1.26.2\n \n NOTE: Python version was forced by VIRTUAL_ENV\n\n──────────────────────────────────────────────────────────────────────────────"
  },
  {
    "objectID": "posts/2025-07-20_species-lists-in-R/index.html",
    "href": "posts/2025-07-20_species-lists-in-R/index.html",
    "title": "Download a species list and cross-reference with conservation status lists in R",
    "section": "",
    "text": "Dax Kellie\nAmanda Buyan\n\n\n\n20 July 2025\nKnowing what species inhabit an area is important for conservation and ecosystem management. In particular, it can help us find how many known species are in a given area, and whether any species are vulnerable or endangered.\nIn this post, we will present two options, one using the galah package, the other using an external shapefile and list. Using either workflow, we will show you how to download a list of species within a Local Government Area (Shoalhaven, NSW), cross-reference this list with a state conservation status list, and visualise the number of threatened species in the region with waffle and ggplot2.\nLet’s first load our packages. To download species lists, you will also need to enter a registered email with the ALA using galah_config().\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(sf)\nlibrary(rmapshaper)\nlibrary(here)\nlibrary(pilot) # remotes::install_github(\"olihawkins/pilot\")\nlibrary(showtext)\nlibrary(galah)\n\n\ngalah_config(email = \"your-email-here\") # ALA-registered email"
  },
  {
    "objectID": "posts/2025-07-20_species-lists-in-R/index.html#footnotes",
    "href": "posts/2025-07-20_species-lists-in-R/index.html#footnotes",
    "title": "Download a species list and cross-reference with conservation status lists in R",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nEach spatial layer has a two letter code, along with a number to identify it. The abbreviations are as follows:\n* cl = contextual layer (i.e. boundaries of LGAs, Indigenous Protected Areas, States/Territories etc.)\n* 11170 = number associated with the spatial layer in the atlas↩︎\nWe used right_join() this time because we wanted to first select columns from nsw_threatened, then join so that we keep all 90+ rows in threatened (using left_join() would keep all 1,000+ rows in nsw_threatened instead).↩︎\nSimplifying a shapefile removes the number of total points that draw the shape outline.↩︎\nCheck out this post for a better explanation of what CRS is and how it affects maps.↩︎\nOn a related note, it’s possible to download a list specifically for Shoalhaven on the BioNet Atlas website. However, results from BioNet will be matched BioNet records only. As a result, fewer species will be identifed compared to the ALA, which matches NSW BioNet data as well as data from other sources.↩︎\nWe can double check status information by viewing the species list in Excel and clicking on links in the info column. This is handy for double checking species status codes or learning more about each species and status.↩︎\nThis is due to differences in taxonomic names in the externally downloaded list and in ALA data. More info can be found under the “Names Matching” tab in the Shapefile + list section.↩︎"
  },
  {
    "objectID": "research/highlights/2025_wetland-restoration/index.html",
    "href": "research/highlights/2025_wetland-restoration/index.html",
    "title": "Selecting tree species for wetland restoration",
    "section": "",
    "text": "Leptospermum brachyandrum (Russell Cumming CC BY NC 4.0)\n\n\nCitation\n\n\nCanning, Adam D. (2025) Scoping the suitability of water-tolerant species of trees for swamp restorations across Australia and its Great Barrier Reef catchment. Ecological Restoration https://doi.org/10.1111/rec.14375\n\n\n\nPage info\nPrepared by Olivia Torresan\n\n\n\n\n\nWetlands are some of the most ecologically diverse and productive ecosystems on the planet. They help provide food, filter water, protect from floods, sequester carbon, and even provide timber for construction. However, many wetlands in Australia have degraded or have been drained for development.\nAs our appreciation grows of the importance of wetlands, the challenge also grows to identify suitable areas and key species to plant for successful restoration. This challenge is especially pressing in regions like the Greater Barrier Reef catchment area which supports the health of its neighbouring, World Heritage-listed coral reef.\nThis study aimed to address this problem by identifying suitable tree species able to be planted in existing or potential wetland regions across Australia, considering their differences in climate, soil and water availability. Areas with high development rates or agricultural versatility were removed, as these were considered generally undesirable to restore. Suitable tree species were identified using water-tolerance trait and occurrence data, retrieved from the ALA.\nFor the Great Barrier Reef catchment, 2,230 land parcels (0.2ha each in size) were identified as highly suitable for potential wetland restoration (i.e. 4.5 square kilometers total). The most widely suitable species across all identified parcels in this region were found to be: Melaleuca trichostachya, Melaleuca bracteata, Leptospermum brachyandrum, Melaleuca viridiflora, Ventilago viminalis, Aegiceras corniculatum, and Avicennia marina.\nThese findings will help restoration teams make more informed decisions on what areas to prioritise for wetland regeneration, and what species of tree might have a higher likelihood to survive over time."
  },
  {
    "objectID": "research/highlights/index.html",
    "href": "research/highlights/index.html",
    "title": "Research highlights",
    "section": "",
    "text": "No matching items"
  },
  {
    "objectID": "posts/2025-08-26_adding-buffers-in-python/index.html",
    "href": "posts/2025-08-26_adding-buffers-in-python/index.html",
    "title": "Add a buffer to a shapefile and account for obfuscated species locations",
    "section": "",
    "text": "Amanda Buyan\nDax Kellie\n\n\n\n26 August 2025\nEcological data is often used to understand what species are found in a given location, especially for conservation monitoring and environmental impact assessment prior to land development. A common method for this task is to use a buffer, an outward boundary around a given area location. Adding a buffer helps to capture all the species in an area, including those that have been observed just outside the area and probably live there, too.\nChoosing a buffer size, however, can be tougher than it seems. Individual organisms move, either over the course of a day or an entire season (e.g. migration, perennial growth), so species’ lifecycles and behaviours may determine the size of our final buffer. A more difficult challenge occurs when species are considered sensitive, vulnerable or endangered. These species’ exact point locations are often obfuscated (aka their location is made less precise) to keep these species safe. This added imprecision will again affect our final decision on buffer size.\nIn this post, we’ll show how to add a buffer around a shapefile with {geopandas}, {shapely} and {matplotlib}. Then we will use {galah-python} to download data of Stuttering frogs (Mixophyes balbus) to demonstrate how the size of a buffer can affect the detection of threatened species in an area. Lastly, we will use {scipy} and {matplotlib} to show the effect of buffers on detecting threatened species in an area."
  },
  {
    "objectID": "posts/2025-08-26_adding-buffers-in-python/index.html#footnotes",
    "href": "posts/2025-08-26_adding-buffers-in-python/index.html#footnotes",
    "title": "Add a buffer to a shapefile and account for obfuscated species locations",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nCheck out this section of a previous ALA Labs post for a more complete explanation of what a CRS is.↩︎\nALA data is projected using CRS EPSG:4326 (the same one used by Google Earth).↩︎\nAlternatively, iNaturalist randomises their coordinate locations at a 30 km resolution prior to sharing data with the Atlas of Living Australia.↩︎\nSome records, if the species is very sensitive, may be witheld altogether.↩︎\nHow nearby is relative to the degree of generalisation, so what we mean by “near” varies↩︎\nGeneralising data points is good because it makes it very difficult know the specific location of an observation when access to this information should be restricted for some reason (i.e., endangered, subject to poaching or misuse, privacy concerns). However, it can also make data more difficult to work with because data points are shifted to new locations. In some cases, it can even cause data points to appear in the ocean despite the true location being on land!↩︎\nhttps://en.wikipedia.org/wiki/Stuttering_frog↩︎\nDownloading all occurrence records using a bounding box then filtering the records to fit a shapefile can be a quicker way to subset records (rather than waiting for the API to process a more complex shapefile polygon shape). You can find a more in-depth article on this here.↩︎\nIt’s faster to use a bounding box than polygon shape to download records - a box has fewer points than a complicated polygon shape, making for a far simpler query to process!↩︎"
  }
]